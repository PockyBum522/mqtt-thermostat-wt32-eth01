{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"AutoConnect for ESP8266/ESP32","text":"<p>An Arduino library for ESP8266/ESP32 WLAN configuration at run time with web interface.</p>"},{"location":"index.html#overview","title":"Overview","text":"<p>To the dynamic configuration for joining to WLAN with SSID and PSK accordingly. It an Arduino library united with ESP8266WebServer class for ESP8266 or WebServer class for ESP32. Easy implementing the Web interface constituting the WLAN for ESP8266/ESP32 WiFi connection. With this library to make a Sketch easily which connects from ESP8266/ESP32 to the access point at runtime by the web interface without hard-coded SSID and password.</p> <p></p>"},{"location":"index.html#no-need-pre-coded-ssid-password","title":"No need pre-coded SSID &amp; password","text":"<p>It is no needed hard-coding in advance the SSID and Password into the Sketch to connect between ESP8266/ESP32 and WLAN. You can input SSID &amp; Password from a smartphone via the web interface at runtime.</p>"},{"location":"index.html#simple-usage","title":"Simple usage","text":"<p>AutoConnect control screen will be displayed automatically for establishing new connections. It aids by the captive portal when vested the connection cannot be detected.By using the AutoConnect menu, to manage the connections convenient.</p>"},{"location":"index.html#store-the-established-connection","title":"Store the established connection","text":"<p>The connection authentication data as credentials are saved automatically in the flash of ESP8266/ESP32 and You can select the past SSID from the AutoConnect menu.</p>"},{"location":"index.html#easy-to-embed-in","title":"Easy to embed in","text":"<p>AutoConnect can be placed easily in your Sketch. It's \"begin\" and \"handleClient\" only.</p>"},{"location":"index.html#lives-with-your-sketches","title":"Lives with your Sketches","text":"<p>The Sketches which provide the web page using ESP8266WebServer there is, AutoConnect will not disturb it. AutoConnect can use an already instantiated ESP8266WebServer object, or itself can assign it. This effect also applies to ESP32. The corresponding class for ESP32 will be the WebServer.</p>"},{"location":"index.html#easy-to-add-the-custom-web-pages-enhanced-wv097","title":"Easy to add the custom Web pages ENHANCED w/v0.9.7","text":"<p>You can easily add your owned web pages that can consist of representative HTML elements and invoke them from the menu. Further it possible importing the custom Web pages declarations described with JSON which stored in PROGMEM, SPIFFS, or SD.</p>"},{"location":"index.html#quick-and-easy-to-equip-the-ota-update-feature-updated-wv115","title":"Quick and easy to equip the OTA update feature UPDATED w/v1.1.5","text":"<p>You can quickly and easily equip the OTA update feature to your Sketch and also you can operate the firmware update process via OTA from AutoConnect menu.</p> <p></p>"},{"location":"index.html#installation","title":"Installation","text":""},{"location":"index.html#requirements","title":"Requirements","text":""},{"location":"index.html#supported-hardware","title":"Supported hardware","text":"<ul> <li> Generic ESP8266 modules (applying the ESP8266 Community's Arduino core)</li> <li> Adafruit HUZZAH ESP8266 (ESP-12)</li> <li> ESP-WROOM-02</li> <li> Heltec WiFi Kit 8</li> <li> NodeMCU 0.9 (ESP-12) / NodeMCU 1.0 (ESP-12E)</li> <li> Olimex MOD-WIFI-ESP8266</li> <li> SparkFun Thing</li> <li> SweetPea ESP-210</li> <li> ESP32Dev Board (applying the Espressif's arduino-esp32 core)</li> <li> SparkFun ESP32 Thing</li> <li> WEMOS LOLIN D32</li> <li> Ai-Thinker NodeMCU-32S</li> <li> Heltec WiFi Kit 32</li> <li> M5Stack</li> <li> And other ESP8266/ESP32 modules supported by the Additional Board Manager URLs of the Arduino-IDE.</li> </ul> <p>About flash size on the module</p> <p>The AutoConnect Sketch size is relatively large. Large flash capacity is necessary. 512Kbyte (4Mbits) flash inclusion module such as ESP-01 is not recommended.</p>"},{"location":"index.html#required-libraries","title":"Required libraries","text":"<p>AutoConnect requires the following environment and libraries.</p> <p> Arduino IDE</p> <p>The current upstream at the 1.8 level or later is needed. Please install from the official Arduino IDE download page. This step is not required if you already have a modern version.</p> <p> ESP8266 Arduino core</p> <p>AutoConnect targets Sketches made on the assumption of ESP8266 Community's Arduino core. Stable 2.4.0 or higher required and the latest release is recommended. Install third-party platform using the Boards Manager of Arduino IDE. Package URL is http://arduino.esp8266.com/stable/package_esp8266com_index.json</p> <p> ESP32 Arduino core</p> <p>Also, to apply AutoConnect to ESP32, the arduino-esp32 core provided by Espressif is needed. Stable 1.0.1 or required and the latest release is recommended. Install third-party platform using the Boards Manager of Arduino IDE. You can add multiple URLs into Additional Board Manager URLs field, separating them with commas. Package URL is https://dl.espressif.com/dl/package_esp32_index.json for ESP32.</p> <p>Arduino core for ESP32 1.0.3 or later</p> <p>For ESP32, AutoConnect v1.0.0 later is required for arduino-esp32 1.0.3 or later.</p> <p> Additional library (Required)</p> <p>The PageBuilder library to build HTML for ESP8266WebServer is needed. To install the PageBuilder library into your Arduino IDE, you can use the Library Manager. Select the board of ESP8266 series in the Arduino IDE, open the library manager and search keyword 'PageBuilder' with the topic 'Communication', then you can see the PageBuilder. The latest version is required 1.4.2 later.1</p> <p></p> <p> Additional library (Optional)</p> <p>By adding the ArduinoJson library, AutoConnect will be able to handle the custom Web pages described with JSON. Since AutoConnect v0.9.7 you can insert user-owned web pages that can consist of representative HTML elements as styled TEXT, INPUT, BUTTON, CHECKBOX, SELECT, SUBMIT and invoke them from the AutoConnect menu. These HTML elements can be added by Sketches using the AutoConnect API. Further it possible importing the custom Web pages declarations described with JSON which stored in PROGMEM, SPIFFS, or SD. ArduinoJson is required to use this feature.2 AutoConnect can work with ArduinoJson both version 5 and version 6.</p>"},{"location":"index.html#install-the-autoconnect","title":"Install the AutoConnect","text":"<p>Clone or download from the AutoConnect GitHub repository.</p> <p></p> <p>When you select Download, you can import it to Arduino IDE immediately. After downloaded, the AutoConnect-master.zip file will be saved in your download folder. Then in the Arduino IDE, navigate to \"Sketch &gt; Include Library\". At the top of the drop down list, select the option to \"Add .ZIP Library...\". Details for Arduino official page.</p> <p></p> <p>Supported by Library manager.</p> <p>AutoConnect was added to the Arduino IDE library manager. It can be used with the PlatformIO library also.</p> <ol> <li> <p>Since AutoConnect v1.2.3, PageBuilder v1.5.0 later is required.\u00a0\u21a9</p> </li> <li> <p>Using the AutoConnect API natively allows you to Sketch custom Web pages without JSON.\u00a0\u21a9</p> </li> </ol>"},{"location":"acelements.html","title":"AutoConnectElements","text":""},{"location":"acelements.html#the-elements-for-the-custom-web-pages","title":"The elements for the custom Web pages","text":"<p>Representative HTML elements for making the custom Web page are provided as AutoConnectElements.</p> <ul> <li>AutoConnectButton: Labeled action button</li> <li>AutoConnectCheckbox: Labeled checkbox</li> <li>AutoConnectElement: General tag</li> <li>AutoConnectFile: File uploader</li> <li>AutoConnectInput: Labeled text input box</li> <li>AutoConnectRadio: Labeled radio button</li> <li>AutoConnectRange: Labeled range slider</li> <li>AutoConnectSelect: Selection list</li> <li>AutoConnectStyle: Custom CSS code</li> <li>AutoConnectSubmit: Submit button</li> <li>AutoConnectText: Style attributed text</li> </ul>"},{"location":"acelements.html#layout-on-a-custom-web-page","title":"Layout on a custom Web page","text":"<p>AutoConnect will not actively be involved in the layout of custom Web pages generated from AutoConnectElements. However, each element has an attribute to arrange placement on a custom web page by horizontally or vertically.</p>"},{"location":"acelements.html#custom-css-for-a-custom-web-page","title":"Custom CSS for a custom Web page","text":"<p>All custom Web page styles are limited to the built-in unique CSS embedded in the library code. Direct modification of the CSS affects AutoConnect behavior. You can use dedicated elements to relatively safely modify the style of your custom Web page. The AutoConnectStyle will insert the raw CSS code into the style block in HTML of the custom Web page.</p>"},{"location":"acelements.html#form-and-autoconnectelements","title":"Form and AutoConnectElements","text":"<p>All AutoConnectElements placed on custom web pages will be contained into one form. Its form is fixed and created by AutoConnect. The form value (usually the text or checkbox you entered) is sent by AutoConnectSubmit using the POST method with HTTP. The post method sends the actual form data which is a query string whose contents are the name and value of AutoConnectElements. You can retrieve the value for the parameter with the Sketch from the query string with ESP8266WebServer::arg function or PageArgument class of the AutoConnect::on handler when the form is submitted.</p>"},{"location":"acelements.html#autoconnectelement-a-basic-class-of-elements","title":"AutoConnectElement - A basic class of elements","text":"<p>AutoConnectElement is a base class for other element classes and has common attributes for all elements. It can also be used as a variant of each element. The following items are attributes that AutoConnectElement has and are common to other elements.</p> <p> Sample <code>AutoConnectElement element(\"element\", \"&lt;hr&gt;\");</code></p> <p>On the page:</p>"},{"location":"acelements.html#constructor","title":"Constructor","text":"<pre><code>AutoConnectElement(const char* name, const char* value, const ACPosterior_t post)\n</code></pre>"},{"location":"acelements.html#name","title":"name","text":"<p>Each element has a name. The name is the String data type. You can identify each element by the name to access it with sketches. </p>"},{"location":"acelements.html#value","title":"value","text":"<p>The value is the string which is a source to generate an HTML code. Characteristics of Value vary depending on the element. The value of AutoConnectElement is native HTML code. A string of value is output as HTML as it is.</p>"},{"location":"acelements.html#post","title":"post","text":"<p>The post specifies a tag to add behind the HTML code generated from the element. Its purpose is to place elements on the custom Web page as intended by the user sketch. AutoConnect will not actively be involved in the layout of custom Web pages generated from AutoConnectElements. Each element follows behind the previous one, with the exception of some elements. You can use the post value to arrange vertically or horizontal when the elements do not have the intended position on the custom Web Page specifying the following enumeration value as ACPosterior_t type for the post.</p> <ul> <li><code>AC_Tag_None</code> : No generate additional tags.</li> <li><code>AC_Tag_BR</code> : Add a <code>&lt;br&gt;</code> tag to the end of the element.</li> <li><code>AC_Tag_P</code> : Include the element in the <code>&lt;p&gt; ~ &lt;/p&gt;</code> tag.</li> <li><code>AC_Tag_DIV</code> : Include the element in the <code>&lt;div&gt; ~ &lt;/div&gt;</code> tag.</li> </ul> <p>The default interpretation of the post value is specific to each element.</p> AutoConnectElements Default interpretation of the post value AutoConnectElement AC_Tag_None AutoConnectButton AC_Tag_None AutoConnectCheckBox AC_Tag_BR AutoConnectFile AC_Tag_BR AutoConnectInput AC_Tag_BR AutoConnectRadio AC_Tag_BR AutoConnectRange AC_Tag_BR AutoConnectSelect AC_Tag_BR AutoConnectSubmit AC_Tag_None AutoConnectText AC_Tag_None <p>A placement posterior of AutoConnectText</p> <p>A placement posterior for AutoConnectText has a slightly peculiar specification. AutoConnectText element without the style attribute will be drained to HTML as a raw value and is accompanied by <code>&lt;p&gt;</code>, <code>&lt;br&gt;</code> or <code>&lt;div&gt;</code> tags according to the post enumeration values.   If the style attribute is specified, the post enumeration value will be ignored and always be enclosed in the <code>&lt;div&gt;</code> tag, and the style value will be inserted into <code>style</code> attribute of the <code>&lt;div&gt;</code> tag.</p>"},{"location":"acelements.html#type","title":"type","text":"<p>The type indicates the type of the element and represented as the ACElement_t enumeration type in the Sketch. Since AutoConnectElement also acts as a variant of other elements, it can be applied to handle elements collectively. At that time, the type can be referred to by the typeOf() function. The following example changes the font color of all AutoConnectText elements of a custom Web page to gray.</p> <pre><code>AutoConnectAux  customPage;\n\nAutoConnectElementVT&amp; elements = customPage.getElements();\nfor (AutoConnectElement&amp; elm : elements) {\nif (elm.typeOf() == AC_Text) {\n    AutoConnectText&amp; text = reinterpret_cast&lt;AutoConnectText&amp;&gt;(elm);\n    text.style = \"color:gray;\";\n  }\n}\n</code></pre> <p>The enumerators for ACElement_t are as follows:</p> <ul> <li>AutoConnectButton: AC_Button</li> <li>AutoConnectCheckbox: AC_Checkbox </li> <li>AutoConnectElement: AC_Element</li> <li>AutoConnectFile: AC_File</li> <li>AutoConnectInput: AC_Input</li> <li>AutoConnectRadio: AC_Radio</li> <li>AutoConnectRange: AC_Range</li> <li>AutoConnectSelect: AC_Select</li> <li>AutoConnectStyle: AC_Style</li> <li>AutoConnectSubmit: AC_Submit</li> <li>AutoConnectText: AC_Text</li> <li>Uninitialized element: AC_Unknown</li> </ul> <p>Furthermore, to convert an entity that is not an AutoConnectElement to its native type, you must re-interpret that type with c++. Or, you can be coding the Sketch more easily with using the as&lt;T&gt; function.</p> <pre><code>AutoConnectAux  customPage;\n\nAutoConnectElementVT&amp; elements = customPage.getElements();\nfor (AutoConnectElement&amp; elm : elements) {\nif (elm.type() == AC_Text) {\n    AutoConnectText&amp; text = customPage[elm.name].as&lt;AutoConnectText&gt;();\n    text.style = \"color:gray;\";\n// Or, it is also possible to write the code further reduced as follows.\n// customPage[elm.name].as&lt;AutoConnectText&gt;().style = \"color:gray;\";\n  }\n}\n</code></pre>"},{"location":"acelements.html#autoconnectbutton","title":"AutoConnectButton","text":"<p>AutoConnectButton generates an HTML <code>&lt;button type=\"button\"&gt;</code> tag and locates a clickable button to a custom Web page. Currently AutoConnectButton corresponds only to name, value, an onclick attribute of HTML button tag. An onclick attribute is generated from an <code>action</code> member variable of the AutoConnectButton, which is mostly used with a JavaScript to activate a script.</p> <p> Sample <code>AutoConnectButton button(\"button\", \"OK\", \"myFunction()\");</code></p> <p>On the page:</p>"},{"location":"acelements.html#constructor_1","title":"Constructor","text":"<pre><code>AutoConnectButton(const char* name, const char* value, const String&amp; action, const ACPosterior_t post)\n</code></pre>"},{"location":"acelements.html#name_1","title":"name","text":"<p>It is the <code>name</code> of the AutoConnectButton element and matches the name attribute of the button tag. It also becomes the parameter name of the query string when submitted.</p>"},{"location":"acelements.html#value_1","title":"value","text":"<p>It becomes a value of the <code>value</code> attribute of an HTML button tag.</p>"},{"location":"acelements.html#action","title":"action","text":"<p>action is String data type and is an onclick attribute fire on a mouse click on the element. It is mostly used with a JavaScript to activate a script.1 For example, the following code defines a custom Web page that copies a content of <code>Text1</code> to <code>Text2</code> by clicking <code>Button</code>.</p> <pre><code>const char* scCopyText = R\"(\n&lt;script&gt;\nfunction CopyText() {\n  document.getElementById(\"Text2\").value = document.getElementById(\"Text1\").value;\n}\n&lt;/script&gt;\n)\";\nACInput(Text1, \"Text1\");\nACInput(Text2, \"Text2\");\nACButton(Button, \"COPY\", \"CopyText()\");\nACElement(TextCopy, scCopyText);\n</code></pre>"},{"location":"acelements.html#post_1","title":"post","text":"<p>Specifies a tag to add behind the HTML code generated from the element. The default values is <code>AC_Tag_None</code>.</p>"},{"location":"acelements.html#autoconnectcheckbox","title":"AutoConnectCheckbox","text":"<p>AutoConnectCheckbox generates an HTML <code>&lt;input type=\"checkbox\"&gt;</code> tag and a <code>&lt;label&gt;</code> tag. It places horizontally on a custom Web page by default.</p> <p> Sample <code>AutoConnectCheckbox checkbox(\"checkbox\", \"uniqueapid\", \"Use APID unique\", false);</code></p> <p>On the page:</p>"},{"location":"acelements.html#constructor_2","title":"Constructor","text":"<pre><code>AutoConnectCheckbox(const char* name, const char* value, const char* label, const bool checked, const ACPosition_t labelPosition, const ACPosterior_t post)\n</code></pre>"},{"location":"acelements.html#name_2","title":"name","text":"<p>It is the <code>name</code> of the AutoConnectCheckbox element and matches the name attribute of the input tag. It also becomes the parameter name of the query string when submitted.</p>"},{"location":"acelements.html#value_2","title":"value","text":"<p>It becomes a value of the <code>value</code> attribute of an HTML <code>&lt;input type=\"checkbox\"&gt;</code> tag.</p>"},{"location":"acelements.html#label","title":"label","text":"<p>A label is an optional string. A label is always arranged on the right side of the checkbox. Specification of a label will generate an HTML <code>&lt;label&gt;</code> tag with an <code>id</code> attribute. The checkbox and the label are connected by the id attribute.  Only  will be displayed if a label is not specified.</p>"},{"location":"acelements.html#checked","title":"checked","text":"<p>A checked is a Boolean value and indicates the checked status of the checkbox. The value of the checked checkbox element is packed in the query string and sent.</p>"},{"location":"acelements.html#labelposition","title":"labelPosition","text":"<p>The position of the label belonging to the checkbox can be specified around the element. The labelPosition specifies the position of the label to generate with ACPostion_t enumeration value. The default value is <code>AC_Behind</code>.</p> <ul> <li><code>AC_Infront</code> : Place a label in front of the check box.</li> <li><code>AC_Behind</code> : Place a label behind the check box.</li> </ul>"},{"location":"acelements.html#post_2","title":"post","text":"<p>Specifies a tag to add behind the HTML code generated from the element. The default values is <code>AC_Tag_BR</code>.</p>"},{"location":"acelements.html#autoconnectfile","title":"AutoConnectFile","text":"<p>AutoConnectFile generates an HTML <code>&lt;input type=\"file\"&gt;</code> tag and a <code>&lt;label&gt;</code> tag. AutoConnectFile enables file upload from the client through the web browser to ESP8266/ESP32 module. You can select the flash in the module, external SD device or any output destination as the storage of the uploaded file.</p> <p> Sample <code>AutoConnectFile file(\"file\", \"\", \"Upload:\", AC_File_FS)</code></p> <p>On the page:</p>"},{"location":"acelements.html#constructor_3","title":"Constructor","text":"<pre><code>AutoConnectFile(const char* name, const char* value, const char* label, const ACFile_t store, const ACPosterior_t post)\n</code></pre>"},{"location":"acelements.html#name_3","title":"name","text":"<p>It is the <code>name</code> of the AutoConnectFile element and matches the name attribute of the input tag. It also becomes the parameter name of the query string when submitted.</p>"},{"location":"acelements.html#value_3","title":"value","text":"<p>File name to be upload. The value contains the value entered by the client browser to the <code>&lt;input type=\"file\"&gt;</code> tag and is read-only. Even If you give a value to the constructor, it does not affect as an initial value like a default file name.</p>"},{"location":"acelements.html#label_1","title":"label","text":"<p>A <code>label</code> is an optional string. A label is always arranged on the left side of the input box. Specification of a label will generate an HTML <code>&lt;label&gt;</code> tag with an id attribute. The input box and the label are connected by the id attribute.</p>"},{"location":"acelements.html#store","title":"store","text":"<p>Specifies the destination to save the uploaded file. The destination can be specified the following values in the ACFile_t enumeration type.</p> <ul> <li><code>AC_File_FS</code> : Save as the SPIFFS file in flash of ESP8266/ESP32 module.</li> <li><code>AC_File_SD</code> : Save to an external SD device connected to ESP8266/ESP32 module.</li> <li><code>AC_File_Extern</code> : Pass the content of the uploaded file to the uploader which is declared by the Sketch individually. Its uploader must inherit AutoConnectUploadHandler class and implements _open, _write and _close function.</li> </ul> <p>Built-in uploader is ready.</p> <p>AutoConnect already equips the built-in uploader for saving to the SPIFFS as AC_File_FS and the external SD as AC_File_SD. It is already implemented inside AutoConnect and will store uploaded file automatically.</p>"},{"location":"acelements.html#post_3","title":"post","text":"<p>Specifies a tag to add behind the HTML code generated from the element. The default values is <code>AC_Tag_BR</code>.</p>"},{"location":"acelements.html#autoconnectinput","title":"AutoConnectInput","text":"<p>AutoConnectInput generates an HTML <code>&lt;input type=\"text\"&gt;</code>, <code>&lt;input type=\"number\"&gt;</code> or <code>&lt;input type=\"password\"&gt;</code> tag and a <code>&lt;label&gt;</code> tag. It can also have a placeholder. The value of the input box is passed to the destination in the query string and can be retrieved programmatically. You can also update from the Sketches.</p> <p> Sample <code>AutoConnectInput input(\"input\", \"\", \"Server\", \"MQTT broker server\");</code></p> <p>On the page:</p>"},{"location":"acelements.html#constructor_4","title":"Constructor","text":"<pre><code>AutoConnectInput(const char* name, const char* value, const char* label, const char* pattern, const char* placeholder, const ACPosterior_t post, const ACInput_t apply)\n</code></pre>"},{"location":"acelements.html#name_4","title":"name","text":"<p>It is the <code>name</code> of the AutoConnectInput element and matches the name attribute, the id attribute of the input tag. It also becomes the parameter name of the query string when submitted.</p>"},{"location":"acelements.html#value_4","title":"value","text":"<p>It becomes a string value of the <code>value</code> attribute of an HTML <code>&lt;input type=\"text\"&gt;</code> tag. The text entered from the custom Web page will be grouped in the query string of the form submission and the string set before accessing the page will be displayed as the initial value.</p>"},{"location":"acelements.html#label_2","title":"label","text":"<p>A <code>label</code> is an optional string. A label is always arranged on the left side of the input box. Specification of a label will generate an HTML <code>&lt;label&gt;</code> tag with an id attribute. The input box and the label are connected by the id attribute.</p>"},{"location":"acelements.html#pattern","title":"pattern","text":"<p>A <code>pattern</code> specifies a regular expression that the AutoConnectInput element's value is checked against on form submission. If it is invalid, the background color will change, but it will be sent even if the data format does not match. To check whether the entered value matches the pattern, use the isValid function.</p> <ul> <li>The password that must contain 8 or more characters that are of at least one number, and one uppercase and lowercase letter:<code>(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,}</code></li> <li> <p>Email address as characters@characters.domain:<code>[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,}</code></p> </li> <li> <p>IP address:<code>(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])</code></p> </li> <li> <p>Host name of Internet:<code>(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])</code></p> </li> <li> <p>Date (MM/DD/YYYY) as range 1900-2099:<code>(0[1-9]|1[012])[- \\/.](0[1-9]|[12][0-9]|3[01])[- \\/.](19|20)\\d\\d</code></p> </li> <li> <p>Twitter account:<code>^@?(\\w){1,15}$</code></p> </li> </ul>"},{"location":"acelements.html#placeholder","title":"placeholder","text":"<p>A placeholder is an option string. Specification of a placeholder will generate a <code>placeholder</code> attribute for the input tag.</p>"},{"location":"acelements.html#post_4","title":"post","text":"<p>Specifies a tag to add behind the HTML code generated from the element. The default values is <code>AC_Tag_BR</code>.</p>"},{"location":"acelements.html#apply","title":"apply","text":"<p>Specifies the type of input that the text box accepts. AutoConnectInput will generate either a <code>input type=\"text\"</code>, <code>input type=\"password\"</code>, or <code>input type=\"number\"</code> tag based on the <code>apply</code> specifying as input type. The input type can be specified the following values in the ACInput_t enumeration type.</p> <ul> <li><code>AC_Input_Text</code> : <code>input type=\"text\"</code></li> <li><code>AC_Input_Password</code> : <code>input type=\"password\"</code></li> <li><code>AC_Input_Number</code> : <code>input type=\"number\"</code></li> </ul> <p>Numerical keypad is different</p> <p>When the AutoConnectInput element with the <code>AC_Input_Number</code> applied is focused on the browser, the numeric keypad may be displayed automatically. For popular mobile OSes such as Android and iOS, the numeric keypad has the following styles and is different with each OS. </p>"},{"location":"acelements.html#autoconnectradio","title":"AutoConnectRadio","text":"<p>AutoConnectRadio generates several HTML <code>&lt;input type=\"radio\"&gt;</code> tags grouped together. It also assigns an equal number of <code>&lt;label&gt;</code> tags to each <code>&lt;input type=\"radio\"&gt;</code> tag and stores the values of the choices that make up a radio button as a String collection.</p> <p> Sample <code>AutoConnectRadio radio(\"radio\", { \"30 sec.\", \"60 sec.\", \"180 sec.\" }, \"Update period\", AC_Vertical, 1);</code></p> <p>On the page:</p>"},{"location":"acelements.html#constructor_5","title":"Constructor","text":"<pre><code>AutoConnectRadio(const char* name, std::vector&lt;String&gt; const&amp; values, const char* label, const ACArrange_t order, const uint8_t checked, const ACPosterior_t post)\n</code></pre>"},{"location":"acelements.html#name_5","title":"name","text":"<p>It is the name of the AutoConnectRadio element, which matches the name attribute of the input tag and defines the radio group by this name. It is also the <code>name</code> parameter in the query string during submission.</p>"},{"location":"acelements.html#values","title":"values","text":"<p>A group of radio buttons is a set of <code>&lt;input type=\"radio\"&gt;</code> tags with the same name; AutoConnectRadio defines a radio group based on an array of Strings specified as values. A <code>values</code> is an array of String, actually a std::vector. The sketch can allocate its String array using std::vector's List-initialization.</p>"},{"location":"acelements.html#label_3","title":"label","text":"<p>A label is an optional string. A label will be arranged in the left or top of the radio buttons according to the order. Specification of a label will generate an HTML <code>&lt;label&gt;</code> tag with an <code>id</code> attribute. The radio buttons and the label are connected by the id attribute.</p>"},{"location":"acelements.html#order","title":"order","text":"<p>A <code>order</code> specifies the direction to arrange the radio buttons. It is a value of type <code>ACArrange_t</code> and accepts one of the following:</p> <ul> <li><code>AC_Horizontal</code> : Horizontal arrangement.</li> <li><code>AC_Vertical</code> : Vertical arrangement.</li> </ul> <p>A label will place in the left or the top according to the order.</p>"},{"location":"acelements.html#checked_1","title":"checked","text":"<p>A <code>checked</code> specifies the index number (1-based) of the values to be checked. If this parameter is not specified neither item is checked.</p>"},{"location":"acelements.html#post_5","title":"post","text":"<p>Specifies a tag to add behind the HTML code generated from the element. The default values is <code>AC_Tag_BR</code>.</p>"},{"location":"acelements.html#autoconnectrange","title":"AutoConnectRange","text":"<p>AutoConnectRange generates an HTML <code>&lt;input type=\"range\"&gt;</code> tag and a <code>&lt;label&gt;</code> tag.</p> <p> Sample <code>AutoConnectRange range(\"bri\", 0, \"Brightness\", -2, 2, 1, AC_Infront);</code></p> <p>On the page:</p>"},{"location":"acelements.html#constructor_6","title":"Constructor","text":"<pre><code>AutoConnectRange(const char* name, const int value, const char* label, const int min, const int max, const int step, const ACPosition_t magnify, const ACPosterior_t post, const char* style)\n</code></pre>"},{"location":"acelements.html#name_6","title":"name","text":"<p>It is the <code>name</code> of the AutoConnectRange element and matches the name attribute, the id attribute of the input tag. It also becomes the parameter name of the query string when submitted.</p>"},{"location":"acelements.html#value_5","title":"value","text":"<p>It becomes a string value of the <code>value</code> attribute of an HTML <code>&lt;input type=\"range\"&gt;</code> tag, which indicates the default value of the range.</p>"},{"location":"acelements.html#label_4","title":"label","text":"<p>A <code>label</code> is an optional string. A label is always arranged on the left side of the range slider. Specification of a label will generate an HTML <code>&lt;label&gt;</code> tag with an id attribute. The range slider and the label are connected by the id attribute.</p>"},{"location":"acelements.html#min","title":"min","text":"<p>Specifies the most negative value within the range of allowed values and must not be less than the <code>value</code> argument.</p>"},{"location":"acelements.html#max","title":"max","text":"<p>It defines the greatest value in the range of permitted values.</p>"},{"location":"acelements.html#step","title":"step","text":"<p>It is a number that specifies the granularity that the value must adhere to. The default is 1. As you move the slider, it increases or decreases the value according to the <code>step</code> in granularity.</p>"},{"location":"acelements.html#magnify","title":"magnify","text":"<p>Displays the current value of the range on the left or right side of the slider.</p> <ul> <li><code>AC_Infront</code> : Displays the current value on the left side.</li> <li><code>AC_Behind</code> : Displays the current value on the right side.</li> <li><code>AC_Void</code> : No display the current value. This is the default.</li> </ul>"},{"location":"acelements.html#post_6","title":"post","text":"<p>Specifies a tag to add behind the HTML code generated from the element. The default values is <code>AC_Tag_BR</code>.</p>"},{"location":"acelements.html#style","title":"style","text":"<p>A <code>style</code> specifies the qualification style to give to the content and can use the style attribute format as it is.</p>"},{"location":"acelements.html#autoconnectstyle","title":"AutoConnectStyle","text":"<p>AutoConnectStyle inserts the string given by the value into the style block of a custom Web page as it is raw.</p> <p>The validity as CSS will not be checked</p> <p>AutoConnectStyle does not do syntax checking and semantic analysis of value. Insert the specified string into the style block of the custom Web page without processing it. Therefore, specifying the wrong CSS will modulate the behavior of the custom Web page.</p>"},{"location":"acelements.html#constructor_7","title":"Constructor","text":"<pre><code>AutoConnectStyle(const char* name, const char* value)\n</code></pre>"},{"location":"acelements.html#name_7","title":"name","text":"<p>It is the <code>name</code> of the AutoConnectStyle element and is useful only to access this element from the Sketch. It does not affect the generated HTML code.</p>"},{"location":"acelements.html#value_6","title":"value","text":"<p>The raw CSS code. It is not necessary to write <code>&lt;style&gt;</code> <code>&lt;/style&gt;</code> tags.</p>"},{"location":"acelements.html#autoconnectselect","title":"AutoConnectSelect","text":"<p>AutoConnectSelect generates an HTML <code>&lt;select&gt;</code> tag (drop-down list) and few <code>&lt;option&gt;</code> tags.</p> <p> Sample <code>AutoConnectSelect select(\"select\", { String(\"Europe/London\"), String(\"Europe/Berlin\"), String(\"Europe/Helsinki\"), String(\"Europe/Moscow\"), String(\"Asia/Dubai\") }, \"Select TZ name\");</code></p> <p>On the page:</p>"},{"location":"acelements.html#constructor_8","title":"Constructor","text":"<pre><code>AutoConnectSelect(const char* name, std::vector&lt;String&gt; const&amp; options, const char* label, const uint8_t selected, const ACPosterior_t post)\n</code></pre>"},{"location":"acelements.html#name_8","title":"name","text":"<p>It is the <code>name</code> of the AutoConnectSelect element and matches the name attribute of the select tags.</p>"},{"location":"acelements.html#options","title":"options","text":"<p>An <code>options</code> is an array of String type for the options which as actually std::vector for an HTML <code>&lt;option&gt;</code> tag. It is an initialization list can be used. The option tags will be generated from each entry in the options, the amount of which is the same as the number of items in an <code>options</code>.</p>"},{"location":"acelements.html#label_5","title":"label","text":"<p>A <code>label</code> is an optional string. A label is always arranged on the left side of the drop-down list. Specification of a label will generate an HTML <code>&lt;label&gt;</code> tag with an id attribute. The select tag and the label are connected by the id attribute.</p>"},{"location":"acelements.html#selected","title":"selected","text":"<p>A <code>selected</code> is an optional value. Specifies that an option should be pre-selected when the page loads.</p>"},{"location":"acelements.html#post_7","title":"post","text":"<p>Specifies a tag to add behind the HTML code generated from the element. The default values is <code>AC_Tag_BR</code>.</p>"},{"location":"acelements.html#autoconnectsubmit","title":"AutoConnectSubmit","text":"<p>AutoConnectSubmit generates an HTML <code>&lt;input type=\"button\"&gt;</code> tag attached <code>onclick</code> attribute. The native code of the <code>onclick</code> attribute is the submission of the form with the POST method.</p> <p> Sample <code>AutoConnectSubmit submit(\"submit\", \"Save\", \"/mqtt_save\");</code></p> <p>On the page:</p>"},{"location":"acelements.html#constructor_9","title":"Constructor","text":"<pre><code>AutoConnectSubmit(const char* name, const char* value, const char* uri, const ACPosterior_t post)\n</code></pre>"},{"location":"acelements.html#name_9","title":"name","text":"<p>It is the <code>name</code> of the AutoConnectSubmit element and matches the name attribute of the input tag.</p>"},{"location":"acelements.html#value_7","title":"value","text":"<p>It becomes a string of the <code>value</code> attribute of an HTML <code>&lt;input type=\"button\"&gt;</code> tag. The <code>value</code> will be displayed as a label of the button.</p>"},{"location":"acelements.html#uri","title":"uri","text":"<p>A <code>uri</code> specifies the URI to send form data when the button declared by AutoConnectSubmit is clicked.</p> <p>The query string of the form data sent with AutoConnectSubmit contains the URI of the page. Its parameter name is <code>_acuri</code>. In Sketch, you can know the called URI by referring to the <code>_acuri</code> parameter with the destination page handler. The actual query string is as follows:</p> <p>_acuri=CALLER_URI</p>"},{"location":"acelements.html#post_8","title":"post","text":"<p>Specifies a tag to add behind the HTML code generated from the element. The default values is <code>AC_Tag_None</code>.</p>"},{"location":"acelements.html#autoconnecttext","title":"AutoConnectText","text":"<p>AutoConnectText generates a text content enclosed in <code>&lt;div&gt;</code>, <code>&lt;p&gt;</code> or <code>&lt;span&gt;</code> tags; if the style parameter is provided, the style attributes is added. A kind of HTML tag applied depends on the value of the post parameter as follows:</p> <ul> <li>AC_Tag_None: <code>&lt;span id='name' style='style'&gt;value&lt;/span&gt;</code></li> <li>AC_Tag_BR: <code>&lt;span id='name' style='style'&gt;value&lt;/span&gt;&lt;br&gt;</code></li> <li>AC_Tag_P: <code>&lt;p id='name' style='style'&gt;value&lt;/p&gt;</code></li> <li>AC_Tag_DIV: <code>&lt;div id='name' style='style'&gt;value&lt;/div&gt;</code></li> </ul> <p> Sample <code>AutoConnectText text(\"text\", \"Publishing the WiFi signal strength to MQTT channel. RSSI value of ESP8266 to the channel created on ThingSpeak\", \"font-family:serif;color:#4682b4;\");</code></p> <p>On the page:</p>"},{"location":"acelements.html#constructor_10","title":"Constructor","text":"<pre><code>AutoConnectText(const char* name, const char* value, const char* style, const char* format, const ACPosterior_t post)\n</code></pre>"},{"location":"acelements.html#name_10","title":"name","text":"<p>A <code>name</code> does not exist in the generated HTML. It provides only a means of accessing elements with the Sketches.</p>"},{"location":"acelements.html#value_8","title":"value","text":"<p>It becomes content and also can contain the native HTML code, but remember that your written code is enclosed by the div tag.</p>"},{"location":"acelements.html#style_1","title":"style","text":"<p>A <code>style</code> specifies the qualification style to give to the content and can use the style attribute format as it is.</p>"},{"location":"acelements.html#format","title":"format","text":"<p>A <code>format</code> is a pointer to a null-terminated multi byte string specifying how to interpret the value. It specifies the conversion format when outputting values. The format string conforms to C-style printf library functions, but depends on the Espressif's SDK implementation. The conversion specification is valid only in %s format. (Left and Right justification, width are also valid.)</p>"},{"location":"acelements.html#post_9","title":"post","text":"<p>Specifies an HTML element that completes the text content. AutoConnectText's post parameter does not specify any behind-supplements, unlike when applied to other elements. A kind of HTML tag applied depends on the enumerated value of the post parameter as follows:</p> <ul> <li>AC_Tag_None: <code>&lt;span id='name' style='style'&gt;value&lt;/span&gt;</code></li> <li>AC_Tag_BR: <code>&lt;span id='name' style='style'&gt;value&lt;/span&gt;&lt;br&gt;</code></li> <li>AC_Tag_P: <code>&lt;p id='name' style='style'&gt;value&lt;/p&gt;</code></li> <li>AC_Tag_DIV: <code>&lt;div id='name' style='style'&gt;value&lt;/div&gt;</code></li> </ul>"},{"location":"acelements.html#how-to-coding-for-the-elements","title":"How to coding for the elements","text":""},{"location":"acelements.html#declaration-for-the-elements-in-sketches","title":"Declaration for the elements in Sketches","text":"<p>Variables of each AutoConnetElement can be declared with macros. By using the macros, you can treat element name that is String type as variable in sketches.2</p> <p>ACElement ( name [ , value ] [ , AC_Tag_None | AC_Tag_BR | AC_Tag_P | AC_Tag_DIV ] )</p> <p>ACButton ( name [ , value ] [ , action ] [ , AC_Tag_None | AC_Tag_BR | AC_Tag_P | AC_Tag_DIV ] )</p> <p>ACCheckbox ( name [ , value ] [ , label ] [ , true | false ] [ , AC_Infront | AC_Behind ] [ , AC_Tag_None | AC_Tag_BR | AC_Tag_P | AC_Tag_DIV ] )</p> <p>ACFile ( name [ , value ] [ , label ] [ , AC_File_FS | AC_File_SD | AC_File_Extern ] [ , AC_Tag_None | AC_Tag_BR | AC_Tag_P | AC_Tag_DIV ] )</p> <p>ACInput ( name [ , value ] [ , label ] [ , pattern ] [ , placeholder ] [ , AC_Tag_None | AC_Tag_BR | AC_Tag_P | AC_Tag_DIV ] [ , AC_Input_Text | AC_Input_Password | AC_Input_Number ])</p> <p>ACRadio ( name [ , values ] [ , label ] [ , AC_Horizontal | AC_Vertical ] [ , checked ] [ , AC_Tag_None | AC_Tag_BR | AC_Tag_P | AC_Tag_DIV ] ) <p>ACRange ( name [ , value ] [ , label ] [ , min ] [ , max ] [ , step ] [ , AC_Infront | AC_Behind | AC_Void ] [ , AC_Tag_None | AC_Tag_BR | AC_Tag_P | AC_Tag_DIV ] [ , style ] )</p> <p>ACSelect ( name [ , options ] [ , label ] [ , AC_Tag_None | AC_Tag_BR | AC_Tag_P | AC_Tag_DIV ] )</p> <p>ACStyle ( name [ , value ] )</p> <p>ACSubmit ( name [ , value ] [ , uri ] [ , AC_Tag_None | AC_Tag_BR | AC_Tag_P | AC_Tag_DIV ] )</p> <p>ACText ( name [ , value ] [ , style ] [ , format ] [ , AC_Tag_None | AC_Tag_BR | AC_Tag_P | AC_Tag_DIV ] )</p> <p>Declaration macro usage</p> <p>For example, AutoConnectText can be declared using macros. <pre><code>AutoConnectText caption(\"caption\", \"hello, world\", \"color:blue;\")\n</code></pre> equals by using ACText macro. <pre><code>ACText(caption, \"hello, world\", \"color:blue;\")\n</code></pre></p>"},{"location":"acelements.html#variant-for-autoconnectelements","title":"Variant for AutoConnectElements","text":"<p>Some AutoConnectAux APIs specify AutoConnectElements as an argument. There are also functions that return a pointer to AutoConnectElements. AutoConnectElement behaves as a variant type of each element class to make these interfaces a single. Use reinterpret_cast to cast from a variant pointer to an Actual type pointer of AutoConnectElements.</p> <pre><code>AutoConnectAux aux;\nACText(Text1, \"hello, world\");\naux.add(Text1);\nAutoConnectText* text_p = reinterpret_cast&lt;AutoConnectText*&gt;(aux.getElement(\"Text1\"));\nAutoConnectText&amp; text = aux.getElement&lt;AutoConnectText&gt;(\"Text1\");\n</code></pre> <ol> <li> <p>JavaScript can be inserted into a custom Web page using AutoConnectElement.\u00a0\u21a9</p> </li> <li> <p>The square brackets in the syntax are optional parameters, the stroke is a selection parameter, the bold fonts are literal.\u00a0\u21a9</p> </li> </ol>"},{"location":"achandling.html","title":"Handling the custom Web pages","text":""},{"location":"achandling.html#page-container-component","title":"Page, Container, Component","text":"<p>AutoConnectAux is the container for a custom Web page, AutoConnectElement is the component of a page. AutoConnectElements must be contained in AutoConnectAux object. (ie. they are the elements displayed on the custom Web page.) Then AutoConnect makes an AutoConnectAux to a page.</p> <p>AutoConnectElements declared in sketch must be programmed to add to AutoConnectAux one after another. Elements are automatically included in AutoConnectAux by AutoConnect if you load it from the JSON document. In either method, it is common to use the function of AutoConnectAux to access an element with a sketch.</p>"},{"location":"achandling.html#custom-web-page-handler-programming-model","title":"Custom Web page handler programming model","text":"<p>To handle Custom Web pages properly, the sketches need to implement to match the programming model. Custom Web page programming model is depicted as follows:</p> <p></p> <p>Custom Web page handler acts as an event handler for processing the HTTP request captured by the WebServer class. The WebServer class parses the HTTP request and calls the registered uri handler appropriately. The custom web page uri (it should be specified by the JSON description for the custom web page, the AutoConnectAux constructor, or the AutoConnect::on function) is not registered directly with the WebServer class, and the Requests always go through the request dispatcher inside AutoConnect.</p> <p>When implementing the custom Web page handler, it is possible to give an appropriate function to the handler by understanding the above internal structure in advance. Custom web page handler can be sketched as regular function and has interface is as follows:</p> <pre><code>String customWebpageHandler(AutoConnectAux&amp; aux, PageArgument&amp; args)\n</code></pre>"},{"location":"achandling.html#parameters-for-the-customwebagehandler","title":"Parameters for the customWebageHandler","text":"<p>When the custom web page handler is called, AutoConnect passes the following two parameters:</p>"},{"location":"achandling.html#1-reference-to-the-autoconnectaux-instance","title":"1. Reference to the AutoConnectAux instance","text":"<p>Custom Web page handlers can access the AutoConnectElements owned by its page through a reference to the AutoConnectAux instance. It can use this access to update the AutoConnectElements value before the user views the page or get the value of AutoConnectElements owned by the page that triggered the transition.</p> <p>A list of commonly used functions to access AutoConnectElements with your Sketch via reference to an AutoConnectAux instance is following:</p> <ul> <li><code>[]</code> operator : Access to an AutoConnectElement by specified element name.</li> <li><code>getElement</code> function : Access to an AutoConnectElement by specified element name.</li> <li><code>as&lt;&gt;</code> function : Cast from a variant of <code>AutoConnectElement</code> type to an actual type such as <code>AutoConnectText</code> or <code>AutoConnectInput</code> etc. To access attributes that exist only in the actual type, it is necessary to convert from the <code>AutoConnectElement</code> type obtained with <code>[]</code> operator or <code>getElement</code> function.</li> </ul> <p>See the section Get AutoConnectElement from the AutoConnectAux and the section AutoConnectElements API for usage examples and API specifications for each above function.</p>"},{"location":"achandling.html#2-reference-to-the-pageargument-instance","title":"2. Reference to the PageArgument instance","text":"<p>The values of the AutoConnectCheckbox, AutoConnectFile, AutoConnectInput, AutoConnectRadio, and AutoConnectSelect elements are packed into the form data of the HTTP POST method by the page transition caused by AutoConnectSubmit. Use the PageArgument instance to retrieve the values of these transmitted AutoConnectElements with the customWebpageHandler. A list of commonly used functions to access PageArgment member variables with your Sketch via a reference to an PageArgument instance is following:</p> <ul> <li><code>arg</code> function : Get an element value by specified element name.</li> <li><code>hasArg</code> function : Checks for the existence of an element with the specified name.</li> </ul> <p>The method to get the form data attached to the HTTP request via PageArgument is described with the section How you can reach the values.</p>"},{"location":"achandling.html#3-access-to-the-autoconnectelement-values","title":"3. Access to the AutoConnectElement values","text":"<p>Here, you have one thing to note. The custom web page handler registered with AutoConnect::on function is called to respond to an HTTP request to the URL of its page. And, the AutoConnectAux instance then references the custom web page assigned to the requested URL. That is, the AutoConnectAux instance passed to the custom web page handler owns the AutoConnectElements for that page, while the PageArgument instance has the AutoConnectElements value of the custom web page that caused the page transition. You need to keep the difference between the two in mind when implementing the custom web page handler with your Sketch and access these values via the appropriate approach.</p> <p>You can access the AutoConnect Elements of the custom web page itself via the <code>AutoConnectAux&amp;</code> argument by specifying the element name. You can also use the <code>PageArgument&amp;</code> argument to get the value of AutoConnectElements for the page that caused the transition to that custom web page. (the URL that issued the HTTP request)</p> <p>The following screenshots are outputs of custom web pages that are based on a scenario to help you understand how to access AutoConnectElements properly with a custom web page handler. The requirements for this scenario are:</p> <ul> <li>Calculate an addition simply, add <code>B</code> to <code>A</code>.</li> <li>Perform the calculation with a customWebPageHandler.</li> <li>Returns the calculated result in another custom web page with page transitions.</li> </ul> <p>The first thing to work on is defining two custom web pages. Here, Value A and Value B are easily defined by applying AutoConnectInput. Also, add an action button to perform the calculation with AutoConnectSubmit.</p> <pre><code>{\n\"uri\": \"/add\",\n\"title\": \"Adder\",\n\"menu\": true,\n\"element\": [\n    {\n\"name\": \"valueA\",\n\"type\": \"ACInput\",\n\"label\": \"Value A\",\n\"apply\": \"number\"\n    },\n    {\n\"name\": \"valueB\",\n\"type\": \"ACInput\",\n\"label\": \"Value B\",\n\"apply\": \"number\"\n    },\n    {\n\"name\": \"add\",\n\"type\": \"ACSubmit\",\n\"value\": \"ADD\",\n\"uri\": \"/results\"\n    }\n  ]\n}\n</code></pre> <p>Next, define an additional page to display the results. Here we use AutoConnectText to display the calculation as a representation string of the expression. There is one thing to watch out for here. That is, the transition destination of the action button as <code>ADD</code> that accept the operand (it is specified by the <code>uri</code> of the ACSubmit element named \"add\") and the <code>uri</code> of the page that displays the answer are the same.</p> <pre><code>{\n\"uri\": \"/results\",\n\"title\": \"Adder\",\n\"menu\": false,\n\"element\": [\n    {\n\"name\": \"results\",\n\"type\": \"ACText\"\n    }\n  ]\n}\n</code></pre> <p>When implementing a custom web page handler, it's usually a good idea to pre-determine the page design (which consists of the elements and layouts you want to use) for a better outlook when coding your Sketch. Especially when coding a custom web page handler, you need to specify the AutoConnectElements exactly, and it is recommended to implement it along the JSON defined earlier.</p> <p>After this, sketch the handlers for the above two custom web pages.</p> <p>First, the handler for the page allocated to <code>/add</code>. The role of this handler is to initialize the values respectively for the <code>valueA</code> and <code>valueB</code> input boxes. Both of these two input boxes are on the <code>/add</code> page, so the handler only references the <code>AutoConnectAux&amp; aux</code> argument.</p> <p>You can use the <code>[]</code> operator with the element name like as <code>aux[\"valueA\"]</code> to get a reference to an AutoConnectElement by name. Then, once the reference is converted to AutoConnectInput, the <code>value</code> member of AutoConnectInput can be accessed. Use the <code>as&lt;AutoConnectInput&gt;()</code> function to convert from the AutoConnectElement type to the actual AutoConnectInput type.</p> <pre><code>String onAdd(AutoConnectAux&amp; aux, PageArgument&amp; args) {\n  aux[\"valueA\"].as&lt;AutoConnectInput&gt;().value = \"0\";\n  aux[\"valueB\"].as&lt;AutoConnectInput&gt;().value = \"0\";\nreturn String();\n}\n</code></pre> <p>Next, the handler for the page allocated to <code>/results</code>. The role of this handler is to add the value B to A for the calculation. The <code>/results</code> page does not have an element that contains the operands Value A and Value B to calculate. Only the <code>/add</code> page has them. The <code>/results</code> page handler is called when ACSubmit on the <code>/add</code> page works, so <code>valueA</code> and <code>valueB</code> are included in the form data of the HTTP POST request to the <code>/results</code> page. That is, the handler for the <code>/results</code> page will get <code>valueA</code> and <code>valueB</code> from the <code>PageArgument&amp; args</code> argument.</p> <pre><code>String onResults(AutoConnectAux&amp; aux, PageArgument&amp; args) {\nint valueA = args.arg(\"valueA\").toInt();\nint valueB = args.arg(\"valueB\").toInt();\n\n  aux[\"results\"].as&lt;AutoConnectText&gt;().value = String(valueA) + \" + \" + String(valueB) + \" = \" + String(valueA + valueB);\nreturn String();\n}\n</code></pre> <p>PageArgument is a built-in class in the PageBuilder library. You can use the PageArgument::arg function to retrieve the parameters of the form data contained in the POST request by name. Since the <code>PageArgument::arg</code> function returns the parameters of the POSTed form data as a string, it converts Value A and Value B to the operand integer value of the addition via the <code>String::toInt()</code> function.</p> <pre><code>int valueA = args.arg(\"valueA\").toInt();\nint valueB = args.arg(\"valueB\").toInt();\n</code></pre> <p>In this scenario, in addition to the calculation result, the calculation formula is also displayed on the result page.</p> <pre><code>aux[\"results\"].as&lt;AutoConnectText&gt;().value = String(valueA) + \" + \" + String(valueB) + \" = \" + String(valueA + valueB);\n</code></pre>"},{"location":"achandling.html#the-customwebpagehandler-return-value","title":"The customWebpageHandler return value","text":"<p>The customWebpageHandler returns a string. The returned string is used internally by AutoConnect to temporarily qualify the HTML generating of the custom web page. AutoConnect typically calls a custom web page handler before HTML generation.</p> <p>When the customWebpageHandler returns an HTML string for qualification, it applies to the drawing area for the elements of AutoConnectElements. Additionally, you can then specify where the modifier HTML will be inserted. The second parameter of the AutoConnectAux::on function, which allows the registration of custom web page handlers, indicates where to insert the modifier HTML. </p> <p>The Sketch can specify the following three values for the second parameter of AutoConnectAux::on function:</p> <ul> <li> <p>AC_EXIT_AHEAD : Modifiers HTML returned by the custom Web page handler is inserted into the front of the list expansion of AutoConnectElements.</p> </li> <li> <p>AC_EXIT_LATER : Modifiers HTML returned by the custom Web page handler is inserted into the back of the list expansion of AutoConnectElements.</p> </li> <li> <p>AC_EXIT_BOTH : The customWebpageHandle will be called twice before and after list expansion of AutoConnectElements.</p> </li> </ul> <p>A detailed description of the AutoConnectAux::on function can be found in Section AutoConnectAux API.</p> <p>The actual sketch code implemented following these steps above would look like this (case of ESP8266):</p> <pre><code>#include &lt;Arduino.h&gt;\n#include &lt;ESP8266WiFi.h&gt;\n#include &lt;ESP8266WebServer.h&gt;\n#include &lt;AutoConnect.h&gt;\n\nconst char PAGE_ADD[] PROGMEM = R\"(\n{\n  \"uri\": \"/add\",\n  \"title\": \"Adder\",\n  \"menu\": true,\n  \"element\": [\n    {\n      \"name\": \"valueA\",\n      \"type\": \"ACInput\",\n      \"label\": \"Value A\",\n      \"apply\": \"number\"\n    },\n    {\n      \"name\": \"valueB\",\n      \"type\": \"ACInput\",\n      \"label\": \"Value B\",\n      \"apply\": \"number\"\n    },\n    {\n      \"name\": \"add\",\n      \"type\": \"ACSubmit\",\n      \"value\": \"ADD\",\n      \"uri\": \"/results\"\n    }\n  ]\n}\n)\";\n\nconst char PAGE_RESULTS[] PROGMEM = R\"(\n{\n  \"uri\": \"/results\",\n  \"title\": \"Adder\",\n  \"menu\": false,\n  \"element\": [\n    {\n      \"name\": \"results\",\n      \"type\": \"ACText\"\n    }\n  ]\n}\n)\";\n\nAutoConnect portal;\nAutoConnectAux  page_add;\nAutoConnectAux  page_results;\n\nString onAdd(AutoConnectAux&amp; aux, PageArgument&amp; args) {\n  aux[\"valueA\"].as&lt;AutoConnectInput&gt;().value = \"0\";\n  aux[\"valueB\"].as&lt;AutoConnectInput&gt;().value = \"0\";\nreturn String();\n}\n\nString onResults(AutoConnectAux&amp; aux, PageArgument&amp; args) {\nint valueA = args.arg(\"valueA\").toInt();\nint valueB = args.arg(\"valueB\").toInt();\n\n  aux[\"results\"].as&lt;AutoConnectText&gt;().value = String(valueA) + \" + \" + String(valueB) + \" = \" + String(valueA + valueB);\nreturn String();\n}\n\nvoid setup() {\n  delay(1000);\n  page_add.load(PAGE_ADD);\n  page_results.load(PAGE_RESULTS);\n  portal.join({ page_add, page_results });\n  portal.on(\"/add\", onAdd);\n  portal.on(\"/results\", onResults);\n  portal.begin();\n}\n\nvoid loop() {\n  portal.handleClient();\n}\n</code></pre>"},{"location":"achandling.html#handing-autoconnectelements-with-the-sketches","title":"Handing AutoConnectElements with the Sketches","text":"<p>The AutoConnectAux class has several functions to manipulate AutoConnectElements. The functions can add, delete, retrieve elements, and get and set values.</p>"},{"location":"achandling.html#add-autoconnectelements-to-the-autoconnectaux-object","title":"Add AutoConnectElements to the AutoConnectAux object","text":"<p>To add AutoConnectElment(s) to an AutoConnectAux object, use the add function.</p> <pre><code>void AutoConnectAux::add(AutoConnectElement&amp; addon)\n</code></pre> <pre><code>void AutoConnectAux::add(AutoConnectElementVT addons)\n</code></pre> <p>The add function adds the specified AutoConnectElement to AutoConnectAux. The AutoConnectElementVT type is the std::vector of the reference wrapper to AutoConnectElements, and you can add these elements in bulk by using the list initialization with the Sketch.</p> <pre><code>typedef std::vector&lt;std::reference_wrapper&lt;AutoConnectElement&gt;&gt; AutoConnectElementVT;\n</code></pre> <p>AutoConnectElements contained in AutoConnectAux object are uniquely identified by name. When adding an AutoConnectElement, if an element with the same name already exists in the AutoConnectAux, checking the type, and if it is the same, the value will be replaced. If another type of AutoConnectElement exists with the same name, that add operation will be invalid.1 In the following example, AutoConnectButton <code>button</code> addition will invalid because <code>hello</code> with the same name already exists as AutoConnectText.</p> <pre><code>AutoConnectAux  aux;\nAutoConnectText text(\"hello\", \"hello, world\");\nAutoConnectButton button(\"hello\", \"hello, world\", \"alert('Hello world!')\");  // This is invalid.\naux.add({ text, button });\n</code></pre> <p>Similarly this, the uniqueness of the name is also necessary within the JSON document</p> <pre><code>{\n\"name\" : \"aux\",\n\"uri\" : \"/aux\",\n\"menu\" : true,\n\"element\" : [\n    {\n\"name\": \"hello\",\n\"type\": \"ACText\",\n\"value\": \"hello, world\"\n    },\n    {\n\"name\": \"hello\",\n\"type\": \"ACButton\",\n\"value\": \"hello, world\",\n\"action\": \"alert('Hello world!')\"\n    }\n  ]\n}\n</code></pre> <p>Load all elements from JSON document</p> <p>If you load all AutoConnectElements from JSON document into AutoConnect, you do not need to sketch the population process of the AutoConnectElements. It is managed by the AutoConnect library automatically.</p>"},{"location":"achandling.html#get-autoconnectelement-from-the-autoconnectaux","title":"Get AutoConnectElement from the AutoConnectAux","text":"<p>To retrieve an element from AutoConnectAux, use the getElement or getElements function. Normally, the getElement is needed when accessing the value of AutoConnectElement in the Sketch.</p> <pre><code>AutoConnectElement* AutoConnectAux::getElement(const char* name)\n</code></pre> <pre><code>AutoConnectElement* AutoConnectAux::getElement(const __FlashStringHelper* name)\n</code></pre> <pre><code>AutoConnectElement* AutoConnectAux::getElement(const String&amp; name)\n</code></pre> <pre><code>T&amp; AutoConnectAux::getElement&lt;T&gt;(const String&amp; name)\n</code></pre> <pre><code>AutoConnectElementVT* AutoConnectAux::getElements(void)\n</code></pre> <p>The getElement function returns an AutoConnectElement with the specified name as a key. When you use this function, you need to know the type of AutoConnectElement in advance and specify its type &lt;T&gt; to an argument of the getElement. A type of &lt;T&gt; can be specified as follows.</p> <pre><code>AutoConnectButton&amp; AutoConnectAux::getElement&lt;AutoConnectButton&gt;(const String&amp; name)\nAutoConnectCheckbox&amp; AutoConnectAux::getElement&lt;AutoConnectCheckbox&gt;(const String&amp; name)\nAutoConnectElement&amp; AutoConnectAux::getElement&lt;AutoConnectElement&gt;(const String&amp; name)\nAutoConnectFile&amp; AutoConnectAux::getElement&lt;AutoConnectFile&gt;(const String&amp; name)\nAutoConnectInput&amp; AutoConnectAux::getElement&lt;AutoConnectInput&gt;(const String&amp; name)\nAutoConnectRadio&amp; AutoConnectAux::getElement&lt;AutoConnectRadio&gt;(const String&amp; name)\nAutoConnectSelect&amp; AutoConnectAux::getElement&lt;AutoConnectSelect&gt;(const String&amp; name)\nAutoConnectSubmit&amp; AutoConnectAux::getElement&lt;AutoConnectSubmit&gt;(const String&amp; name)\nAutoConnectText&amp; AutoConnectAux::getElement&lt;AutoConnectText&gt;(const String&amp; name)\n</code></pre> <p>To retrieve an AutoConnectElement by specifying its type, use the following method.</p> <pre><code>AutoConnectAux  aux;\naux.load(\"SOME_JSON_DOCUMENT\");\n\n// Retrieve the pointer of the AutoConnectText\nAutoConnectText* text = reinterpret_cast&lt;AutoConnectText*&gt;(aux.getElement(\"TEXT_ELEMENT_NAME\"));\n\n// Retrieve the reference of the AutoConnectText\nAutoConnectText&amp; text = aux.getElement&lt;AutoConnectText&gt;(\"TEXT_ELEMENT_NAME\");\n</code></pre> <p>The AutoConnectElement type behaves as a variant of other element types. Therefore use cast or template to convert to actual type as above. In the Sketch, you access the real type of AutoConnectElement after casting it and storing into the variable.</p> <pre><code>const String auxJson = String(\"{\\\"title\\\":\\\"Page 1 title\\\",\\\"uri\\\":\\\"/page1\\\",\\\"menu\\\":true,\\\"element\\\":[{\\\"name\\\":\\\"caption\\\",\\\"type\\\":\\\"ACText\\\",\\\"value\\\":\\\"hello, world\\\"}]}\");\nAutoConnect portal;\nportal.load(auxJson);\nAutoConnectAux* aux = portal.aux(\"/page1\");  // Identify the AutoConnectAux instance with uri\nAutoConnectText&amp; text = aux-&gt;getElement&lt;AutoConnectText&gt;(\"caption\");  // Cast to real type and access members\nSerial.println(text.value);\n</code></pre> <p>You can also use the operator <code>[]</code> of AutoConnectAux as another way to get the desired element. An operator <code>[]</code> is a shortcut for getElement function with the reference casting and makes simplify the Sketch code and treats like an array with the elements placed on a custom Web page. Its argument is the name of the element to be acquired similarly to getElement function. In the Sketch, by combining the AutoConnectElement::as&lt;T&gt; function with the operator <code>[]</code>, you can access the  AutoConnectElements reference according to its actual type. For example, the following sketch code returns the same as a reference of AutoConnectText element as the <code>caption</code>.</p> <pre><code>AutoConnect portal;\nportal.load(auxJson);\nAutoConnectAux&amp;  aux = *portal.aux(\"/page1\");\nAutoConnectText&amp; text1 = aux.getElement&lt;AutoConnectElement&gt;(\"caption\");\nAutoConnectText&amp; text2 = aux[\"caption\"].as&lt;AutoConnectText&gt;();\n</code></pre> <p>Need cast to convert to the actual type</p> <p>An operator <code>[]</code> returns a reference of an AutoConnectElement. It is necessary to convert the type according to the actual element type with AutoConnectElement::as&lt;T&gt; function. <pre><code>AutoConnectButton&amp; AutoConnectElement::as&lt;AutoConnectButton&gt;()\nAutoConnectCheckbox&amp; AutoConnectElement::as&lt;AutoConnectCheckbox&gt;()\nAutoConnectElement&amp; AutoConnectElement::as&lt;AutoConnectElement&gt;()\nAutoConnectFile&amp; AutoConnectElement::as&lt;AutoConnectFile&gt;()\nAutoConnectInput&amp; AutoConnectElement::as&lt;AutoConnectInput&gt;()\nAutoConnectRadio&amp; AutoConnectElement::as&lt;AutoConnectRadio&gt;()\nAutoConnectSelect&amp; AutoConnectElement::as&lt;AutoConnectSelect&gt;()\nAutoConnectSubmit&amp; AutoConnectElement::as&lt;AutoConnectSubmit&gt;()\nAutoConnectText&amp; AutoConnectElement::as&lt;AutoConnectText&gt;()\n</code></pre></p> <p>To get all the AutoConnectElements in an AutoConnectAux object use the getElements function. This function returns the vector of the reference wrapper as AutoConnectElementVT to all AutoConnectElements registered in the AutoConnectAux.</p> <pre><code>AutoConnectElementVT&amp; AutoConnectAux::getElements(void)\n</code></pre>"},{"location":"achandling.html#enable-autoconnectelements-during-the-sketch-execution","title":"Enable AutoConnectElements during the Sketch execution","text":"<p>AutoConnectElemets have an enable attribute to activate its own HTML generation. Sketches can change the HTMLization of their elements dynamically by setting or resetting the enable value. An element whose the enable attribute is true will generate itself HTML and place on the custom Web page.  And conversely, it will not generate the HTML when the value is false.</p> <p>For example, to enable the submit button only when the ESP module is connected to the access point in STA mode, you can sketch the following:</p> <pre><code>#include &lt;ESP8266WiFi.h&gt;\n#include &lt;ESP8266WebServer.h&gt;\n#include &lt;AutoConnect.h&gt;\n\nstatic const char AUX[] PROGMEM = R(\"\n{\n\"name\" : \"aux\",\n\"uri\" : \"/aux\",\n\"menu\" : true,\n\"element\" : [\n    {\n\"name\": \"input\",\n\"type\": \"ACInput\",\n\"label\": \"Input\"\n    },\n    {\n\"name\": \"send\",\n\"type\": \"ACSubmit\",\n\"uri\": \"/send\"\n    }\n  ]\n}\n\");\n\nAutoConnect    portal;\nAutoConnectAux page;\n\nString onPage(AutoConnectAux&amp; aux, PageArgument&amp; args) {\n  AutoConnectSubmit&amp; send = aux[\"send\"].as&lt;AutoConnectSubmit&gt;();\nif (WiFi.isConnected())\n    send.enable = (WiFi.getMode() == WIFI_STA);\nelse\n    send.enable = false;\nreturn String();\n}\n\nvoid setup() {\n  page.load(AUX);\n  page.on(onPage);\n  portal.join(page);\n  portal.begin();\n}\n\nvoid loop() {\n  portal.handleClient();\n}\n</code></pre> <p>Desirable to set or reset the enable attribute in the page handler</p> <p>The enable attribute can be set at any time during the Sketch execution. The page handler with the AC_EXIT_AHEAD option is sure to handle it.</p>"},{"location":"achandling.html#loading-saving-autoconnectelements-with-json","title":"Loading &amp; saving AutoConnectElements with JSON","text":"<p>AutoConnect supports reading the custom Web page definitions written in JSON and also supports loading and saving of AutoConnectAux or AutoConnectElements. In both cases, the target object is a JSON document for AutoConnect. However, it can not save all AutoConnectElements contained in the page as a custom Web page. (ie. AutoConnectAux)</p> <p></p>"},{"location":"achandling.html#loading-autoconnectaux-autoconnectelements-with-json","title":"Loading AutoConnectAux &amp; AutoConnectElements with JSON","text":"<p>To load a JSON document as AutoConnectAux use the AutoConnect::load function and load the JSON document of each AutoConnectElement using the AutoConnectAux::loadElement function. Although the functions of both are similar, the structure of the target JSON document is different.</p> <p>The AutoConnect::load function loads the entire AutoConnectAux and creates both the AutoConnectAux instance and each AutoConnectElement instance. A single JSON document can contain multiple custom Web pages. If you write JSON of AutoConnectAux as an array, the load function generates all the pages contained in that array. Therefore, it is necessary to supply the JSON document of AutoConnectAux as an input of the load function and must contain the elements described section JSON document structure for AutoConnectAux.</p> <p>The AutoConnectAux::loadElement function loads the elements individually into an AutoConnectAux object. The structure of its supplying JSON document is not AutoConnectAux. It must be a JSON structure for AutoConnectElement, but you can specify an array.</p> <pre><code>// AutoConnectAux as a custom Web page.\nconst char page[] PROGMEM = R\"raw(\n{\n  \"title\": \"Settings\",\n  \"uri\": \"/settings\",\n  \"menu\": true,\n  \"element\": [\n    {\n      \"name\": \"server\",\n      \"type\": \"ACInput\",\n      \"label\": \"Server\"\n    },\n    {\n      \"name\": \"set\",\n      \"type\": \"ACSubmit\",\n      \"value\": \"SET\",\n      \"uri\" : \"/set\"\n    }\n  ]\n}\n)raw\";\n\n// Additional AutoConnectElements.\nconst char addons[] PROGMEM = R\"raw(\n[\n  {\n    \"name\": \"notes\",\n    \"type\": \"ACText\",\n    \"value\": \"An update period as the below optionally.\"\n  },\n  {\n    \"name\": \"period\",\n    \"type\": \"ACRadio\",\n    \"value\": [\n      \"30 sec.\",\n      \"60 sec.\",\n      \"180 sec.\"\n    ],\n    \"arrange\": \"vertical\",\n    \"checked\": 1\n  }\n]\n)raw\";\n\nAutoConnect     portal;\nAutoConnectAux* auxPage;\n\n// Load a custom Web page.\nportal.load(page);\n// Get a '/settings' page\nauxPage = portal.aux(\"/settings\");\n\n// Also, load only AutoConnectRadio named the period.\nauxPage-&gt;loadElement(addons, \"period\");\n// Retrieve a server name from an AutoConnectText value.\nAutoConnectText&amp; serverName = auxPage-&gt;getElement&lt;AutoConnectText&gt;(\"server\");\nSerial.println(serverName.value);\n</code></pre>"},{"location":"achandling.html#saving-autoconnectelements-with-json","title":"Saving AutoConnectElements with JSON","text":"<p>To save the AutoConnectAux or the AutoConnectElement as a JSON document, use the AutoConnectAux::saveElement function. It serializes the contents of the object based on the type of the AutoConnectElement. You can persist a serialized AutoConnectElements as a JSON document to a stream.</p> <pre><code>// Open a parameter file on the SPIFFS.\nSPIFFS.begin();\nFILE param = SPIFFS.open(\"/param\", \"w\");\n\n// Save elements as the parameters.\nauxPage-&gt;saveElement(param, { \"server\", \"period\" });\n\n// Close a parameter file.\nparam.close();\nSPIFFS.end();\n</code></pre> <p>The example above saves <code>server</code> and <code>period</code> elements from the AutoConnectAux object as mentioned above to the <code>/param</code> file on SPIFFS. Its JSON document of AutoConnectElements saved by its code looks like this:</p> <pre><code>[\n  {\n\"name\": \"server\",\n\"type\": \"ACInput\",\n\"value\": \"An inputted server name\",\n\"label\": \"Server\",\n\"placeholder\": \"\"\n  },\n  {\n\"name\": \"period\",\n\"type\": \"ACRadio\",\n\"value\": [\n\"30 sec.\",\n\"60 sec.\",\n\"180 sec.\"\n    ],\n\"arrange\": \"vertical\",\n\"checked\": 2\n  }\n]\n</code></pre> <p>Above JSON document can be loaded as it is into a custom Web page using the loadElement function. The loadElement function also loads the value of the element, so the saved value can be restored on the custom Web page.</p>"},{"location":"achandling.html#custom-field-data-handling","title":"Custom field data handling","text":"<p>A sketch can access variables of AutoConnectElements in the custom Web page. The value entered into the AutoConnectElements on the page is stored in the member variable of each element by AutoConnect whenever GET/POST transmission occurs. </p> <p>The following diagram shows the flow of the input values of a custom Web page into a sketch and is the basis for actions to manipulate the values of custom Web pages using sketches.</p> <p></p>"},{"location":"achandling.html#where-to-pick-up-the-values","title":"Where to pick up the values","text":"<p>A sketch composed of handlers can receive the value of AutoConnectElements entered in a custom Web page after sending, but that handler is different from the page where the value was entered. It is necessary to be aware that can accept the entered values by the next page handler after the transition.</p> <p>Usually, two ways to retrieve entered values we have. One is to use the ESP8266WebServer::arg (or WebServer::arg for ESP32) function in the <code>on handler</code> attached by ESP8266WebServer (WebServer w/ESP32 also).</p> <pre><code>#include &lt;ESP8266WiFi.h&gt;\n#include &lt;ESP8266WebServer.h&gt;\n#include &lt;AutoConnect.h&gt;\n\nstatic const char addonJson[] PROGMEM = R\"raw(\n{\n  \"title\": \"Hello\",\n  \"uri\": \"/hello\",\n  \"menu\": true,\n  \"element\": [\n    {\n      \"name\": \"feels\",\n      \"type\": \"ACInput\",\n      \"label\": \"What's up?\"\n    },\n    {\n      \"name\": \"send\",\n      \"type\": \"ACSubmit\",\n      \"value\": \"Just it!\",\n      \"uri\": \"/feels\"\n    }\n  ]\n}\n)raw\";\n\nESP8266WebServer webServer;\nAutoConnect portal(webServer);\n\n// Here, /feels handler\nvoid feelsOn() {\n\n// Retrieve the value of a input-box named \"feels\"\n  String feel = webServer.arg(\"feels\");\n// Echo back the value\n  String echo = \"&lt;html&gt;&lt;p style=\\\"color:blue;font-family:verdana;font-size:300%;\\\"&gt;\" + feel + String(\" and a bold world!&lt;/p&gt;&lt;/html&gt;\");\n  webServer.send(200, \"text/html\", echo);\n}\n\nvoid setup() {\n  delay(1000);\n  webServer.on(\"/feels\", feelsOn);  // Register /feels handler\n  portal.load(addonJson);           // Load a custom Web page\n  portal.begin();\n}\n\nvoid loop() {\n  portal.handleClient();\n}\n</code></pre> <p>An above example is the most simple sketch of handling values entered into a custom Web page. This sketch obtains the string entered in the AutoConnectInput named <code>feels</code> with the <code>/feels</code> handler after page transition, and the AutoConnectInput is an <code>&lt;input type=\"text\" name=\"feels\"&gt;</code> element wrapped in the form as the actual HTML code. </p> <p>Should be accessed <code>/_ac</code> first</p> <p>When you actually try the above sketch, there is no a root handler. So the URL that should be accessed first is <code>/_ac</code> concatenated with the local IP address of the esp8266 module.</p> <p>Another method is effective when custom Web pages have complicated page transitions. It is a way to straight access the AutoConnectElements member value. You can get the AutoConnectElement with the specified name using the getElement function. The following sketch executes the above example with AutoConnect only, without using the function of ESP8266WebServer.</p> <pre><code>#include &lt;ESP8266WiFi.h&gt;\n#include &lt;ESP8266WebServer.h&gt;\n#include &lt;AutoConnect.h&gt;\n\nconst static char addonJson[] PROGMEM = R\"raw(\n[\n  {\n    \"title\": \"Hello\",\n    \"uri\": \"/hello\",\n    \"menu\": true,\n    \"element\": [\n      {\n        \"name\": \"feels\",\n        \"type\": \"ACInput\",\n        \"label\": \"What's up?\"\n      },\n      {\n        \"name\": \"send\",\n        \"type\": \"ACSubmit\",\n        \"value\": \"Just it!\",\n        \"uri\": \"/feels\"\n      }\n    ]\n  },\n  {\n    \"title\": \"Hello\",\n    \"uri\": \"/feels\",\n    \"menu\": false,\n    \"element\": [\n      {\n        \"name\": \"echo\",\n        \"type\": \"ACText\",\n        \"style\": \"color:blue;font-family:verdana;font-size:300%;\"\n      }\n    ]\n  }\n]\n)raw\";\n\nAutoConnect portal;\n\n// Here, /feels handler\nString feelsOn(AutoConnectAux&amp; aux, PageArgument&amp; args) {\n\n// Get the AutoConnectInput named \"feels\".\n// The where() function returns an uri string of the AutoConnectAux that triggered this handler.\n  AutoConnectAux* hello = portal.aux(portal.where());\n  AutoConnectInput&amp; feels = hello-&gt;getElement&lt;AutoConnectInput&gt;(\"feels\");\n// Get the AutoConnectText named \"echo\".\n  AutoConnectText&amp;  echo = aux.getElement&lt;AutoConnectText&gt;(\"echo\");\n// Echo back from input-box to /feels page.\n  echo.value = feels.value +  String(\" and a bold world!\");\nreturn String(\"\");\n}\n\nvoid setup() {\n  delay(1000);\n  portal.load(addonJson);                       // Load custom Web pages\n  portal.on(\"/feels\", feelsOn, AC_EXIT_AHEAD);  // Register /feels handler\n  portal.begin();\n}\n\nvoid loop() {\n  portal.handleClient();\n}\n</code></pre> <p>The above example handles in the handler for the values of a custom Web page. An AutoConnect::on function registers a handler for the AutoConnectAux page of the specified uri. The argument of the custom Web page handler is an AutoConnectAux of the page itself and the PageArgument object.</p> <p>To retrieve the values entered in a custom Web page you need to access the AutoConnectElement of the page that caused the request to this page and to do this, you use the AutoConnect::where function. The <code>AutoConnect::where</code> function returns an uri string of the AutoConnectAux object of the custom Web page that caused the HTTP request.</p> <p>The where() function is available for only AutoConnectAux.</p> <p>The <code>AutoConnect::where</code> function is available only for the AutoConnectAux object. It is invalid for HTTP requests from individual pages registered with the on handler of ESP8266WebServer/WebServer for ESP32. In other words, the <code>AutoConnect::where</code> function only returns the last AutoConnecAux page called.</p>"},{"location":"achandling.html#when-setting-the-initial-values","title":"When setting the initial values","text":"<p>An AutoConnectAux page is dynamically created by AutoConnect when its uri is requested. The initial value of AutoConnectElements can be set before its page request. It is also possible during <code>loop()</code>. To set the initial value when the page is accessed it needs by the handler of its page.</p> <p>The AutoConnect::on and AutoConnectAux::on functions register a handler for a custom Web page and also specify when to call that handler. The behavior of the two <code>on</code> functions is the same, only the class and arguments are different.</p> <p><pre><code>bool AutoConnect::on(const String&amp; uri, const AuxHandlerFunctionT handler, AutoConnectExitOrder_t order)\n</code></pre> <pre><code>void AutoConnectAux::on(const AuxHandlerFunctionT handler, const AutoConnectExitOrder_t order)\n</code></pre></p> <p>Parameter <code>uri</code> specifies an URI of the custom Web page, but an AutoConnectAux object with its URI must be registered with AutoConnect via the AutoConnect::join function beforehand.</p> <p>AutoConnect::on/AutoConnectAux::on is not ESP8266WebServer::on</p> <p>The <code>on</code> function for AutoConnect is different from the <code>on</code> function of Arduino core ESP8266WebServer (WebServer for ESP32). You can share the same handler via wrapper, but access to AutoConnectElements is valid only for handlers registered with <code>on</code> function for AutoConnect.</p> <p><code>AuxHandlerFunctionT</code> type is a handler declaration using with std::function.</p> <pre><code>String handler(AutoConnectAux&amp; aux, PageArgument&amp; args)\n</code></pre> <p>The handler of the custom Web page has two arguments by a reference of AutoConnectAux and a reference of PageArgument, it returns String. AutoConnect appends the string returned from the handler to the generated HTML. This allows you to add an HTML part before displaying the page.</p> <code>AutoConnectExitOrder_t</code> specifies when the handler is called with the following enumeration value. <ul> <li>AC_EXIT_AHEAD : Called before AutoConnect generates the HTML of the page. You set the value of AutoConnectElements in the handler then its value will be displayed on the page.</li> </ul> <ul> <li>AC_EXIT_LATER : Called after AutoConnect generates the HTML of the page. You can append to HTML generated by AutoConnect.</li> </ul> <ul> <li>AC_EXIT_BOTH : Called even before generating HTML and after generated.</li> </ul> <p>The following example is a part of sketch contained the handlers. </p> <pre><code>// AutoConnect object declarations\nACInput(input1);\nAutoConnectAux aux(\"/aux\", { input1 });\nAutoConnect portal;\n// Pre-declare handlers\nString initialize(AutoConnectAux&amp;, PageArgument&amp;);\nString append(AutoConnectAux&amp;, PageArgument&amp;);\n\n// Register handlers and launch the portal.\naux.on(initialize, AC_AHEAD);\naux.on(append, AC_LATER);\nportal.join(aux);\nportal.begin();\n\n// Some code here...\n\n// The handler called before HTML generating\nString initialize(AutoConnectAux&amp; aux, PageArgument&amp; args) {\n  AutoConnectInput&amp; input1 = aux.getElement&lt;AutoConnectInput&gt;(\"input1\");\n// Set initial value for the input box in a custom Web page.\n  input1.value = \"Initial value\";\n// Nothing appendix for a generated HTML.\nreturn String();\n}\n\n// The handler called after HTML generated\nString append(AutoConnectAux&amp; aux, PageArgument&amp; args) {\n// Append an HTML\nreturn String(\"&lt;p&gt;This text has been added.&lt;/p&gt;\");\n}\n</code></pre>"},{"location":"achandling.html#how-you-can-reach-the-values","title":"How you can reach the values","text":"<p>AutoConnectSubmit uses the POST method to send HTTP requests. A value of AutoConnectInput sent to the ESP8266 or ESP32 with POST is stored in the request body of the HTTP request: <pre><code>POST /feels HTTP/1.1\nHost: ESP8266_IP_ADDRESS\nname1=value1&amp;name2=value2&amp;name3=value3\n</code></pre> ESP8266WebServer class will parse the query string and rebuilds its arguments when the above request arrives. A custom page handler registered with the ESP8266WebServer::on function can access the value of AutoConnectElements with ESP8266WebServe::arg function. It reaches the values of AutoConnectElements without the intermediation of AutoConnect. Therefore, its handler will not be AutoConnectAux and can send a response to the client directly. The following example is part of a server sketch which has two web pages. The <code>/hello</code> page is a custom Web page of AutoConnectAux which has an input box named \"input1\". Another <code>/echo</code> page is a page handler for ESP8266WebServer, which uses the ESP8266WebServer::send function to echo back the value of an input1 as an http response.</p> <pre><code>ESP8266WebServer server;\nAutoConnect      portal(server);\nACInput(input1, \"\", \"INPUT\");\nACSubmit(send, \"HELLO\", \"/echo\");\nAutoConnectAux  aux(\"/hello\", { input1, send });\n\nserver.on(\"/echo\", []() {\n  String echo = server.arg(\"input1\");\n  Serial.println(echo);\n  server.send(200, \"text/plain\", echo);\n});\n\nportal.join(aux);\nportal.begin();\n</code></pre> <p>Also, you can choose another way to access arguments without going through the ESP8266WebServer class. The PageArgument object of the custom Web page handler argument is a copy of the arg object of the ESP8266WebServer class. Either of these methods is a simple and easy way to access parameters in custom Web page handlers. However, if you need to access from outside of the handler to the value of AutoConnectElements, you need to accomplish it using with the AutoConnectAux::getElement function. The following sketch code replaces the above example with JSON and PageArgument, and its behaves is equivalent basically to the above sketch.</p> <pre><code>const static char auxPage[] PROGMEM = R\"raw(\n[\n  { \"title\":\"Hello\", \"uri\":\"/hello\", \"menu\":true, \"element\":[\n    { \"name\":\"input1\", \"type\": \"ACInput\", \"label\": \"INPUT\" },\n    { \"name\":\"send\", \"type\":\"ACSubmit\", \"value\":\"HELLO\", \"uri\":\"/echo\" }]\n  },\n  { \"title\":\"Echo\", \"uri\":\"/echo\", \"menu\":false, \"element\":[\n    { \"name\":\"echo\", \"type\":\"ACText\" }]\n  }\n]\n)raw\";\n\nAutoConnect portal;\n\nportal.load(auxPage);\nportal.on(\"/echo\", [](AutoConnectAux&amp; aux, PageArgument&amp; args) {\n  AutoConnectText&amp; ac_echo = aux.getElement&lt;AutoConnectText&gt;(\"echo\");\n  ac_echo.value = args.arg(\"input1\");\nreturn String();  \n});\n\nportal.begin();\n</code></pre>"},{"location":"achandling.html#get-autoconnectelement-values-from-the-transition-source","title":"Get AutoConnectElement values from the transition source","text":"<p>Usually, the page transition called by the custom web page handler will have an HTTP request directed to the destination URL. Its HTTP request has parameters enclosed by the POST method, all of which are AutoConnectElements placed on the transition source page. On the other hand, the custom web page handler's first argument points to AutoConnectAux after the transition, so the handler cannot access the AutoConnectElement values placed at the transition source using the first argument.</p> <p>Custom Web paga handler has two ways to access AutoConnectElements placed on the transition source page: combining the AutoConnect::where and AutoConnect::aux functions or using the AutoConnectAux::referer function. The following code snippet shows the difference between the two methods of identifying the <code>input1</code> AutoConnectInput with the <code>/echo</code> page handler after the transition based on the <code>/hello</code> page described above.</p> <pre><code>portal.on(\"/echo\", [](AutoConnectAux&amp; aux, PageArgument&amp; args) {\n  AutoConnectAux&amp;   ac_hello = *portal.aux(portal.where());\n  AutoConnectInput&amp; ac_input1 = ac_hello[\"input1\"].as&lt;AutoConnectInput&gt;();\n  Serial.println(ac_input1.value);\nreturn String();  \n});\n</code></pre> <pre><code>portal.on(\"/echo\", [](AutoConnectAux&amp; aux, PageArgument&amp; args) {\n  AutoConnectAux&amp;   ac_hello = portal.referer();\n  AutoConnectInput&amp; ac_input1 = ac_hello[\"input1\"].as&lt;AutoConnectInput&gt;();\n  Serial.println(ac_input1.value);\nreturn String();  \n});\n</code></pre>"},{"location":"achandling.html#transfer-of-input-values-across-pages","title":"Transfer of input values across pages","text":"<p>Since v1.0.0, AutoConnect supports a new attribute with each element that allows automatic transfer of input values across pages without sketching. AutoConnect will copy the input value of the elements declared as global to the same-named global elements on a different custom Web pages at the page transition timing.</p> <p> </p> <p>The global attribute will be useful for echoing input values back to another custom Web pages. This copy operation can be performed between different types. (eg., copy value from AutoConnectInput to AutoConnectText) The following example reflects the input value of PAGE1 to the AutoConnectText field of PAGE2 without sketch code.</p> <pre><code>static const char PAGE1[] PROGMEM = R\"(\n{\n  \"title\": \"PAGE1\",\n  \"uri\": \"/page1\",\n  \"menu\": true,\n  \"element\": [\n    {\n      \"name\": \"input1\",\n      \"type\": \"ACInput\",\n      \"global\": true\n    },\n    {\n      \"name\": \"send\",\n      \"type\": \"ACSubmit\",\n      \"value\": \"OK\",\n      \"uri\": \"/page2\"\n    }\n  ]\n}\n)\";\nstatic const char PAGE2[] PROGMEM = R\"(\n{\n  \"title\": \"PAGE2\",\n  \"uri\": \"/page2\",\n  \"menu\": false,\n  \"element\": [\n    {\n      \"name\": \"input1\",\n      \"type\": \"ACText\",\n      \"global\": true\n    }\n  ]\n}\n)\";\n\nAutoConnect portal;\nAutoConnectAux page1;\nAutoConnectAux page2;\n\nvoid setup() {\n  page1.load(PAGE1);\n  page2.load(PAGE2);\n  portal.join( { page1, page2 });\n  portal.begin();\n}\n\nvoid loop() {\n  portal.handleClient();\n}\n</code></pre> <p> The value entered in input1 declared in PAGE1 is reflected in input1 of PAGE2 as an AutoConnectText value even if there is no sketch code to transfer it to PAGE2. It's shown as like: </p> <p>Copy only for same-named and the global</p> <p>The input value will be copied only if the global attribute of the destination element is true. If an element with the same name is declared non-global, the value is not copied.</p>"},{"location":"achandling.html#retrieve-the-values-with-webserveron-handler","title":"Retrieve the values with WebServer::on handler","text":"<p>ESP8266WebServer class and the WebServer class assume that the implementation of the ReqestHandler class contained in the WebServer library will handle the URL requests. Usually, it is sketch code registered by ESP8266WebServer::on function.</p> <p>When a page transition from a custom Web page created by AutoConnectAux to a handler registered with ESP2866WebServer::on function, a little trick is needed to retrieve the values of AutoConnectElements. (i.e. the URI of the ESP8266WebServer::on handler is specified in the uri attribute of AutoConnectSubmit) AutoConnect cannot intervene in the procedure in which the ESP8266WebServer class calls the on-page handler coded with the Sketch. Therefore, it is necessary to retrieve preliminary the values of AutoConnectElements using the AutoConnectAux::fetchElement function for value processing with the on-page handler.</p> <p>The following sketch is an example of extracting values inputted on a custom web page with an on-page handler and then processing it.</p> <pre><code>ESP8266WebServer server;\nAutoConnect portal(server);\nAutoConnectAux Input;\n\nconst static char InputPage[] PROGMEM = R\"r(\n{\n  \"title\": \"Input\", \"uri\": \"/input\", \"menu\": true, \"element\": [\n    { \"name\": \"input\", \"type\": \"ACInput\", \"label\": \"INPUT\" },\n    {\n      \"name\": \"save\",\n      \"type\": \"ACSubmit\",\n      \"value\": \"SAVE\",\n      \"uri\": \"/\"\n    }\n  ]\n}\n)r\";\n\n// An on-page handler for '/' access\nvoid onRoot() {\n  String  content =\n\"&lt;html&gt;\"\n\"&lt;head&gt;&lt;meta name='viewport' content='width=device-width, initial-scale=1'&gt;&lt;/head&gt;\"\n\"&lt;body&gt;&lt;div&gt;INPUT: {{value}}&lt;/div&gt;&lt;/body&gt;\"\n\"&lt;/html&gt;\";\n\n  Input.fetchElement();    // Preliminary acquisition\n// For this steps to work, need to call fetchElement function beforehand.\n  String value = Input[\"input\"].value;\n  content.replace(\"{{value}}\", value);\n  server.send(200, \"text/html\", content);\n}\n\nvoid setup() {\n  Input.load(InputPage);\n  portal.join(Input);\n  server.on(\"/\", onRoot);  // Register the on-page handler\n  portal.begin();  \n}\n\nvoid loop() {\n  portal.handleClient();\n}\n</code></pre>"},{"location":"achandling.html#overwrite-the-autoconnectelements","title":"Overwrite the AutoConnectElements","text":"<p>Sketches can update the attributes of AutoConnectElements with two approaches. A one is to assign directly to the attributes of a member variable of its element. The other is to overwrite them with loading the element by AutoConnectAux::loadElement. </p> <p>The elements for attributes described in the JSON document for AutoConnectElements overwrites the member variables of the target AutoConnectElements. However, AutoConnectAux::loadElement keeps the member variables unchanged if there is no element in the JSON document. This overwriting behavior is the same for the AutoConnect::load function.</p> <p>For example, the combination of the Sketch and JSON document as follows updates only the style while keeping Caption (ie. \"Hello, world\") as AutoConnectText value.</p> <p> External JSON document for the below sketch to modify the text style. <pre><code>{\n\"name\" : \"Caption\",\n\"type\" : \"ACText\",\n\"style\": \"text-align:center;font-size:24px;font-family:'Impact','Futura',sans-serif;color:tomato;\"\n}\n</code></pre></p> <p>  the Sketch (a part of code), load above JSON. <pre><code>ACText(Caption, \"Hello, world\");\nAutoConnectAux helloPage(\"/hello\", \"Hello\", true, { Caption });\nAutoConnect portal;\n\nString onHello(AutoConnectAux&amp; aux, PageArgument&amp; args) {\n  aux.loadElement(JSON);\nreturn String();\n}\n\nvoid setup() {\n  helloPage.on(onHello);\n  portal.join(helloPage);\n  portal.begin();\n}\n\nvoid loop() {\n  portal.handleClient();\n}\n</code></pre>  It's shown as like:</p>"},{"location":"achandling.html#check-data-against-on-submission","title":"Check data against on submission","text":"<p>By giving a pattern to AutoConnectInput, you can find errors in data styles while typing in custom Web pages. The pattern is specified with regular expression.2 If the value during input of AutoConnectInput does not match the regular expression specified in the pattern, its background color changes to pink. The following example shows the behavior when checking the IP address in the AutoConnectInput field.</p> <pre><code>{\n\"title\" : \"Page-1\",\n\"uri\" : \"/page1\",\n\"menu\" : true,\n\"element\" : [\n    {\n\"name\" : \"Server\",\n\"type\" : \"ACInput\",\n\"label\": \"Server address\",\n\"pattern\": \"^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$\"\n    }\n  ]\n}\n</code></pre> <p> It's shown as like: </p> <p>If you are not familiar with regular expressions, you may feel that description very strange. Matter of fact, it's a strange description for those who are unfamiliar with the formal languages. If your regular expression can not interpret the intended syntax and semantics, you can use an online tester. The regex101 is an exceptional online tool for testing and debugging regular expressions.</p>"},{"location":"achandling.html#input-data-validation","title":"Input data validation","text":"<p>The pattern attribute of AutoConnectInput only determines the data consistency on the web browser based on the given regular expression. In order to guarantee the validity of input data, it is necessary to verify it before actually using it.</p> <p>You can validate input data from AutoConnectInput using the isValid function before actually processing it.  The isValid function determines whether the value currently stored in AutoConnectInput matches the pattern.</p> <p>You can also use the AutoConnectAux::isValid function to verify the data input to all AutoConnectInput elements on the custom Web page at once. The two sketches below show the difference between using AutoConnectInput::isValid and using AutoConnectAux::isValid. In both cases, it verifies the input data of the same AutoConnectInput, but in the case of using AutoConnectAux::isValid, the amount of sketch coding is small.</p>"},{"location":"achandling.html#common-declaration","title":"Common declaration","text":"<pre><code>const char PAGE[] PROGMEM = R\"(\n{\n  \"title\": \"Custom page\",\n  \"uri\": \"/page\",\n  \"menu\": true,\n  \"element\": [\n    {\n      \"name\": \"input1\",\n      \"type\": \"ACInput\",\n      \"pattern\": \"^[0-9]{4}$\"\n    },\n    {\n      \"name\": \"input2\",\n      \"type\": \"ACInput\",\n      \"pattern\": \"^[a-zA-Z]{4}$\"\n    }\n  ]\n}\n)\";\nAutoConnectAux page;\npage.load(PAGE);\n</code></pre>"},{"location":"achandling.html#using-autoconnectinputisvalid","title":"Using AutoConnectInput::isValid","text":"<pre><code>AutoConnectInput&amp; input1 = page[\"input1\"].as&lt;AutoConnectInput&gt;();\nAutoConnectInput&amp; input2 = page[\"input2\"].as&lt;AutoConnectInput&gt;();\nif (!input1.isValid() || !input2.isValid())\n  Serial.println(\"Validation error\");\n</code></pre>"},{"location":"achandling.html#using-autoconnectauxisvalid","title":"Using AutoConnectAux::isValid","text":"<pre><code>if (!page.isValid())\n  Serial.println(\"Validation error\");\n</code></pre>"},{"location":"achandling.html#convert-data-to-actually-type","title":"Convert data to actually type","text":"<p>The values in the AutoConnectElements field of the custom Web page are all typed as String. A sketch needs to be converted to an actual data type if the data type required for sketch processing is not a String type. For the typical data type conversion method, refer to section Tips for data conversion.</p>"},{"location":"achandling.html#place-html-elements-undefined-in-autoconnectelements","title":"Place HTML elements undefined in AutoConnectElements","text":"<p>Of the many HTML elements for markup, AutoConnet can only support a limited number. If you are designing a custom web page and the elements you want are not in AutoConnectElements, consider using an AutoConnectElement. AutoConnectElement can be applied in many cases when trying to place HTML tag elements that are undefined in AutoConnectElemets on custom web pages.</p> <p>Not all of them work</p> <p>The strongest constraint is the heap size required to generate HTML for the entire custom Web page. AutoConnect creates a custom web page as a chunk of String. It's not a stream. Therefore, it may not be possible to generate long HTML pages. See also FAQ.</p>"},{"location":"achandling.html#place-a-markup-or-a-styled-html-tag","title":"Place a markup or a styled HTML tag","text":"<p>If the HTML element you want to place is just the tag that makes up the appearance of the web page, assign the tag element directly to the value member of AutoConnectElement. If the tag you are trying to place is for static markup effects, just write the <code>value</code> as follows:</p> <pre><code>{\n\"name\": \"headline\",\n\"type\": \"ACElement\",\n\"value\": \"&lt;hr style='height:1px;border-width:0;color:gray;background-color:#52a6ed'&gt;\"\n}\n</code></pre> <p>If the element has a hierarchy like a <code>&lt;table&gt; ~ &lt;/table&gt;</code>, describe the entire element in the <code>value</code>:</p> <pre><code>{\n\"name\": \"table\",\n\"type\": \"ACElement\",\n\"value\": \"&lt;table&gt;&lt;tr&gt;&lt;th&gt;Board&lt;/th&gt;&lt;th&gt;Platform&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;NodeMCU&lt;/td&gt;&lt;td&gt;Espressif8266&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ESP32-DevKitC&lt;/td&gt;&lt;td&gt;Espressif32&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;\"\n}\n</code></pre> <p>Also, using AutoConnectStyle combined, you can give the style effect of only that element.</p> <pre><code>{\n\"name\": \"tablestyle\",\n\"type\": \"ACStyle\",\n\"value\": \"table.style{font-family:arial,sans-serif;border-collapse:collapse;width:100%;color:black;}table.style td,table.style th{border:1px solid #dddddd;text-align:center;padding:8px;}table.style tr:nth-child(even){background-color:#dddddd;}\"\n},\n{\n\"name\": \"table\",\n\"type\": \"ACElement\",\n\"value\": \"&lt;table class='style'&gt;&lt;tr&gt;&lt;th&gt;Board&lt;/th&gt;&lt;th&gt;Platform&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;NodeMCU&lt;/td&gt;&lt;td&gt;Espressif8266&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ESP32-DevKitC&lt;/td&gt;&lt;td&gt;Espressif32&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;\"\n}\n</code></pre> <p>  As you see it:  Board Platform NodeMCU Espressif8266 ESP32-DevKitC Espressif32 </p>"},{"location":"achandling.html#place-the-input-elements-within-a-form","title":"Place the input elements within a form","text":"<p>There is still no dedicated AutoConnectElement for entering other than equivalent to <code>checkbox</code>, <code>file</code>, <code>number</code>, <code>password</code>, <code>radio</code> and <code>text</code> for <code>&lt;input type=\"...\"&gt;</code> HTML element. But you can substitute them with the AutoConnectElement.</p> <p>For example, if you use the <code>&lt;input&gt;</code> element of <code>type=\"date\"</code> to place a field where you can enter a date, the AutoConnectElement would look like this:</p> <pre><code>{\n\"name\": \"date\",\n\"type\": \"ACElement\",\n\"value\": \"&lt;label for='picker'&gt;Date:&lt;/label&gt;&lt;input type='date' id='picker' name='date'&gt;\"\n}\n</code></pre> <p>And it becomes a textbox that validates the input or a special date picker interface. Then, instead of accessing that AutoConnectElement directly, obtains entered date value from the POST body included in the HTTP request from the hosted ESP8266WebServer class. Its process carries out with the AutoConnectAux page handler following:</p> <pre><code>String aux_page_handler(AutoConnectAux &amp;aux, PageArgument &amp;arg) {\n  Serial.println(arg.arg(\"date\"));  // Obtain a date value entered\nreturn \"\";\n}\n</code></pre> <p>AutoConnect passes a PageArgument to the AutoConnectAux page handler. The handler can use the PageArgument::arg function to get the parameters contained in the HTTP request for the page.  Also, the equivalent can also be implemented using ESP8266WebServer::arg function with the ESP8266WebServer client request handler.</p>"},{"location":"achandling.html#using-javascript","title":"Using JavaScript","text":"<p>What is described in this section belongs to the tips of what effectiveness a web page can have using AutoConnectElement, rather than the correct usage for AutoConnect. You can use AutoConnectElement to embed JavaScript into the custom Web page as with HTML elements for markup. The reason for embedding JavaScript on a page depends on your requirements, but One of the most common requirements is the need to access elements of a web page. You can implement the requirements by having the AutoConnectElement have JavaScript that contains DOM access.</p> <p>The following screenshot shows an example of accessing AutoConnectText via the DOM using an AutoConnectElement with JavaScript. This web page is a very simple example and returns the result of multiplying the multiplier entered in an AutoConnectInput field.</p> <p></p> <p>This custom Web page is generated from the following JSON document:</p> <pre><code>{\n\"uri\": \"/jselement\",\n\"title\": \"Multiply\",\n\"menu\": true,\n\"element\": [\n    {\n\"name\": \"multiplier\",\n\"type\": \"ACInput\",\n\"label\": \"3 &amp;times; \",\n\"apply\": \"number\",\n\"posterior\": \"none\"\n    },\n    {\n\"name\": \"op\",\n\"type\": \"ACButton\",\n\"value\": \" = \",\n\"action\": \"multi()\",\n\"posterior\": \"none\"\n    },\n    {\n\"name\": \"answer\",\n\"type\": \"ACText\"\n    },\n    {\n\"name\": \"js\",\n\"type\": \"ACElement\",\n\"value\": \"&lt;script type='text/javascript'&gt;function multi() {document.getElementById('answer').innerHTML=3*document.getElementById('multiplier').value;}&lt;/script&gt;\"\n    }\n  ]\n}  \n</code></pre> <p>An input field for a <code>multiplier</code> is defined by AutoConnectInput. The field for displaying the results exists with the name <code>answer</code>. The multiplication function is what AutoConnectElement has as JavaScript and it has the following content:</p> <pre><code>function multi() {\n  document.getElementById('answer').innerHTML = 3 * document.getElementById('multiplier').value;\n}\n</code></pre> <p>And the action for calling the <code>multi()</code> function is the <code>=</code> labeled button as the AutoConnectButton element. AutoConnect generates the name attribute of each AutoConnectElement as the Id of the HTML tag. The Id should be useful for DOM access.</p> <p>JavaScript that is too long can cause insufficient memory</p> <p>If it reaches thousands of bytes, AutoConnect will not be able to complete the HTML generation for the page.</p>"},{"location":"achandling.html#custom-web-pages-communication-without-page-transitions","title":"Custom Web pages communication without page transitions","text":"<p>The request-response form typically provided by AutoConnectAux is based on stateless HTTP page transitions. Its communication between custom Web pages and sketches involves page transitions in the client browser via the request-response form. However, major Web browsers support HTTP asynchronous communication without page transitions. By embedding those Web APIs in your custom Web pages, you can implement sketches that do not disrupt the user working flow with page transitions.</p> <p>There are two types of Web APIs that allow asynchronous communication that can be used with AutoConnectAux:</p> <ul> <li> <p>XMLHttpRequest</p> <p>JavaScript embedded in a custom web page uses the XMLHttpRequest (XHR) objects to communicate with the request handler on the sketch side. A sketch typically embeds its JavaScript coded as a string value with AutoConnectElement into a custom web page JSON description.</p> <p>The request handler that is communication partner with the above JavaScript should be implemented in the sketch as the Client request handlers of the ESP8266WebServer (WebServer for ESP32) class.</p> <p>The procedure for implementing a sketch in this manner is described in a subsequent section.</p> </li> <li> <p>Fetch API</p> <p>The Fetch API supported by AutoConnectAux is even easy to implement than XHR. AutoConnectElements can execute Fetch API-driven JavaScript that can communicate with the server sketch. Its script will be triggered by expected events and automatically be embedded into the HTML source of your custom web page by AutoConnect.</p> <p>Also, the sketch process with which the above Fetch API script communicates can access and update the values and properties of each AutoConnectElement. Updated AutoConnectElement contents are immediately reflected on the custom web page by sending a response.</p> <p>The Fetch API-driven approach based on AutoConnectElements event firing is described in the section of Interact with sketches by AutoConnectElements event.</p> </li> </ul>"},{"location":"achandling.html#communicate-with-the-sketch-using-xhr","title":"Communicate with the Sketch using XHR","text":"<p>AutoConnectElement allows having scripts that make HTTP sessions based on XHR. XHR (XMLHttpRequest) is a JavaScript API to create AJAX requests. Its methods allow sending network requests between the browser and a server. The sketch implements the server-side process as a response handler to a standard HTTP request and can equip it with a dynamic custom Web page. This technique is tricky but is useful when implementing dynamic pages because it does not cause page transitions. As a matter of fact, AutoConnectOTA class is implemented with this technique and is a custom web page by AutoConnectAux using XHR.</p> <p>Here's a simple example of JavaScript-based on XHR and a server-side request handler. It's like a clock that displays the time in real-time on an AutoConnect custom web page. The sketch in the following example is roughly divided into two structures. The AutoConnectElement defined with the name <code>js</code> gets the server time with XHR and updates the response via the DOM with the AutoConnectText named <code>time</code> and substance is the following JavaScript:</p> <pre><code>var xhr;\n\nfunction clock() {\nxhr.open('GET', '/clock');\nxhr.responseType = 'text';\nxhr.send();\n}\n\nwindow.onclose = function() {\nxhr.abort();\n};\n\nwindow.onload = function() {\nxhr = new XMLHttpRequest();\nxhr.onreadystatechange = function() {\nif (this.readyState == 4 &amp;&amp; xhr.status == 200) {\n      document.getElementById('time').innerHTML = this.responseText;\n    }\n  };\nsetInterval(clock, 1000);\n};\n</code></pre> <p>This script issues a GET request to <code>/clock</code> every second and updates the element of Id=<code>time</code> with the text content of its response. As this script shows, it will issue a send request using the XMLHttpRequest object.</p> <p>The other component is located on the AutoConnect-hosted ESP8266WebServer server. This component gets the current time from the NTP server and sends the value as text to the client.</p> <pre><code>void auxClock() {\ntime_t  t;\nstruct tm *tm;\nchar    dateTime[24];\n\n  t = time(NULL);\n  tm = localtime(&amp;t);\n  sprintf(dateTime, \"%04d/%02d/%02d %02d:%02d:%02d.\",\n                    tm-&gt;tm_year + 1900, tm-&gt;tm_mon + 1, tm-&gt;tm_mday,\n                    tm-&gt;tm_hour, tm-&gt;tm_min, tm-&gt;tm_sec);\n  server.send(200, \"text/plain\", dateTime);\n}\n</code></pre> <p>Then just register the <code>auxClock</code> function as a <code>/clock</code> URL handler with the hosted ESP8266Server instance.</p> <pre><code>server.on(\"/clock\", auxClock);\n</code></pre> <p>As you can see from the above two components, AutoConnect does not intervene in those communications and no page transitions occur. A complete sketch that integrates the above components and includes a custom Web page declaration for time display looks like this:</p> <pre><code>#include &lt;Arduino.h&gt;\n#include &lt;ESP8266WiFi.h&gt;\n#include &lt;ESP8266WebServer.h&gt;\n#include &lt;AutoConnect.h&gt;\n#include &lt;time.h&gt;\n\nstatic const char JSPAGE[] PROGMEM = R\"'(\n{\n  \"uri\": \"/jselement\",\n  \"title\": \"Clock\",\n  \"menu\": true,\n  \"element\": [\n    {\n      \"name\": \"time\",\n      \"type\": \"ACText\"\n    },\n    {\n      \"name\": \"js\",\n      \"type\": \"ACElement\",\n      \"value\": \"&lt;script type='text/javascript'&gt;var xhr;function clock(){xhr.open('GET', '/clock');xhr.responseType='text';xhr.send();}window.onclose=function(){xhr.abort();};window.onload=function(){xhr=new XMLHttpRequest();xhr.onreadystatechange=function(){if(this.readyState==4&amp;&amp;xhr.status==200){document.getElementById('time').innerHTML=this.responseText;}};setInterval(clock,1000);};&lt;/script&gt;\"\n    }\n  ]\n}  \n)'\";\n\nESP8266WebServer  server;\nAutoConnect portal(server);\n\nvoid auxClock() {\ntime_t  t;\nstruct tm *tm;\nchar    dateTime[24];\n\n  t = time(NULL);\n  tm = localtime(&amp;t);\n  sprintf(dateTime, \"%04d/%02d/%02d %02d:%02d:%02d.\",\n                    tm-&gt;tm_year + 1900, tm-&gt;tm_mon + 1, tm-&gt;tm_mday,\n                    tm-&gt;tm_hour, tm-&gt;tm_min, tm-&gt;tm_sec);\n  server.send(200, \"text/plain\", dateTime);\n}\n\nvoid setup() {\n  delay(1000);\n  portal.load(FPSTR(JSPAGE));\nif (portal.begin()) {\n    server.on(\"/clock\", auxClock);\n    configTime(0, 0, \"europe.pool.ntp.org\");\n  }\n}\n\nvoid loop() {\n  portal.handleClient();\n}\n</code></pre>"},{"location":"achandling.html#interact-with-sketches-by-autoconnectelements-event","title":"Interact with sketches by AutoConnectElements event","text":"<p>AutoConnectAux supports Fetch API besides XMLHttpRequest for communication between the client browser and the ESP module. This allows your sketches to get and change values and properties of AutoConnectElements without a page transition on the browser. The changed values and properties are immediately reflected in the page currently being viewed in the browser.</p> <p>The following screenshot shows that a custom web page using the Fetch API can blink the LED on the ESP module without any page transitions. And it allows the custom web page changes the text color and button caption in sync with the LED flashing.</p> <p></p> <p>The sketch implemented for the above demonstration does not need to write JavaScript code to handle the Fetch API. Its Fetch API script will automatically be embedded in the HTML source of your custom web page by AutoConnect. All you need to do is describe your custom web page in JSON and write AutoConnectElements event handlers to apply to user interaction. </p> <p>How to sketch with the AutoConnectElements events is covered in detail in chapter Interact with Sketch and AutoConnectElements.</p>"},{"location":"achandling.html#transitions-of-the-custom-web-pages","title":"Transitions of the custom Web pages","text":""},{"location":"achandling.html#scope-lifetime-of-autoconnectaux","title":"Scope &amp; Lifetime of AutoConnectAux","text":"<p>AutoConnectAux and AutoConnectElements must live while the custom Web pages are available. The implementation of the custom Web page inherits from requestHandler driven from ESP8266WebServer (WebServer for ESP32), so the instance of AutoConnectAux and AutoConnectElements must exist for the duration of effect of handleClient. The following example is incorrect for manipulating custom Web pages. Its AutoConnectAux instance will be destructed at the exit of the setup().</p> <pre><code>#include &lt;ESP8266WiFi.h&gt;\n#include &lt;ESP8266WebServer.h&gt;\n#include &lt;AutoConnect.h&gt;\n\nstatic const auxPage[] PROGMEM = R\"raw(\n{\n  \"title\": \"Page-1\",\n  \"uri\": \"/page1\",\n  \"menu\": true,\n  \"element\": [\n    { \"name\":\"Server\", \"type\":\"ACText\", \"label\":\"Server address\" }\n  ]\n}\n)raw\";\n\nAutoConnect  portal;\n\nvoid setup() {\n// This declaration is wrong.\n  AutoConnectAux aux;\n  aux.load(auxPage);\n  portal.join(aux);\n  portal.begin();\n}\n\nvoid loop() {\n  portal.handleClient();\n}\n</code></pre>"},{"location":"achandling.html#the-uri-of-the-custom-web-pages","title":"The URI of the custom Web pages","text":"<p>The transition of the custom Web page follows the URI of the page, but the ESP8266WebServer class does not know the URI of an AutoConnectAux page. (Registering a custom Web page does not use the ESP8266WebServer::on/WebServer::on function.) Therefore ESP8266WebServer class does not detect its URI access. If you want to detect an http request to AutoConnectAux's custom Web page, you need to register its URI with the AutoConnectAux::on function.</p> <p>In addition to this, there are restrictions in the handler for the custom Web page as shown in the following section.</p>"},{"location":"achandling.html#an-http-response-from-the-custom-web-page-handler","title":"An HTTP response from the custom Web page handler","text":"<p>Normally, a custom web page handler does not need to respond to a request from the client. Its HTTP response will be sent by AutoConnect when it returns from the custom web page handler. In that case, the HTTP response code is 200.</p> <p>However, this structure requires AutoConnectAux to always respond with the page content. If AutoConnectAux does not have page content as an HTTP response, then the custom web page handler can respond with its own HTTP response by following the steps:</p> <ol> <li> <p>Declare an AutoConnectAux with the <code>responsive</code> argument set to <code>false</code>, or describe <code>\"response\":false</code> with JSON:</p> <pre><code>AutoConnectAux aux(\"/aux\", \"AUX\", false, {}, false);\n</code></pre> <pre><code>{\n\"title\": \"AUX\",\n\"uri\": \"/aux\",\n\"response\": false,\n\"menu\": false\n}\n</code></pre> </li> <li> <p>Send an HTTP response from a custom web page handler (Case of ESP32):</p> <p><pre><code>WebServer   server;\nAutoConnect portal(server);\n\nString handleAux(AutoConnectAux&amp; aux, PageArgument&amp; args) {\n  server.send(202, \"text/plain\", \"Accepted\");\nreturn String();\n}\n\nportal.on(\"/aux\", handleAux);\n</code></pre> If you want to respond with a 302 from a custom web page handler, you can use the AutoConnectAux::redirect function. <pre><code>String handleAux(AutoConnectAux&amp; aux, PageArgument&amp; args) {\n  aux.redirect(\"http://redirect.url:port/?query\");\nreturn String();\n}\n</code></pre></p> </li> </ol>"},{"location":"achandling.html#limitations","title":"Limitations","text":"<p>The custom Web pages handler has the following limitations.</p> <ul> <li> <p>Do not send HTTP responses from the handler.</p> <p>If the handler returns its own response, the custom Web page will be lost.</p> </li> <li> <p>Use AutoConnectSubmit whenever possible.</p> <p>AutoConnect will hold the values of a custom Web Page is sent by AutoConnectSubmit.</p> </li> <li> <p>Can not handle the custom Web pages during a connection is not established yet.</p> <p>During the connection attempt, the web browser of the client will send a probe for a captive portal. Its request will cause unintended custom Web page transitions.</p> </li> <li> <p>Can not place URI of the custom Web pages to AUTOCONNECT_URI.</p> <p>AutoConnect will not work if you place a custom Web page to AUTOCONNECT_URI.</p> </li> <li> <p>Can not use the element named SUBMIT.</p> <p>You can not use 'SUBMIT' as the element name of AutoConnectElements in a custom Web page that declares the AutoConnectSubmit element. (Case sensitive ignored) AutoConnect does not rely on the <code>input type=submit</code> element for the form submission and uses HTML form element submit function instead. So, the submit function will fail if there is an element named 'submit' in the form.</p> </li> </ul> <p>Do not handle for the same page</p> <p>Do not duplicate AutoConnect::on with ESP8266WebServer::on (also WebServer::on) for the same custom web page.</p> <ol> <li> <p>The valid scope of the name is within an AutoConnectAux.\u00a0\u21a9</p> </li> <li> <p>Regular expression specification as a pattern of AutoConnectInput is JavaScript compliant.\u00a0\u21a9</p> </li> </ol>"},{"location":"acinteract.html","title":"Interact between Sketch and AutoConnectElements","text":""},{"location":"acinteract.html#interaction-with-autoconnectelements-wo-page-transition","title":"Interaction with AutoConnectElements w/o page transition","text":"<p>The substance of the custom web page deployed by AutoConnectAux is just HTML content; AutoConnectAux is just a request handler conforming to the RequestHandler class of the ESP8266 and ESP32 Arduino core's WebServer library.</p> <p>Therefore, the request-response form typically provided by AutoConnectAux is based on stateless HTTP page transitions. Its communication between custom Web pages and sketches involves page transitions in the client browser via the request-response form.</p> <p>However, major Web browsers support HTTP asynchronous communication without page transitions. By embedding those Web APIs in your custom web pages, you can implement sketches that do not disrupt the user working flow with page transitions.</p> <p>AutoConnectAux allows the custom web page to use two types of Web APIs for asynchronous communication with the sketch. Both methods can be accomplished by having JavaScript inherent in the custom web page to communicate with the server sketch (i.e., the AutoConnectAux event handler). </p> <ul> <li> <p>XMLHttpRequest</p> <p>JavaScript embedded in a custom web page uses the XMLHttpRequest (XHR) objects to communicate with the request handler on the sketch side. A sketch typically embeds its JavaScript coded as a string value with AutoConnectElement into a custom web page JSON description.</p> <p>The request handler that is communication partner with the JavaScript should be implemented in the sketch as the Client request handlers of the ESP8266WebServer (WebServer for ESP32) class.</p> <p>The procedure for implementing a sketch in this manner is covered in Communicate with the Sketch using XHR section.</p> </li> <li> <p>Fetch API</p> <p>The Fetch API supported by AutoConnectAux is even easy to implement than XHR. AutoConnectElements can execute Fetch API-driven JavaScript that can communicate with the server sketch. Its script will be triggered by expected events and automatically be embedded into the HTML source of your custom web page by AutoConnect.</p> <p>Also, the sketch process with which the Fetch API scripts communicates can access and update the values and properties of each AutoConnectElement. Updated AutoConnectElement contents are immediately reflected on the custom web page by sending a response.</p> <p>This section describes a Fetch API-driven approach based on AutoConnectElements event firing and the specific API for the sketch implementation.</p> <p>No retries around Fetch API handling</p> <p>The JavaScript containing the Fetch API that AutoConnect automatically embeds in custom web pages does not include retry handling. If the connection with the ESP module is unstable, the request will be reset by the client browser without completing the HTTP transmission/reception. However, the state may be difficult to understand at first glance, and the user may not be able to immediately determine what has happened.</p> <p>When applying the Fetch API on the AutoConnect custom web page, it is recommended to keep the amount of communication as low as possible.</p> </li> </ul>"},{"location":"acinteract.html#interact-with-sketches-by-autoconnectelements-event","title":"Interact with sketches by AutoConnectElements event","text":"<p>Interaction between AutoConnectElements and sketch without page transitions is very smooth. It allows you to complete data exchange with ESP modules on the same page without interrupting your work.</p> <p>The figure below illustrates what a custom web page without page transitions looks like in action. It's a screen capture of a custom web page behavior that controls a simple LED blink (like <code>\"hello, world\\n\"</code> for The C Programming Language), and contains only a caption as AutoConnectText and a button as AutoConnectButton to turn on or off LED. </p> <p></p> <p>The LED ON/OFF button as AutoConnectButton used in this sketch handles the HTML element click event to send the current value to the ESP module. The receiver sketch changes the LED signal level according to the received value and responds to the client with the button's display text and caption color. These send-and-receive exchanges are attribute names and values for AutoConnectButton and AutoConnectText. This sketch handles these actions with the standard HTTP POST method without causing a page transition.</p> <p>The following sections describe APIs and programming methods for interacting with custom web pages with no page transitions, following the sketch structure that implements the above figure.</p>"},{"location":"acinteract.html#associate-events-with-autoconnectelements","title":"Associate events with AutoConnectElements","text":"<p>Custom web pages derived by AutoConnectAux are regular HTML, so it can contain JavaScript that responds to DOM events. The reason why the sketch above figure does not cause a page transition is that the click event with the AutoConnectButton is trigged to send an HTTP POST to the sketch running in the ESP module using the Fetch API.</p> <p>AutoConnect automatically inserts JavaScript that communicates via the Fetch API in response to events if AutoConnectElements with registered an event handler is present on the custom web page. The following code is the JSON description of the custom web page shown above. It is no different from the page description with no event handling.</p> <pre><code>const char LED_ONOFF[] PROGMEM = R\"(\n{\n  \"uri\": \"/led\",\n  \"title\": \"LED\",\n  \"menu\": true,\n  \"element\": [\n    {\n      \"name\": \"caption\",\n      \"type\": \"ACText\",\n      \"value\": \"BUILT-IN LED\",\n      \"style\": \"font-weight:bold;font-size:25px;text-align:center;\",\n      \"posterior\": \"div\"\n    },\n    {\n      \"name\": \"onoff\",\n      \"type\": \"ACButton\",\n      \"value\": \"ON\"\n    }\n  ]\n}\n)\";\n</code></pre> <p>All you need to do is write your custom web page in JSON and write event handlers for AutoConnectElements that apply to user interactions.</p>"},{"location":"acinteract.html#allow-autoconnectelements-to-have-event-processing","title":"Allow AutoConnectElements to have event processing","text":"<p>AutoConnect will automatically embed the JavaScript into the HTML that communicates with a server-side sketch using the Fetch API if the custom web page has AutoConnectElements with an event handler. Use the <code>on</code> function to allow the event-handling capability to elements used for the interaction with the user.</p> <p>To give your custom web page the ability to handle events using Fetch API, roughly follow these steps:</p> <ol> <li> <p>Declare AutoConnectElements for user interaction. It can be declared directly using the constructor of each element or embedded in the JSON description. This procedure is no different from the definition in custom web pages.</p> </li> <li> <p>Identify elements that allow events after loading a custom web page. Usually, you use the AutoConnectAux::getElement function (or override operator <code>[]</code>) accompanied by the AutoConnect::aux or AutoConnect::locate for this. This function takes the element name as an argument and returns a reference to an instance of AutoConnectElements.</p> <pre><code>AutoConnect portal;\n\nportal.load(FPSTR(LED_ONOFF));\nAutoConnectAux&amp; led = portal.locate(\"/led\");\nAutoConnectButton&amp; onOff = led[\"onoff\"].as&lt;AutoConnectButton&gt;();\n</code></pre> </li> <li> <p>Register the event handler with the <code>AutoConnectElement::on</code> function.</p> <pre><code>onOff.on(ledOnOff);\n</code></pre> </li> <li> <p>Write an event handler with the sketch. The event handler will be passed a reference to the instance of AutoConnectElements where the event occurred and a reference to AutoConnectAux. The event handler can use these parameters to receive the element's value of the event occurrence and perform processing according to that value. You can also give attributes such as new values and styles of other elements as return values. Use the AutoConnectElement::response function to set the return values.</p> <pre><code>// Event handler that attaches to an AutoConnectButton named `led`.\n// This event handler receives a reference to AutoConnectButton as `led`\n// and a reference to the AutoConnectAux of the page rendered in the client\n// browser.\nvoid ledOnOff(AutoConnectButton&amp; me, AutoConnectAux&amp; ledOnOff) {\nif (me.value == \"ON\") {\n// Since \"ON\" has been passed from the AutoConnectButton as `led`. Let the\n// LED turns on.\n    digitalWrite(LED_BUILTIN, HIGH);\n// Direct assignment to AutoConnectElement values is not reflected on the\n// web page; use the `response` function to update the value of the element\n// on the web page.\n    me.response(\"OFF\");\n// The `on` event handler attached to AutoConnectElements can override the\n// value and attributes of other elements placed on that AutoConnectAux page.\n// For example, a following statement changes the font color of the `caption`\n// element along with a LED blinking.\n    ledOnOff[\"caption\"].response(\"style\", \"{\\\"color\\\":\\\"red\\\"}\");\n  }\nif (me.value == \"OFF\") {\n// Since a value \"OFF\" has been passed from the AutoConnectButton as `led`.\n// Let the LED turns off.\n    digitalWrite(LED_BUILTIN, LOW);\n    me.response(\"ON\");\n    ledOnOff[\"caption\"].response(\"style\", \"{\\\"color\\\":\\\"black\\\"}\");\n  }\n}\n</code></pre> </li> </ol>"},{"location":"acinteract.html#register-event-handling-for-autoconnectelements","title":"Register Event handling for AutoConnectElements","text":"<p>The <code>on</code> function catches different events for each AutoConnectElements1. There are also types of AutoConnectElements for which event handling cannot be registered. The syntax of the <code>on</code> function is as follows:</p> <p>void AutoConnectElements::on(eventHandler)</p> <p>AutoConnectElements that can catch events and the types of events are as follows:</p> Available elements for Event Event type The moment the event occurs AutoConnectButton click Mouse click (only primary button) AutoConnectCheckbox change When an element is checked or unchecked AutoConnectInput change When the element loses focus after its value was changed AutoConnectRadio change When an element is checked (but not when unchecked) AutoConnectSelect change When the user commits the change explicitly <p>The eventHandler parameter specifies the function that handles the event.</p>"},{"location":"acinteract.html#event-handling-for-autoconnectelements","title":"Event handling for AutoConnectElements","text":""},{"location":"acinteract.html#event-handler-function","title":"Event handler function","text":"<p>void eventHandler(AutoConnectElements&amp; me, AutoConnectAux&amp; aux)</p> <p>AutoConnectElements1 is actually one of the types listed in the table above for which the event is available. A reference to the element itself and to the AutoConnectAux to which it belongs is passed to the event handler. For example, to receive an event when an AutoConnectRadio named <code>radio</code> changes its checked state by mouse clicking, declare a function like <code>onChangeRadio</code> as follows:</p> <pre><code>void onChangeRadio(AutoConnectRadio&amp; me, AutoConnectAux&amp; aux)\n</code></pre> <p>Then use the AutoConnectRadio::on function to register the onChangeRadio handler function with the <code>radio</code> instance of AutoConnectRadio.</p> <pre><code>AutoConnectRadio radio(\"radio\", {\"Huey\", \"Dewey\", \"Louie\"}, \"Select one\");\n...\nradio.on(onChangeRadio);\n</code></pre> <p>AutoConnectElements1 will handle events if an event handler is registered with the <code>on</code> function. AutoConnect automatically inserts a script containing the Fetch API in the HTML generation of your custom web page when an element with an event handler function is registered.</p> <p>A type of event source and type of event handler argument is always the same</p> <p>The first argument of the event handler will contain a reference to an instance of an actual AutoConnectElements that is source of the event. So, the type of AutoConnectElements that registers the event handler and the type passed to the event handler are always the same. For example, the type of the first argument of the handler that receives the change event of AutoConnectText is the type of AutoConnectText itself.</p>"},{"location":"acinteract.html#data-sent-with-the-event","title":"Data sent with the event","text":"<p>When the custom web page catches the event, the script inserted by AutoConnect uses the Fetch API to send the value of each AutoConnectElements on the page to the ESP module. This script sends the value of each element as form data via HTTP POST.</p> <p>The data sent in this behavior is the same as the data transmission form with page transitions with AutoConnectSubmit. Then AutoConnect will store the transmitted data in the actual instance of AutoConnectElements before control is passed to the user sketch. Details of this behavior are covered in the section Custom field data handling.</p> <p>So in your sketch, you can unconsciously access the value of each AutoConnectElements of the custom web page where the event occurred in the event handler function. A reference to the element where the event originated is passed as the first argument, and a reference to the custom web page where the event triggered as the second argument.</p>"},{"location":"acinteract.html#make-responses","title":"Make responses","text":"<p>Responses to an HTTP POST request triggered by the event will be returned by AutoConnect at the end of the event handler function. The event handler continues processing until it exits, depending on the situation. For example, the event handler that controls the LED on/off described above (i.e., <code>ledOnOff</code> function) responds to the requested HTTP POST by setting the signal level to the <code>LED_BUILTIN</code> port to conform to the sent value of the AutoConnectButton by the event. It then rewrites the button's label with the new value.</p> <p>Use the <code>response</code> function for this. The <code>response</code> function has the effect of communicating the contents of AutoConnectElements updated by the event handler to the client browser. In the actual event handler, you should call the <code>response</code> as a member function of AutoConnectElements and specifies the instance of the element that will return the response. For example, to update the value of an AutoConnectText named <code>caption</code> on a page according to the LED ON/OFF control above, the code would look like this:</p> <pre><code>...\n\nACButton(onoff, \"ON\");\nACText(caption, \"LED OFF\");\n...\n\nvoid eventHandler(AutoConnectButton&amp; me, AutoConnectAux&amp; aux) {\n\n...\n\nif (me.value == \"OFF\") {\n    digitalWrite(LED_BUILTIN, LOW);\n    me.response(\"ON\");\n    caption.response(\"LED OFF\");\n  }\nif (me.value == \"ON\") {\n    digitalWrite(LED_BUILTIN, HIGH);\n    me.response(\"OFF\");\n    caption.response(\"LED ON\");\n  }\n\n...\n\n}\n</code></pre> <p>The AutoConnectButton::response function rewrites the value attribute and innerHTML property of the <code>onoff</code> element (i.e. <code>button type=\"button id=\"onoff\"</code> node) on the page, while the AutoConnectText::response function rewrites only the innerHTML property of the <code>div</code> or <code>span</code> DOM node on the page. In this way, the value returned by response differs depending on the type of AutoConnectElements that generated the event. The following table shows which attributes of elements on the page the <code>response(const char*)</code> function affects.</p> Available AutoConnectElement::response functions Attributes to rewrite <code>AutoConnectButton::response</code> value for the HTMLButtonElementinnerHTML for the HTMLButtonElement node <code>AutoConnectCheckbox::response</code> checked for <code>&lt;input type=\"checkbox\"&gt;</code> <code>AutoConnectInput::response</code> value for the HTMLInputElement <code>AutoConnectText::response</code> innerHTML for the <code>&lt;div&gt;</code> or <code>&lt;span&gt;</code> node <p>When the <code>response</code> function updates the value of AutoConnectElements</p> <p>The <code>response</code> function also updates the value of the element's instance. For example, AutoConnectText::response function, in addition to sending the text to be updated to the client browser, also updates the value member of the sketch's AutoConnectText variable. However, that update process is done by AutoConnect at the exit of the event handler function.</p> <p>So, in the event handler function, even if you execute the response function, the value of AutoConnectElements will be kept as it was before the event occurred.</p> <p>Each AutoConnectElements has another response function that takes two arguments. The response(const char*) function updates the value of that element, while the <code>response(const char*, const char*)</code> function with two arguments updates the specified attribute or property and is used to change attributes of an element other than its value. For example, citing the LED ON/OFF example above, you can change the button background color according to the LED lighting state using the <code>response</code> function that takes two arguments.</p> <p>To change the button background color via an event handler when an event fires, specifies a String of a response form that allows direct access to the inline styles property of the button element using the CSSStyleDeclaration object.</p> <p>In this case, specify the property name of the HTML element to be changed in the first argument of the response function and the value to be changed in the second argument. This specification format conforms to object literals in JavaScript and can be expressed in JSON as follows:</p> <pre><code>{ style: { backgroundColor: 'red' }}\n</code></pre> <p>So, specify <code>style</code> as the property part of the above syntax to the first argument of the response function and the nested <code>{backGroundColor:\"red\"}</code> part to the second argument.</p> <pre><code>response(\"style\", \"{backGroundColor:\\\"red\\\"}\");\n</code></pre> <p>If the property to be changed is not a nested object property like an inline style, the second argument can be the property value as it is. For example:</p> <pre><code>response(\"placeholder\", \"Enter name\");\n</code></pre> <p>Also, even if you give a boolean value, specify it as a string in the argument to the <code>response</code> function. AutoConnect automatically converts \"true\"/\"false\" as strings to booleans. For example:</p> <pre><code>response(\"hidden\", \"true\");\n</code></pre>"},{"location":"acinteract.html#overall-the-led-control-sketch","title":"Overall the LED control sketch","text":"<p>Based on the explanation so far, the following sketch is the implementation of the custom web page shown in the opening figure.</p> <pre><code>#include &lt;Arduino.h&gt;\n#include &lt;WiFi.h&gt;\n#include &lt;WebServer.h&gt;\n#include &lt;AutoConnect.h&gt;\n\nconst char LED_ONOFF[] PROGMEM = R\"(\n{\n  \"uri\": \"/led\",\n  \"title\": \"LED\",\n  \"menu\": true,\n  \"element\": [\n    {\n      \"name\": \"caption\",\n      \"type\": \"ACText\",\n      \"value\": \"BUILT-IN LED\",\n      \"style\": \"font-weight:bold;font-size:25px;text-align:center;\",\n      \"posterior\": \"div\"\n    },\n    {\n      \"name\": \"onoff\",\n      \"type\": \"ACButton\",\n      \"value\": \"ON\"\n    }\n  ]\n}\n)\";\n\nAutoConnect portal;\nAutoConnectConfig config;\n\n// Event handler that attaches to an AutoConnectButton named `led`.\n// This event handler receives a reference to AutoConnectButton as `led`\n// and a reference to the AutoConnectAux of the page rendered in the client\n// browser.\nvoid ledOnOff(AutoConnectButton&amp; me, AutoConnectAux&amp; ledOnOff) {\nif (me.value == \"ON\") {\n\n// Since \"ON\" has been passed from the AutoConnectButton as `led`. Let the\n// LED turns on.\n    digitalWrite(LED_BUILTIN, HIGH);\n\n// Direct assignment to AutoConnectElement values is not reflected on the\n// web page; use the `response` function to update the value of the element\n// on the web page.\n    me.response(\"OFF\");\n// The `on` event handler attached to AutoConnectElements can override the\n// value and attributes of other elements placed on that AutoConnectAux page.\n// For example, a following statement changes the font color of the `caption`\n// element along with a LED blinking.\n    ledOnOff[\"caption\"].response(\"style\", \"{\\\"color\\\":\\\"red\\\", \\\"font-weight\\\":\\\"bold\\\"}\");\n  }\nif (me.value == \"OFF\") {\n// Since a value \"OFF\" has been passed from the AutoConnectButton as `led`.\n// Let the LED turns off.\n    digitalWrite(LED_BUILTIN, LOW);\n    me.response(\"ON\");\n    ledOnOff[\"caption\"].response(\"style\", \"{\\\"color\\\":\\\"black\\\", \\\"font-weight\\\":\\\"normal\\\"}\");\n  }\n}\n\nvoid setup() {\n  delay(500);\n  Serial.begin(115200);\n  Serial.println();\n\n// Built-in LED port setting up\n  pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, LOW);\n\n// Configure AutoConnect connection behavior.\n// Various configurations depending on the demands of your situation.\n  config.autoReconnect = true;\n  portal.config(config);\n\n// Load the AutoConnectAux page with the LED ON/OFF button into AutoConnect.\n// The sketch can get its instance using the AutoConnect::locate function\n// after AutoConnectAux is loaded.\n  portal.load(FPSTR(LED_ONOFF));\n  AutoConnectAux&amp; led = portal.locate(\"/led\");\n\n// The AutoConnectElement::on function allows the sketch to register an event\n// handler that interacts with the element individually.\n  AutoConnectButton&amp; onOff = led[\"onoff\"].as&lt;AutoConnectButton&gt;();\n  onOff.on(ledOnOff);\n// Start a portal\n  portal.begin();\n}\n\nvoid loop() {\n  portal.handleClient();\n}\n</code></pre> <p>Above custom web page features two major AutoConnectElements:</p> <ul> <li> <p><code>caption</code>: AutoConnectText</p> <p>Shows the current LED lighting state. The font color also reflects this status. To change the font color, use the <code>response</code> function for the <code>caption</code> element according to the value of the AutoConnectButton named <code>onoff</code> in the event handler.</p> <pre><code>ledOnOff[\"caption\"].response(\"style\", \"{\\\"color\\\":\\\"red\\\", \\\"font-weight\\\":\\\"bold\\\"}\");\n</code></pre> </li> <li> <p><code>onoff</code>: AutoConnectButton</p> <p>LED lighting switch placed on the custom web page. Interact with an event handler of the server sketch by catching click events on the browser. The event handler function name is <code>ledOnOff</code>. Register an event handler with the AutoConnectButton::on function to catch a click event on the <code>onoff</code> element as an AutoConnectButton.</p> <pre><code>AutoConnectButton&amp; onOff = led[\"onoff\"].as&lt;AutoConnectButton&gt;();\nonOff.on(ledOnOff);\n</code></pre> <p>In the event handler, you can get the current value of the <code>onoff</code> through the reference to AutoConnectButton, which is the first argument as <code>me</code>.</p> <pre><code>if (me.value == \"ON\") {\n  digitalWrite(LED_BUILTIN, HIGH);\n}\n</code></pre> <p>The label on the <code>onoff</code> button indicates the instruction to turn the LED signal. So the content will be the opposite of the LED lighting state. Use the AutoConnectButton::response function to rewrite the label.</p> <pre><code>me.response(\"OFF\");\n</code></pre> </li> </ul> <ol> <li> <p>AutoConnectElements is a generic term for elements handled by custom web pages. They are actually replaced by types such as <code>AutoConnectInput</code> or <code>AutoConnectText</code> etc.\u00a0\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"acintro.html","title":"Custom Web pages with AutoConnect","text":""},{"location":"acintro.html#what-it-is","title":"What it is","text":"<p> AutoConnect can handle custom Web pages prepared by user sketches individually. Custom Web pages can be integrated into the AutoConnect menu and executed as menu items and can have input-output parameters and handle them.</p> <p>For example, you can program some sketches that publish messages by entering the URI or unique ID of the MQTT broker on a custom page. You do not need to code the processing to handle the web page. It retrieves the input parameters and passes to the MQTT broker connection API is only.</p>"},{"location":"acintro.html#how-it-works","title":"How it works","text":"<p>AutoConnect creates the custom Web pages dynamically at runtime. Sketch describes the custom Web pages using classes and APIs necessary for dynamic creation which are AutoConnectAux and the variant of AutoConnectElements. AutoConnectAux is an object dependent on AutoConnect, which provides an easy way to incorporate custom Web pages into AutoConnect like the one on the right figure. The elements make up a custom Web page are provided as an AutoConnectElement class.</p> <p>Furthermore, an input box, a check box, a submit button, etc. are implemented by classes derived from AutoConnectElement.</p> <p></p> <p>AutoConnectAux is a container for AutoConnectElements. To make a custom Web page, create elements that make up the page and put it in the AutoConnectAux object. Joining its AutoConnectAux object to AutoConnect will integrate the custom Web page into the AutoConnect menu.</p> <p></p> <p>The above figure shows a code sequence that declares AutoConnectElements and put in the AutoConnectAux container and integrates those into AutoConnect. It declares two text elements named header and caption, adds them to the AutoConnectAux object as aux, binds to an AutoConnect object named portal. This sequence is the basic procedure for creating custom Web pages with the Sketch. The further explanation is available in section AutoConnectElements also.</p>"},{"location":"acintro.html#custom-web-pages-in-autoconnect-menu","title":"Custom Web pages in AutoConnect menu","text":"<ul> <li>     AutoConnect integrates custom Web page objects into menus as AutoConnectAux. The AutoConnectAux object contains URI and title as member variables and has an indicator to display in the AutoConnect menu.You give the title and URI of the custom Web page to the AutoConnectAux object with Sketch. Then the title of the custom Web page would be displayed in the AutoConnect menu as the left figure.1 It is a hyperlink to a custom Web page which will be displayed tapped it.</li> </ul>"},{"location":"acintro.html#multiple-custom-web-pages","title":"Multiple custom Web pages","text":"<p>You can create multiple custom Web pages and specify pages that can be called from the menu. The following sketch shows a code sequence for integrating three custom Web pages into one and embedding them in a menu.</p> <p></p> <ul> <li><p>In the above code, the third parameter of aux2 is false. The third parameter of the AutoConnectAux constructor is an indicator for whether it's shown to the AutoConnect menu. Right animation is an execution result of the above code. You will see that the menu applies only two items for three custom Web pages. the Sketch of this animation is written to transition to aux2 by the utility of the AutoConnectSubmit element owned by aux1.2The aux2 page transitions only from the aux1 page. As shown in mqttRSSI in the library example, its page replies the saving result for the parameters entered on the previous page. It can not be invoked directly from the menu and want to hide them with AutoConnect menu items. The utility of the third parameter of the AutoConnectAux constructor is that.</p></li> </ul>"},{"location":"acintro.html#basic-steps-to-use-custom-web-pages","title":"Basic steps to use custom Web pages","text":"<p>So, the basic procedure for handling of the custom Web pages is as follows:</p> <ol> <li>Create or define AutoConnectAux.</li> <li>Create or define AutoConnectElement(s).</li> <li>Add AutoConnectElement(s) to AutoConnectAux.</li> <li>Create more AutoConnectAux containing AutoConnectElement(s), if necessary.</li> <li>Register the request handlers for the custom Web pages.</li> <li>Join prepared AutoConnectAux(s) to AutoConnect.</li> <li>Invoke AutoConnect::begin().</li> <li>Perform AutoConnect::handleClient().</li> </ol>"},{"location":"acintro.html#write-the-custom-web-page-with-json","title":"Write the custom Web page with JSON","text":"<p>You can write the custom Web page in JSON without using sketch codes.3 It is possible to describe the entire page in JSON and can be described for each element also. The JSON document can be saved in SPIFFS or SD and read using AutoConnect's load function. you can reduce the steps of the basic procedure with this approach, but this way consumes a lot of memory.  The following JSON code and sketch will execute the custom Web page as an example in the above figure. That is, the Sketch of this code and footnote2 is equivalent.</p> <p>custom_page.json <pre><code>[\n  {\n\"title\": \"MQTT Setting\",\n\"uri\": \"/mqtt_setting\",\n\"menu\": true,\n\"element\": [\n      {\n\"name\": \"header\",\n\"type\": \"ACText\",\n\"value\": \"MQTT broker settings\"\n      },\n      {\n\"name\": \"caption1\",\n\"type\": \"ACText\",\n\"value\": \"Publishing the WiFi...\"\n      },\n      {\n\"name\": \"save\",\n\"type\": \"ACSubmit\",\n\"value\": \"SAVE\",\n\"uri\": \"/mqtt_save\"\n      }\n    ]\n  },\n  {\n\"title\": \"MQTT Setting\",\n\"uri\": \"/mqtt_save\",\n\"menu\": false,\n\"element\": [\n      {\n\"name\": \"caption2\",\n\"type\": \"ACText\",\n\"value\": \"Save parameters\"\n      },\n      {\n\"name\": \"start\",\n\"type\": \"ACSubmit\",\n\"value\": \"START\",\n\"uri\": \"/mqtt_start\"\n      }\n    ]\n  },\n  {\n\"title\": \"MQTT Start\",\n\"uri\": \"/mqtt_start\",\n\"menu\": true,\n\"element\": []\n  }\n]\n</code></pre></p> <p>the Sketch <pre><code>#include &lt;ESP8266WiFi.h&gt;\n#include &lt;ESP8266WebServer.h&gt;\n#include &lt;FS.h&gt;\n#include &lt;AutoConnect.h&gt;\n\nAutoConnect  portal;\n\nvoid setup() {\n  SPIFFS.begin();\n\n  File page = SPIFFS.open(\"/custom_page.json\", \"r\");\n  portal.load(page);\n  page.close();\n  SPIFFS.end();\n\n  portal.begin();\n}\n\nvoid loop() {\n  portal.handleClient();\n}\n</code></pre></p>"},{"location":"acintro.html#passing-parameters-with-sketches-and-custom-web-pages","title":"Passing parameters with sketches and custom Web pages","text":"<p>A sketch can access variables of AutoConnectElements on the custom Web page. The value entered into the AutoConnectElements is stored to the member variables of the element by AutoConnect whenever GET / POST transmission occurs. Your sketches can get these values with the request handler which will be registered by AutoConnect::on function. And if you assign a value to an element before a request to the page occurs, its value will appear as the initial value when the page is displayed. The details are explained in section Custom field data handling.</p> <ol> <li> <p>There is no overlay in the actual menu.\u00a0\u21a9</p> </li> <li> <p>the Sketch is actually this: <pre><code>#include &lt;ESP8266WiFi.h&gt;\n#include &lt;ESP8266WebServer.h&gt;\n#include &lt;AutoConnect.h&gt;\n\nAutoConnect     portal;\n\nACText(header, \"MQTT broker settings\");\nACText(caption1, \"Publishing the WiFi...\");\nACSubmit(save, \"SAVE\", \"/mqtt_save\");\nAutoConnectAux  aux1(\"/mqtt_setting\", \"MQTT Setting\", true, { header, caption1, save });\n\nACText(caption2, \"Save parameters\");\nACSubmit(start, \"START\", \"/mqtt_start\"); \nAutoConnectAux  aux2(\"/mqtt_save\", \"MQTT Setting\", false, { caption2, start });\n\nAutoConnectAux  aux3(\"/mqtt_start\", \"MQTT Start\");\n\nvoid setup() {\n  portal.join({ aux1, aux2, aux3 });\n  portal.begin();\n}\n\nvoid loop() {\n  portal.handleClient();\n}\n</code></pre> \u21a9</p> </li> <li> <p>Installation of the ArduinoJson as the latest release of version 5 series is required.\u00a0\u21a9</p> </li> </ol>"},{"location":"acjson.html","title":"Custom Web pages with JSON","text":"<p>You can embed custom Web pages written in JSON into AutoConnect without AutoConnectAux &amp; AutoConnectElements declaration. Custom Web page declaration by JSON can  embed in the Sketch as a fixed string or can store in the external file such as SPIFFS for stream loading. Also, you can also load and save AutoConnectElements objects individually.1</p> <p>By providing the following JSON document to AutoConnect, you can include the custom Web page like the below:</p> <p></p> <p>A JSON document for AutoConnect can contain the custom Web page multiple. You can further reduce the Sketch process by loading multiple pages of JSON document at once.</p> <p>Adopt ArduinoJson v5 or v6</p> <p>To handle AutoConnectAux and AutoConnectElements written in JSON, you need to install the ArduinoJson library. You can adopt either version 5 or version 6 for the ArduinoJson. AutoConnect supports both versions.</p>"},{"location":"acjson.html#json-objects-elements-for-the-custom-web-page","title":"JSON objects &amp; elements for the custom Web page","text":""},{"location":"acjson.html#json-document-structure-for-autoconnectaux","title":"JSON document structure for AutoConnectAux","text":"<p>AutoConnectAux will configure custom Web pages with JSON objects. The elements that make up the object are as follows:</p> <pre><code>{\n\"title\" : title,\n\"uri\" : uri,\n\"menu\" : true | false,\n\"response\" : true | false,\n\"auth\": authentication,\n\"element\" : element_array\n}\n</code></pre>"},{"location":"acjson.html#title","title":"title","text":"A title of the custom Web page. This is string value and specifies the title will be displayed in the AutoConnection menu."},{"location":"acjson.html#uri","title":"uri","text":"String of URI path that specifies where to place the custom Web page. It needs to be a location from the root path including '/'."},{"location":"acjson.html#menu","title":"menu","text":"This is a Boolean value indicating whether to include the custom Web page in the AutoConnect menu. If the page only responds to another page and you want to prevent the direct use from the menu, you can exclude from the AutoConnect menu. If this key is false, it will not appear in the menu."},{"location":"acjson.html#response","title":"response","text":"This is a Boolean value indicating whether to respond to HTTP responses independently in its custom web page handler. Normally, AutoConnect will respond with a response code of 200 after its custom web page has processed the request from the client. However, depending on the processing status of the handler, it may be necessary to return a response other than 200. For example, it might respond with a 302 redirect. In such situations, the custom web page handler can apply the sendHeader, sendContent, and send functions of the WebServer library to respond with its own response. If the <code>response</code> is <code>false</code>, AutoConnect will not respond with an HTTP response when it returns from the custom web page handler. The custom web page handler needs to perform the HTTP response by itself."},{"location":"acjson.html#auth","title":"auth","text":"It allows that this page requires authentication. An authentication specifies the following string that represents the authentication scheme. <ul> <li>NONE: No authentication. This is default.</li> </ul> <ul> <li>BASIC: Apply Basic scheme.</li> </ul> <ul> <li>DIGEST: Apply Digest scheme.</li> </ul>"},{"location":"acjson.html#element","title":"element","text":"Describe an array of JSON objects as element_array. It is a JSON object array of the AutoConnectElements that make up the custom Web page. <p>Order of elements on a custom Web page</p> <p>The order in which AutoConnectElements are placed on a custom Web page is the order in the JSON document.</p>"},{"location":"acjson.html#multiple-custom-web-pages-declaration-in-json-document","title":"Multiple custom Web pages declaration in JSON document","text":"<p>You can put declarations of multiple custom Web pages in one JSON document. In that case, declare an array of each custom Web page with JSON. The following JSON document contains three custom Web pages:</p> <pre><code>[\n  {\n\"title\" : \"Page 1 title\",\n\"uri\" : \"/page1\",\n\"menu\" : true,\n\"element\" : [\n      {\n\"name\" : \"caption\",\n\"type\" : \"ACText\",\n\"value\" : \"hello, world\"\n      },\n      {\n\"name\" : \"send\",\n\"type\" : \"ACSubmit\",\n\"uri\" : \"/page2\"\n      }\n    ]\n  },\n  {\n\"title\" : \"Page 1 title\",\n\"uri\" : \"/page2\",\n\"menu\" : false,\n\"element\" : [\n      {\n\"name\" : \"responds\",\n\"type\" : \"ACText\",\n\"value\" : \"Good day\"\n      },\n      {\n\"name\" : \"send\",\n\"type\" : \"ACSubmit\",\n\"uri\" : \"/page3\"\n      }\n    ]\n  },\n  {\n\"title\" : \"Page 3 title\",\n\"uri\" : \"/page3\",\n\"menu\" : true,\n\"element\" : [\n      {\n\"name\" : \"responds\",\n\"type\" : \"ACText\",\n\"value\" : \"bye\"\n      }\n    ]\n  }\n]\n</code></pre> <p>The above custom Web page definitions can be loaded in a batch using the AutoConnect::load function.</p>"},{"location":"acjson.html#json-object-for-autoconnectelements","title":"JSON object for AutoConnectElements","text":"<p>JSON description for AutoConnectElements describes as an array in the element with arguments of each constructor.</p> <pre><code>{\n\"name\" : name,\n\"type\" : type,\n\"posterior\" : posterior,\nkey_according_to_type : the_value | array_of_value,\n  [ key_according_to_type : the_value | array_of_value ]\n}\n</code></pre>"},{"location":"acjson.html#name","title":"name","text":"A string of the name for the element."},{"location":"acjson.html#type","title":"type","text":"A string of the type for the element. For this type, specify the following string corresponding to each element. <ul> <li>AutoConnectButton: ACButton</li> </ul> <ul> <li>AutoConnectCheckbox: ACCheckbox </li> </ul> <ul> <li>AutoConnectElement: ACElement</li> </ul> <ul> <li>AutoConnectFile: ACFile</li> </ul> <ul> <li>AutoConnectInput: ACInput</li> </ul> <ul> <li>AutoConnectRadio: ACRadio</li> </ul> <ul> <li>AutoConnectRange: ACRange</li> </ul> <ul> <li>AutoConnectSelect: ACSelect</li> </ul> <ul> <li>AutoConnectStyle: ACStyle</li> </ul> <ul> <li>AutoConnectSubmit: ACSubmit</li> </ul> <ul> <li>AutoConnectText: ACText</li> </ul>"},{"location":"acjson.html#posterior","title":"posterior","text":"Specifies a tag to add behind the HTML code generated from the element. Its purpose is to place elements on the custom Web page as intended by the user sketch. You can use the posterior key with the following values to arrange vertically or horizontal when the elements do not have the intended position on the custom Web Page specifying the following: <ul> <li>none : No generate additional tags.</li> </ul> <ul> <li>br : Add a <code>&lt;br&gt;</code> tag to the end of the element.</li> </ul> <ul> <li>par : Include the element in the <code>&lt;p&gt; ~ &lt;/p&gt;</code> tag.</li> </ul> <ul> <li>div : Include the element in the <code>&lt;div&gt; ~ &lt;/div&gt;</code> tag.</li> </ul>"},{"location":"acjson.html#key_according_to_type","title":"key_according_to_type","text":"<p>This is different for each AutoConnectElements, and the key that can be specified by the type of AutoConnectElements is determined.</p>"},{"location":"acjson.html#acbutton","title":"ACButton","text":"<ul> <li>value : Specifies the button label. This value also applies to the <code>value</code> attribute of an HTML <code>button</code> tag.</li> </ul> <ul> <li>action : Specifies an action to be fire on a mouse click on the button. It is mostly used with a JavaScript to activate a script, or it directly describes a JavaScript.</li> </ul>"},{"location":"acjson.html#accheckbox","title":"ACCheckbox","text":"<ul> <li>value : Specifies the value to be supplied to the checkbox. It will be packed in the query string as <code>name=value</code> when the checkbox is ticked.</li> </ul> <ul> <li>label : Specifies a label of the checkbox. Its placement is always to the right of the checkbox.</li> </ul> <ul> <li>checked : Specifies checking status as a boolean value. The value of the checked checkbox element is packed in the query string and sent.</li> </ul>"},{"location":"acjson.html#acelement","title":"ACElement","text":"<ul> <li>value : Specifies the source code of generating HTML. The value is native HTML code and is output as HTML as it is.</li> </ul>"},{"location":"acjson.html#acfile","title":"ACFile","text":"<ul> <li>value : The file name of the upload file will be stored. The <code>value</code> is read-only and will be ignored if specified.</li> </ul> <ul> <li>label : Specifies a label of the file selection box. Its placement is always to the left of the file selection box.</li> </ul> <ul> <li> store : Specifies the destination to save the uploaded file. Its value accepts one of the following: <ul> <li>fs : Save as the SPIFFS file in flash of ESP8266/ESP32 module. If the valid file system of the ESP8266 module incorporating the Sketch is LittleFS, AutoConnect assumes the file system to be LittleFS. However, it does not sense the actual file system, so If the Sketch implementation does not match the file system on the ESP8266 depends, a file writing error will occur.</li> </ul> <ul> <li>sd : Save to an external SD device connected to ESP8266/ESP32 module.</li> </ul> <ul> <li>extern : Pass the content of the uploaded file to the uploader which is declared by the Sketch individually. Its uploader must inherit AutoConnectUploadHandler class and implements _open, _write and _close function.</li> </ul> </li> </ul> <p>A valid filesystem of ESP8266 on board flash</p> <p>AutoConnect has assumed LittleFS as a valid file system since v1.2.0 enhancement. On the other hand, the ESP8266 arduino core has supported LittleFS officially since a release 2.7.0. LittleFS support in AutoConnect relies on the FS instance declared by the arduino core used at compile-time per project, and its FS instance will acquire by either the SPIFFS class or the LittleFS class. That is, you need to choose which file system will be available in the actual Sketch and make consistent it with AutoConnect assumed file system. So, you can choose which one uses the file systems per project via adjustment the AC_USE_SPIFFS macro enable or disable. AutoConnect determines the available file system by the AC_USE_SPIFFS macro which defined in AutoConnectDefs.h header file. </p>"},{"location":"acjson.html#acinput","title":"ACInput","text":"<ul> <li>value : Specifies the initial text string of the input box. If this value is omitted, placeholder is displayed as the initial string.</li> </ul> <ul> <li>label : Specifies a label of the input box. Its placement is always to the left of the input box.</li> </ul> <ul> <li>placeholder : Specifies short hint of the input box.</li> </ul> <ul> <li> apply : Specifies the type of input that the text box accepts. Its value accepts one of the following: <ul> <li>text : A text.</li> </ul> <ul> <li>password : Password input field. The text is obscured so that it cannot be read, usually by replacing each character with a symbol such as the asterisk (\"<code>*</code>\") or a dot (\"<code>\u2022</code>\").</li> </ul> <ul> <li>number : A field let the user enter number characters only.</li> </ul> </li> </ul> <p>Numerical keypad is different</p> <p>When the AutoConnectInput element with the <code>number</code> applied is focused on the browser, the numeric keypad may be displayed automatically. For popular mobile OSes such as Android and iOS, the numeric keypad has the following styles and is different with each OS. </p>"},{"location":"acjson.html#acradio","title":"ACRadio","text":"<ul> <li>value : Specifies the collection of radio buttons as an array element.</li> </ul> <ul> <li>label : Specifies a label of the collection of radio buttons, not for each button. The arrangement will be the top or left side according to the <code>arrange</code>.</li> </ul> <ul> <li> arrange : Specifies the orientation of the radio buttons. Its value accepts one of the following: <ul> <li>horizontal : Horizontal arrangement.</li> </ul> <ul> <li>vertical : Vertical arrangement.</li> </ul> </li> </ul> <ul> <li>checked : Specifies the index number (1-based) of the radio buttons collection to be checked.</li> </ul>"},{"location":"acjson.html#acrange","title":"ACRange","text":"<ul> <li>value : Specifies the initial value in the range. If the <code>value</code> is not specified, the default value is determined by the following algorithm:<code>value = (max &lt; min) ? min : min + (max - min)/2;</code></li> </ul> <ul> <li>label : Specifies a label of the range slider. Its placement is always to the left of the input box.</li> </ul> <ul> <li>min : Specifies the most negative value within the range of allowed values and must not be less than the <code>value</code>.</li> </ul> <ul> <li>max : Specifies the greatest value in the range of permitted values.</li> </ul> <ul> <li>step : Specifies the granularity that the value must adhere to. The default is 1. As you move the slider, it increases or decreases the <code>value</code> according to the <code>step</code> in granularity.</li> </ul> <ul> <li> magnify : Displays the current value of the range on the left or right side of the slider. The <code>magnify</code> accepts one of the following: <ul> <li>infront : Displays the current value on the left side.</li> </ul> <ul> <li>behind : Displays the current value on the right side.</li> </ul> <ul> <li>void :  No display the current value. This is the default.</li> </ul> </li> </ul> <ul> <li>style : Specifies the qualification style to give to the content and can use the style attribute format as it is.</li> </ul>"},{"location":"acjson.html#acselect","title":"ACSelect","text":"<ul> <li>label : Specifies a label of the drop-down list. Its placement is always to the left of the drop-down list.</li> </ul> <ul> <li>option : Specifies the initial value collection of the drop-down list as an array element.</li> </ul>"},{"location":"acjson.html#acstyle","title":"ACStyle","text":"<ul> <li>value : Specifies the custom CSS code.</li> </ul>"},{"location":"acjson.html#acsubmit","title":"ACSubmit","text":"<ul> <li>value : Specifies a label of the submit button.</li> </ul> <ul> <li>uri : Specifies the URI to send form data when the button is clicked.</li> </ul>"},{"location":"acjson.html#actext","title":"ACText","text":"<ul> <li>value : Specifies a content and also can contain the native HTML code, but remember that your written code is enclosed by the div tag.</li> </ul> <ul> <li>style : Specifies the qualification style to give to the content and can use the style attribute format as it is.</li> </ul> <ul> <li>format : Specifies how to interpret the value. It specifies the conversion format when outputting values. The format string conforms to the C-style printf library functions, but depends on the espressif SDK implementation. The conversion specification is valid only for %s format. (Left and Right justification, width are also valid.)</li> </ul> <p>AutoConnect JSON parsing process is not perfect</p> <p>It is based on analysis by ArduinoJson, but the semantic analysis is simplified to save memory. Consequently, it is not an error that a custom Web page JSON document to have unnecessary keys. It will be ignored.</p>"},{"location":"acjson.html#loading-json-document","title":"Loading JSON document","text":""},{"location":"acjson.html#loading-to-autoconnect","title":"Loading to AutoConnect","text":"<p>There are two main ways to load the custom Web pages into AutoConnect.</p> <ol> <li> <p>Load directly into AutoConnect</p> <p>This way does not require an explicit declaration of AutoConnectAux objects with sketches and is also useful when importing the custom Web pages JSON document from an external file such as SPIFFS because the page definition and sketch coding structure can be separated.</p> <p>Using the AutoCoonnect::load function, AutoConnect dynamically generates the necessary AutoConnectAux objects internally based on the custom Web page definition of the imported JSON document content. In the Sketch, the generated AutoConnectAux object can be referenced using the AutoConnect::aux function. You can reach the AutoConnectElements you desired using the AutoConnectAux::getElement function of its AutoConnectAux.</p> <p>In the following example, it loads in a batch a JSON document of custom Web pages stored in SPIFFS and accesses to the AutoConnectInput element.</p> <pre><code>[\n  {\n\"title\": \"page1\",\n\"uri\": \"/page1\",\n\"menu\": true,\n\"element\": [\n      {\n\"name\": \"input1\",\n\"type\": \"ACInput\"\n      }\n    ]\n  },\n  {\n\"title\": \"page2\",\n\"uri\": \"/page2\",\n\"menu\": true,\n\"element\": [\n      {\n\"name\": \"input2\",\n\"type\": \"ACInput\"\n      }\n    ]\n  }\n]\n</code></pre> <pre><code>AutoConnect portal;\nFile page = SPIFFS.open(\"/custom_page.json\", \"r\");\nportal.load(page);\npage.close();\nAutoConnectAux* aux = portal.aux(\"/page1\");\nAutoConnectInput&amp; input1 = aux-&gt;getElement&lt;AutoConnectInput&gt;(\"input1\");\n</code></pre> </li> <li> <p>Load to AutoConnectAux and join to AutoConnect</p> <p>This way declares AutoConnectAux in the Sketch and loads the custom Web pages JSON document there. It has an advantage for if you want to define each page of a custom Web page individually or allocate AutoConnectAux objects dynamically on the Sketch side.</p> <p>After loading a JSON document using the AutoConnectAux::load function by each, integrate those into AutoConnect using the AutoConnect::join function.</p> <p>In the following example, you can see the difference between two sketches in a sketch modified using the AutoConnectAux::load.</p> <p><pre><code>{\n\"title\": \"page1\",\n\"uri\": \"/page1\",\n\"menu\": true,\n\"element\": [\n    {\n\"name\": \"input1\",\n\"type\": \"ACInput\"\n    }\n  ]\n}\n</code></pre> <pre><code>{\n\"title\": \"page2\",\n\"uri\": \"/page2\",\n\"menu\": true,\n\"element\": [\n    {\n\"name\": \"input2\",\n\"type\": \"ACInput\"\n    }\n  ]\n}\n</code></pre> <pre><code>AutoConnect portal;\nAutoConnectAux page1;\nAutoConnectAux page2;\nFile page = SPIFFS.open(\"/custom_page1.json\", \"r\");\npage1.load(page);\npage.close();\npage = SPIFFS.open(\"/custom_page2.json\", \"r\");\npage2.load(page);\npage.close();\nportal.join( { page1, page2 } );\nAutoConnectInput&amp; input1 = page1.getElement&lt;AutoConnectInput&gt;(\"input1\");\n</code></pre></p> </li> </ol>"},{"location":"acjson.html#loading-from-the-streamed-file","title":"Loading from the streamed file","text":"<p>AutoConnect supports loading of JSON document from the following instances:</p> <ul> <li>String</li> <li>PROGMEM</li> <li>Stream</li> </ul> <p>To load custom Web pages JSON document into AutoConnect, use the load function of the AutoConnect class. Its JSON document can read must be completed as a description interpretable by the ArduinoJson library. It cannot import custom Web pages if there are syntax errors for the JSON. If you can not see the custom Web page prepared by JSON, you can check the syntax with ArduinoJson Assistant. It is useful for pre-checking.</p> <p><pre><code>bool AutoConnect::load(const String&amp; aux)\n</code></pre> <pre><code>bool AutoConnect::load(const __FlashStringHelper* aux)\n</code></pre> <pre><code>bool AutoConnect::load(Stream&amp; aux)\n</code></pre> An example of using each function is as follows. <pre><code>AutoConnect  portal;\n\n// Loading from String\nconst String aux = String(\"{\\\"title\\\":\\\"Page 1 title\\\",\\\"uri\\\":\\\"/page1\\\",\\\"menu\\\":true,\\\"element\\\":[{\\\"name\\\":\\\"caption\\\",\\\"type\\\":\\\"ACText\\\",\\\"value\\\":\\\"hello, world\\\"}]}\");\nportal.load(aux);\n\n// Loading from PROGMEM\nconst char aux[] PROGMEM = R\"raw(\n{\n  \"title\" : \"Page 1 title\",\n  \"uri\" : \"/page1\",\n  \"menu\" : true,\n  \"element\" : [\n    {\n      \"name\" : \"caption\",\n      \"type\" : \"ACText\",\n      \"value\" : \"hello, world\"\n    }\n  ]\n}\n)raw\";\nportal.load(FPSTR(aux));\n\n// Loading from Stream assumes \"aux.json\" file should be store in SPIFFS.\nFile aux = SPIFFS.open(\"aux.json\", \"r\");\nportal.load(aux);\naux.close();\n</code></pre></p> <p>AutoConnect passes the given JSON document directly to the parseObject() function of the ArduinoJson library for parsing. Therefore, the constraint of the parseObject() function is applied as it is in the parsing of the JSON document for the AutoConnect. That is, if the JSON string is read-only, duplicating the input string occurs and consumes more memory.</p>"},{"location":"acjson.html#adjust-the-json-document-buffer-size","title":"Adjust the JSON document buffer size","text":"<p>AutoConnect uses ArduinoJson library's dynamic buffer to parse JSON documents. Its dynamic buffer allocation scheme depends on the version 5 or version 6 of ArduinoJson library. Either version must have enough buffer to parse the custom web page's JSON document successfully. AutoConnect has the following three constants internally to complete the parsing as much as possible in both ArduinoJson version. These constants are macro defined in AutoConnectDefs.h.</p> <p>If memory insufficiency occurs during JSON document parsing, you can adjust these constants to avoid insufficiency by using the JsonAssistant with deriving the required buffer size in advance.</p> <pre><code>#define AUTOCONNECT_JSONBUFFER_SIZE     256\n#define AUTOCONNECT_JSONDOCUMENT_SIZE   (8 * 1024)\n#define AUTOCONNECT_JSONPSRAM_SIZE      (16* 1024)\n</code></pre>"},{"location":"acjson.html#autoconnect_jsonbuffer_size","title":"AUTOCONNECT_JSONBUFFER_SIZE","text":"<p>This is a unit size constant of DynamicJsonBuffer and works when the library used is ArduinoJson version 5. A buffer size of the JSON document increases with this unit. This value relates to the impact of the fragmented heap area. If it is too large, may occur run-out of memory.</p>"},{"location":"acjson.html#autoconnect_jsondocument_size","title":"AUTOCONNECT_JSONDOCUMENT_SIZE","text":"<p>This is a size of DynamicJsonDocument for ArduinoJson version 6. This buffer is not automatically expanding, and the size determines the limit.</p>"},{"location":"acjson.html#autoconnect_jsonpsram_size","title":"AUTOCONNECT_JSONPSRAM_SIZE","text":"<p>For ESP32 module equips with PSRAM, you can allocate the JSON document buffer to PSRAM. Buffer allocation to PSRAM will enable when PSRAM:Enabled option selected in the Arduino IDE's Board Manager menu. It is available since ArduinoJson 6.10.0.</p>"},{"location":"acjson.html#saving-json-document","title":"Saving JSON document","text":"<p>the Sketch can persist AutoConnectElements as a JSON document and also uses this function to save the values entered on the custom Web page. And you can reload the saved JSON document into AutoConnectElements as the field in a custom Web page using the load function. </p> <ol> <li> <p>Loading and saving AutoConnect parameters adopt this method.\u00a0\u21a9</p> </li> </ol>"},{"location":"acupload.html","title":"File upload handler","text":""},{"location":"acupload.html#uploading-file-from-web-browser","title":"Uploading file from Web Browser","text":"<p>If you have to write some data individually to the ESP8266/ESP32 module for the Sketch behavior, the AutoConnectFile element will assist with your wants implementation. The AutoConnectFile element produces an HTML <code>&lt;input type=\"file\"&gt;</code> tag and can save uploaded file to the flash or external SD of the ESP8266/ESP32 module. The handler for saving is built into AutoConnect. You can use it to inject any sketch data such as the initial values for the custom Web page into the ESP module via OTA without using the Sketch data upload tool of Arduino-IDE.</p> <p></p>"},{"location":"acupload.html#basic-steps-of-the-file-upload-sketch","title":"Basic steps of the file upload sketch","text":"<p>Here is the basic procedure of the Sketch which can upload files from the client browser using AutoConnectFile:1</p> <ol> <li>Place AutoConnectFile on a custom Web page by writing JSON or constructor code directly with the Sketch.</li> <li>Place other AutoConnectElements as needed.</li> <li>Place AutoConnectSubmit on the same custom Web page.</li> <li>Perform the following process in the on-handler of submitting destination:<ul> <li>Retrieve the AutoConnectFile instance from the custom Web page where you placed the AutoConnectFile element using the AutoConnectAux::getElement function or the operator [].</li> <li>Start access to the device specified as the upload destination. In usually, it depends on the file system's begin function. For example, if you specified Flash's SPIFFS as the upload destination, invokes SPIFFS.begin().</li> <li>The value member of AutoConnectFile contains the file name of the upload file. Use its file name to access the uploaded file on the device.</li> <li>Invokes the end function associated with the begin to close the device. It is the SPIFFS.end()* if the flash on the ESP module has been begun for SPIFFS.</li> </ul> </li> </ol> <p>The following sketch is an example that implements the above basic steps. The postUpload function is the on-handler and retrieves the AutoConnectFile as named <code>upload_file</code>. You should note that this handler is not for a custom Web page placed with its AutoConnectFile element. The uploaded file should be processed by the handler for the transition destination page from the AutoConnectFile element placed page. AutoConnect built-in upload handler will save the uploaded file to the specified device before invoking the postUpload function.</p> <p>However, If you use uploaded files in different situations, it may be more appropriate to place the actual handling process outside the handler. It applies for the parameter file, etc. The important thing is that you do not have to sketch file reception and storing logic by using the AutoConnectFile element and the upload handler built into the AutoConnect.</p> <pre><code>#include &lt;ESP8266WiFi.h&gt;\n#include &lt;ESP8266WebServer.h&gt;\n#include &lt;FS.h&gt;\n#include &lt;AutoConnect.h&gt;\n\n// Upload request custom Web page\nstatic const char PAGE_UPLOAD[] PROGMEM = R\"(\n{\n  \"uri\": \"/\",\n  \"title\": \"Upload\",\n  \"menu\": true,\n  \"element\": [\n    { \"name\":\"caption\", \"type\":\"ACText\", \"value\":\"&lt;h2&gt;File uploading platform&lt;h2&gt;\" },\n    { \"name\":\"upload_file\", \"type\":\"ACFile\", \"label\":\"Select file: \", \"store\":\"fs\" },\n    { \"name\":\"upload\", \"type\":\"ACSubmit\", \"value\":\"UPLOAD\", \"uri\":\"/upload\" }\n  ]\n}\n)\";\n\n// Upload result display\nstatic const char PAGE_BROWSE[] PROGMEM = R\"(\n{\n  \"uri\": \"/upload\",\n  \"title\": \"Upload\",\n  \"menu\": false,\n  \"element\": [\n    { \"name\":\"caption\", \"type\":\"ACText\", \"value\":\"&lt;h2&gt;Uploading ended&lt;h2&gt;\" },\n    { \"name\":\"filename\", \"type\":\"ACText\" },\n    { \"name\":\"size\", \"type\":\"ACText\", \"format\":\"%s bytes uploaded\" },\n    { \"name\":\"content_type\", \"type\":\"ACText\", \"format\":\"Content: %s\" }\n  ]\n}\n)\";\n\nESP8266WebServer server;\nAutoConnect portal(server);\n// Declare AutoConnectAux separately as a custom web page to access\n// easily for each page in the post-upload handler.\nAutoConnectAux auxUpload;\nAutoConnectAux auxBrowse;\n\n/**\n * Post uploading, AutoConnectFile's built-in upload handler reads the\n * file saved in SPIFFS and displays the file contents on /upload custom\n * web page. However, only files with mime type uploaded as text are\n * displayed. A custom web page handler is called after upload.\n * @param  aux  AutoConnectAux(/upload)\n * @param  args PageArgument\n * @return Uploaded text content\n */\nString postUpload(AutoConnectAux&amp; aux, PageArgument&amp; args) {\n  String  content;\n  AutoConnectFile&amp;  upload = auxUpload[\"upload_file\"].as&lt;AutoConnectFile&gt;();\n  AutoConnectText&amp;  aux_filename = aux[\"filename\"].as&lt;AutoConnectText&gt;();\n  AutoConnectText&amp;  aux_size = aux[\"size\"].as&lt;AutoConnectText&gt;();\n  AutoConnectText&amp;  aux_contentType = aux[\"content_type\"].as&lt;AutoConnectText&gt;();\n// Assignment operator can be used for the element attribute.\n  aux_filename.value = upload.value;\n  aux_size.value = String(upload.size);\n  aux_contentType.value = upload.mimeType;\n// The file saved by the AutoConnect upload handler is read from\n// the EEPROM and echoed to a custom web page.\n  SPIFFS.begin();\n  File uploadFile = SPIFFS.open(String(\"/\" + upload.value).c_str(), \"r\");\nif (uploadFile) {\nwhile (uploadFile.available()) {\nchar c = uploadFile.read();\n      Serial.print(c);\n    }\n    uploadFile.close();\n  }\nelse\n    content = \"Not saved\";\n  SPIFFS.end();\nreturn String();\n}\n\nvoid setup() {\n  delay(1000);\n  Serial.begin(115200);\n  Serial.println();\n\n  auxUpload.load(PAGE_UPLOAD);\n  auxBrowse.load(PAGE_BROWSE);\n  portal.join({ auxUpload, auxBrowse });\n  auxBrowse.on(postUpload);\n  portal.begin();\n}\n\nvoid loop() {\n  portal.handleClient();\n}\n</code></pre>"},{"location":"acupload.html#where-will-the-file-upload","title":"Where will the file upload","text":"<p>The AutoConnect built-in upload handler can save the upload file to three locations:</p> <ol> <li>Flash memory embedded in the ESP8266/ESP32 module</li> <li>SD device externally connected to the ESP8266/ESP32 module</li> <li>Other character devices</li> </ol> <p>You can specify the device type to save with the store attribute of AutoConnectFile, and it accepts the following values:</p> <ul> <li>Flash : <code>AC_File_FS</code> for the API parameter or <code>fs</code> for the JSON document</li> <li>SD : <code>AC_File_SD</code> for the API parameter or <code>sd</code> for the JSON document</li> <li>Other : <code>AC_File_Extern</code> for the API parameter or <code>extern</code> for the JSON document</li> </ul> <p>The substance of AC_File_FS (fs) is a SPIFFS file system implemented by the ESP8266/ESP32 core, and then AutoConnect uses the Global Instance SPIFFS to access SPIFFS.</p> <p>Also, the substance of AC_File_SD (sd) is a FAT file of Arduino SD library ported to the ESP8266/ESP32 core, and then AutoConnect uses the Global Instance SD to access SD. When saving to an external SD device, there are additional required parameters for the connection interface and is defined as the macro in AutoConnectDefs.h.</p> <pre><code>#define AUTOCONNECT_SD_CS       SS\n#define AUTOCONNECT_SD_SPEED    4000000\n</code></pre> <p><code>AUTOCONNECT_SD_CS</code> defines which GPIO for the CS (Chip Select, or SS as Slave Select) pin. This definition is derived from pins_arduino.h, which is included in the Arduino core distribution. If you want to assign the CS pin to another GPIO, you need to change the macro definition of AutoConnectDefs.h.</p> <p><code>AUTOCONNECT_SD_SPEED</code> defines SPI clock speed depending on the connected device.</p> <p>Involves both the begin() and the end()</p> <p>The built-in uploader executes the begin and end functions regardless of the Sketch whence the file system of the device will terminate with the uploader termination. Therefore, to use the device in the Sketch after uploading, you need to restart it with the begin function.</p>"},{"location":"acupload.html#when-it-will-be-uploaded","title":"When it will be uploaded","text":"<p>Upload handler will be launched by ESP8266WebServer/WebServer(as ESP32) library which is triggered by receiving an HTTP stream of POST BODY including file content. Its launching occurs before invoking the page handler.</p> <p>The following diagram illustrates the file uploading sequence:</p> <p></p> <p>At the time of the page handler behaves, the uploaded file already saved to the device, and the member variables of AutoConnectFile reflects the file name and transfer size.</p>"},{"location":"acupload.html#the-file-name-for-the-uploaded-file","title":"The file name for the uploaded file","text":"<p>AutoConnetFile saves the uploaded file with the file name you selected by <code>&lt;input type=\"file\"&gt;</code> tag on the browser. The file name used for uploading is stored in the AutoConnetFile's value member, which you can access after uploading. (i.e. In the handler of the destination page by the AutoConnectSubmit element.) You can not save it with a different name. It can be renamed after upload if you need to change the name.</p>"},{"location":"acupload.html#upload-to-a-device-other-than-flash-or-sd","title":"Upload to a device other than Flash or SD","text":"<p>You can output the file to any device using a custom uploader by specifying extern with the store attribute of AutoConnectFile (or specifying AC_File_Extern for the store member variable) and can customize the uploader according to the need to upload files to other than Flash or SD. Implements your own uploader with inheriting the AutoConnectUploadHandler class which is the base class of the upload handler.</p> <p>It's not so difficult</p> <p>Implementing the custom uploader requires a little knowledge of the c++ language. If you are less attuned to programming c++, you may find it difficult. But don't worry. You can make it in various situations by just modifying the Sketch skeleton that appears at the end of this page.</p>"},{"location":"acupload.html#upload-handler-base-class","title":"Upload handler base class","text":"<p>AutoConnectUploadHandler is a base class of upload handler and It has one public member function and three protected functions. </p>"},{"location":"acupload.html#constructor","title":"Constructor","text":"<pre><code>AutoConnectUploadHandler()\n</code></pre>"},{"location":"acupload.html#member-functions","title":"Member functions","text":"<p>The upload public function is an entry point, the ESP8266WebServer (WebServer as ESP32) library will invoke the upload with each time of uploading content divided into chunks. </p> <p>Also, the _open, _write and _close protected functions are actually responsible for saving files and are declared as pure virtual functions. A custom uploader class that inherits from the AutoConnectUploadHandler class need to implement these functions.</p> <p>The actual upload process is handled by the three private functions above, and then upload only invokes three functions according to the upload situation. In usually, there is no need to override the upload function in an inherited class.</p> <pre><code>public virtual void upload(const String&amp; requestUri, const HTTPUpload&amp; upload)\n</code></pre> Parameters requestUriURI of upload request source. uploadA data structure of the upload file as HTTPUpload. It is defined in the ESP8266WebServer (WebServer as ESP32) library as follows:  <pre><code>typedef struct {\n  HTTPUploadStatus status;\n  String  filename;\n  String  name;\n  String  type;\nsize_t  totalSize;\nsize_t  currentSize;\nsize_t  contentLength;\nuint8_t buf[HTTP_UPLOAD_BUFLEN];\n} HTTPUpload;\n</code></pre> <p>An upload handler needs to implement a procedure corresponding with HTTPUploadStatus enum value indicated by the uploading process of ESP8266WebServer class, which contained in HTTPUpload.status as following values:</p> <ul> <li><code>UPLOAD_FILE_START</code> : Invokes to the _open.</li> <li><code>UPLOAD_FILE_WRITE</code> : Invokes to the _write.</li> <li><code>UPLOAD_FILE_END</code> : Invokes to the _close.</li> <li><code>UPLOAD_FILE_ABORTED</code> : Invokes to the _close.</li> </ul> <p>The _open function will be invoked when HTTPUploadStatus is UPLOAD_FILE_START. Usually, the implementation of an inherited class will open the file.</p> <pre><code>protected virtual bool _open(const char* filename, const char* mode) = 0\n</code></pre> Parameters filenameUploading file name. modeAn indicator for the file access mode, a \"w\" for writing. Return value trueFile open successful. falseFailed to open. <p>The _write function will be invoked when HTTPUploadStatus is UPLOAD_FILE_WRITE. The content of the upload file is divided and the _write will be invoked in multiple times. Usually, the implementation of an inherited class will write data.</p> <pre><code>protected virtual size_t _write(const uint8_t *buf, const size_t size) = 0\n</code></pre> Parameters bufFile content block. sizeFile block size to write. Return value Size written. <p>The _close function will be invoked when HTTPUploadStatus is UPLOAD_FILE_END or UPLOAD_FILE_ABORTED. Usually, the implementation of an inherited class will close the file.</p> <pre><code>protected virtual void _close(void) = 0\n</code></pre> <p>For reference, the following AutoConnectUploadFS class is an implementation of AutoConnect built-in uploader and inherits from AutoConnectUploadHandler.</p> <pre><code>class AutoConnectUploadFS : public AutoConnectUploadHandler {\npublic:\nexplicit AutoConnectUploadFS(SPIFFST&amp; media) : _media(&amp;media) {}\n~AutoConnectUploadFS() { _close(); }\n\nprotected:\nbool _open(const char* filename, const char* mode) override {\nif (_media-&gt;begin()) {\n      _file = _media-&gt;open(filename, mode);\nreturn _file != false;      \n    }\nreturn false;\n  }\n\nsize_t _write(const uint8_t* buf, const size_t size) override {\nif (_file)\nreturn _file.write(buf, size);\nelse\nreturn -1;\n  }\n\nvoid _close(void) override {\nif (_file)\n      _file.close();\n    _media-&gt;end();\n  }\n\nprivate:\n  SPIFFST*  _media;\n  SPIFileT  _file; \n};\n</code></pre>"},{"location":"acupload.html#register-custom-upload-handler","title":"Register custom upload handler","text":"<p>In order to upload a file by the custom uploader, it is necessary to register it to the custom Web page beforehand. To register a custom uploader, specify the custom uploader class name in the template argument of the  AutoConnectAux::onUpload function and invokes it.</p> <pre><code>void AutoConnectAux::onUpload&lt;T&gt;(T&amp; uploadClass)\n</code></pre> Parameters TSpecifies a class name of the custom uploader. This class name is a class that you implemented by inheriting AutoConnectUploadHandler for custom upload. uploadClassSpecifies the custom upload class instance. <p>The rough structure of the Sketches that completed these implementations will be as follows:</p> <pre><code>#include &lt;ESP8266WiFi.h&gt;\n#include &lt;ESP8266WebServer.h&gt;\n#include &lt;AutoConnect.h&gt;\n\nstatic const char PAGE_UPLOAD[] PROGMEM = R\"(\n{\n  \"uri\": \"/\",\n  \"title\": \"Upload\",\n  \"menu\": true,\n  \"element\": [\n    { \"name\":\"caption\", \"type\":\"ACText\", \"value\":\"&lt;h2&gt;File uploading platform&lt;h2&gt;\" },\n    { \"name\":\"upload_file\", \"type\":\"ACFile\", \"label\":\"Select file: \", \"store\":\"extern\" },\n    { \"name\":\"upload\", \"type\":\"ACSubmit\", \"value\":\"UPLOAD\", \"uri\":\"/upload\" }\n  ]\n}\n)\";\n\nstatic const char PAGE_RECEIVED[] PROGMEM = R\"(\n{\n  \"uri\": \"/upload\",\n  \"title\": \"Upload ended\",\n  \"menu\": false,\n  \"element\": [\n    { \"name\":\"caption\", \"type\":\"ACText\", \"value\":\"&lt;h2&gt;File uploading ended&lt;h2&gt;\" }\n  ]\n}\n)\";\n\n// Custom upload handler class\nclass CustomUploader : public AutoConnectUploadHandler {\npublic:\n  CustomUploader() {}\n~CustomUploader() {}\n\nprotected:\nbool   _open(const char* filename, const char* mode) override;\nsize_t _write(const uint8_t *buf, const size_t size) override;\nvoid   _close(void) override;\n};\n\n// _open for custom open\nbool CustomUploader::_open(const char* filename, const char* mode) {\n// Here, an implementation for the open file.\n}\n\n// _open for custom write\nsize_t CustomUploader::_write(const uint8_t *buf, const size_t size) {\n// Here, an implementation for the writing the file data.\n}\n\n// _open for custom close\nvoid CustomUploader::_close(void) {\n// Here, an implementation for the close file.\n}\n\nAutoConnect     portal;\nAutoConnectAux  uploadPage;\nAutoConnectAux  receivePage;\nCustomUploader  uploader;   // Declare the custom uploader\n\nvoid setup() {\n  uploadPage.load(PAGE_UPLOAD);\n  receivePage.load(PAGE_RECEIVED);\n  portal.join({ uploadPage, receivePage });\n  receivePage.onUpload&lt;CustomUploader&gt;(uploader);  // Register the custom uploader\n  portal.begin();\n}\n\nvoid loop() {\n  portal.handleClient();\n}\n</code></pre> <p>Don't forget to specify the store</p> <p>When using a custom uploader, remember to specify the extern for the store attribute of AutoConnectFile.</p> <ol> <li> <p>The AutoConnectFile element can be used with other AutoConnectElements on the same page.\u00a0\u21a9</p> </li> </ol>"},{"location":"adauthentication.html","title":"Authentication settings","text":"<p>The Sketch may use authentication to protect custom Web pages and prevent unauthorized access. AutoConnect has implemented HTTP authentication feature that can be applied to multiple scopes using the authentication methods provided by the platform's WebServer library for ESP8266 or ESP32.1</p> <ul> <li>Applying HTTP authentication</li> <li>Applying HTTP authentication for Built-in OTA</li> <li>Authentication within the captive portal state</li> </ul>"},{"location":"adauthentication.html#applying-http-authentication","title":"Applying HTTP authentication","text":"<p>AutoConnectConfig::auth setting allows the Sketch to HTTP authenticate with \"BASIC\" or \"DIGEST\" scheme. AutoConnectConfig::authScope specifies the scope covered by authentication which is the whole range for all pages of the Sketch, custom web pages, or AutoConnect pages. AutoConnectConfig::username and AutoConnectConfig::password specifies credential as user-id/password pairs.</p> <p>The Sketch enables HTTP authentication with the AutoConnectConfig::auth setting, also specifies the authentication scheme:</p> <ul> <li>AC_AUTH_NONE     AutoConnect pages and custom Web pages do not require authentication. Not protected from all HTTP access. This is the default.</li> <li>AC_AUTH_DIGEST     Protect AutoConnect pages and custom Web pages with DIGEST authentication.</li> <li>AC_AUTH_BASIC     Protect AutoConnect pages and custom Web pages with BASIC authentication.</li> </ul> <p>Note that the authentication scope specified in AutoConnectConfig::authScope is different from the protection space shown by Realm for HTTP authentication. AutoConnect assumes only one Realm and defines it as AUTOCONNECT_AUTH_REALM in <code>AutoConnectDefs.h</code> header file. Instead, the Sketch will be able to expand or narrow the range of authentication by AutoConnectConfig::authScope setting, which can be either as follows:</p> <ul> <li>AC_AUTHSCOPE_PORTAL     Require authentication to access for all AutoConnect pages, including custom Web pages.</li> <li>AC_AUTHSCOPE_AUX     Require authentication to access for all custom Web pages, excepting AutoConnect pages. This is the Default.</li> <li>AC_AUTHSCOPE_PARTIAL     Authenticate only specific custom Web pages which are specified by AutoConnectAux::authentication function or JSON.</li> </ul> <p>Also, a credential used for authentication is specified in the Sketch using the AutoConnectConfig::username and AutoConnectConfig::password settings.2</p> <p>Here's a minimal Sketch with HTTP authentication for the custom Web page:</p> <pre><code>#include &lt;ESP8266WiFi.h&gt;\n#include &lt;ESP8266WebServer.h&gt;\n#include &lt;AutoConnect.h&gt;\n\nstatic const char PAGE_AUTH[] PROGMEM = R\"(\n{\n  \"uri\": \"/auth\",\n  \"title\": \"Auth\",\n  \"menu\": true,\n  \"element\": [\n    {\n      \"name\": \"text\",\n      \"type\": \"ACText\",\n      \"value\": \"AutoConnect has authorized\",\n      \"style\": \"font-family:Arial;font-size:18px;font-weight:400;color:#191970\"\n    }\n  ]\n}\n)\";\n\nWebServerClass    server;\nAutoConnect       portal(server);\nAutoConnectConfig config;\n\nvoid setup() {\n  config.auth = AC_AUTH_DIGEST;\n  config.authScope = AC_AUTHSCOPE_AUX;\n  config.username = \"user\";\n  config.password = \"password\";\n  portal.config(config);\n  portal.load(FPSTR(PAGE_AUTH));\n  portal.begin();\n}\n\nvoid loop() {\n  portal.handleClient();\n}\n</code></pre> <p>If you want to authenticate only specific pages in a Sketch that handles multiple custom Web pages, set AC_AUTHSCOPE_PARTIAL to AutoConnectConfig::authScope. Then, it specifies the authentication scheme with the auth key in the JSON description of the page should be authenticated.  </p> <p>AutoConnect determines which authentication method to use for custom Web pages (such as AutoConnectAux) based on its association with AutoConnectConfig::authScope setting. The table below shows which authentication scheme will be finally adopted. As shown in this table, the final authentication scheme depends on the AutoConnectConfig::authScope setting, and if AC_AUTHSCOPE_PARTIAL is specified it, AutoConnectAux's authentication setting takes precedence over the AutoConnectConfig::auth setting.</p> AutoConnectConfig::authScope Authentication scheme for the custom Web page AC_AUTHSCOPE_PORTAL Specified by AutoConnectConfig::auth AC_AUTHSCOPE_AUX Specified by AutoConnectConfig::auth AC_AUTHSCOPE_PARTIAL Specified by AutoConnectAux::authentication, The default values is AC_AUTH_NONE. <p>Authentication designation for AutoConnectAux can also be specified by giving the following value to the auth key by the JSON description:</p> <ul> <li>\"auth\" : \"basic\"</li> <li>\"auth\" : \"digest\"</li> <li>\"auth\" : \"none\"</li> </ul> <p>The following example Sketch has two custom Web pages, <code>Hello</code> and <code>Auth</code>. It applies authentication only to the <code>Auth</code> page by setting AC_AUTHSCOPE_PARTIAL to AutoConnectConfig::authScope.</p> <pre><code>#include &lt;ESP8266WiFi.h&gt;\n#include &lt;ESP8266WebServer.h&gt;\n#include &lt;AutoConnect.h&gt;\n\nstatic const char PAGE_HELLO[] PROGMEM = R\"(\n{\n  \"uri\": \"/hello\",\n  \"title\": \"Hello\",\n  \"menu\": true,\n  \"element\": [\n    {\n      \"name\": \"text\",\n      \"type\": \"ACText\",\n      \"value\": \"Hello, word\",\n      \"style\": \"font-family:Arial;font-size:18px;font-weight:400;color:#191970\"\n    }\n  ]\n}\n)\";\n\nstatic const char PAGE_AUTH[] PROGMEM = R\"(\n{\n  \"uri\": \"/auth\",\n  \"title\": \"Auth\",\n  \"menu\": true,\n  \"auth\": \"digest\",\n  \"element\": [\n    {\n      \"name\": \"text\",\n      \"type\": \"ACText\",\n      \"value\": \"AutoConnect has authorized\",\n      \"style\": \"font-family:Arial;font-size:18px;font-weight:400;color:#191970\"\n    }\n  ]\n}\n)\";\n\nWebServerClass    server;\nAutoConnect       portal(server);\nAutoConnectConfig config;\n\nvoid setup() {\n// It's a default value but has no meaning in the AC_AUTHSCOPE_PARTIAL setting.\n// config.auth = AC_AUTH_NONE;\n  config.authScope = AC_AUTHSCOPE_PARTIAL;\n  config.username = \"user\";\n  config.password = \"password\";\n  portal.config(config);\n  portal.load(FPSTR(PAGE_HELLO));\n  portal.load(FPSTR(PAGE_AUTH));\n  portal.begin();\n}\n\nvoid loop() {\n  portal.handleClient();\n}\n</code></pre> <p>PageBuilder v1.4.0 or later needed</p> <p>PageBuilder v1.4.0 or later is required to use HTTP authentication with AutoConnect. Also, v1.4.2 or later is required to eliminate SPIFFS, which is deprecated as a file system for ESP8266 module.</p> <p>Can not use DIGEST authentication for ESP32 arduino core 1.0.4 stable release</p> <p>For ESP32, Arduino core 1.0.4 stable has a bug for DIGEST authentication. The upstream of the master is recommended. (or use BASIC authentication)</p>"},{"location":"adauthentication.html#applying-http-authentication-for-built-in-ota","title":"Applying HTTP authentication for Built-in OTA","text":"<p>AutoConnectConfig::auth setting also affects the built-in OTA feature. AC_AUTH_BASIC or AC_AUTH_DIGEST setting allows Built-in OTA to authenticate with the UPDATE page. This setting is valid even if AutoConnectConfig::authScope is AC_AUTHSCOPE_PARTIAL. That is if the AutoConnectConfig::auth setting is BASIC or DIGEST, authentication will be required for Built-in OTA. See also Authentication with AutoconnectOTA.</p>"},{"location":"adauthentication.html#authentication-within-the-captive-portal-state","title":"Authentication within the captive portal state","text":"<p>When accessing the ESP module from an iOS or Android device in the captive portal state, the HTTP authentication framework is disabled in the OS of the client device. Even if the ESP module responds with a <code>401 unauthorized</code> with <code>WWW-Authenticate</code>, those client device OSs under the captive portal do not display the login dialog and deprive the user of the opportunity to enter their credentials. There will always be an unauthorized error.</p> <p>AutoConnect's authentication operation based on HTTP (not HTTPS) depends on the OS of the client device, so in the captive portal state, most devices will unconditionally result in an authentication error. Therefore, the default authentication behavior of AutoConnect does not apply authentication in the captive portal state. (It will be ignored even if the AutoConnect setting is not AC_AUTH_NONE)</p> <p>However, if you want to deny unauthorized access to the protected page even in the captive portal state, you can use the extension bit of AutoConnectConfig::authScope. The AC_AUTHSCOPE_WITHCP flag allows AutoConnect to authentication in the captive portal state. It is set using a logical OR operator for the AutoConnectConfig::authScope setting and AutoConnect will enable authentication at the captive portal if the AC_AUTHSCOPE_WITHCP is ON.</p> <pre><code>AutoConnectConfig config;\n...\nconfig.auth = AC_AUTH_DIGEST;\nconfig.authScope = AC_AUTHSCOPE_AUX | AC_AUTHSCOPE_WITHCP;\n...\n</code></pre> <ol> <li> <p>ESP32 Arduino core has the authenticate method provided by the WebServer library, similar to that of the ESP8266.\u00a0\u21a9</p> </li> <li> <p>The default user name and password for authentication inherits the setting of AutoConnectConfig::apid and AutoConnectConfig::psk.\u00a0\u21a9</p> </li> </ol>"},{"location":"adconnection.html","title":"AutoConnect WiFi connection control","text":"<p>AutoConnect aims to connect the ESP module as a station to a WiFi access point and equips with various APIs to maintain a WiFi connection as possible while sketch running. The main APIs are AutoConnect::begin and AutoConnect::handleClient. You can make sketches with flexible WiFi connection capability by properly using these two APIs and the settings by AutoConnectConfig.</p> <ul> <li>Automatic reconnect</li> <li>Automatic reconnect (Background)</li> <li>Configure WiFi channel</li> <li>Connects depending on the WiFi signal strength</li> <li>Detects connection establishment to AP</li> <li>Match with known access points by SSID</li> <li>Preserve AP mode</li> <li>Timeout settings for a connection attempt</li> <li>Verify the WiFi connection conditions</li> </ul>"},{"location":"adconnection.html#automatic-reconnect","title":"Automatic reconnect","text":"<p>AutoConnect will change the WiFi mode depending on the situation. The AutoConnect::begin function starts the Web Server with WIFI_STA mode when the connection is successful with 1st-WiFi.begin. If the connection with the last access point fails, AutoConnect will switch the WiFi mode to WIFI_AP_STA, launching a DNS server and allowing the ESP module to launch the captive portal.</p> <p>The captive portal launches SoftAP at its start and disconnects the STA. At this time, the ESP module discards its stored station configuration data (known as the SDK's station_config structure). This is the default behavior of AutoConnect.</p> <p>On the other hand, AutoConnect can connect to an access point again that has disconnected once, and its control is allowed by AutoConnectConfig::autoReconnect that option specifies to attempt to reconnect to the past established access point using the saved credentials. If the autoReconnect is enabled, AutoConnect will not launch SoftAP immediately even if 1st-WiFi.begin fails. When AutoConnect fails WiFi connection, it will scan the WiFi signal and try to find the access point that the ESP module has connected to in the past. If AutoConnect finds one of the saved credentials from the broadcast with BSSID, it will explicitly apply the matching credential and attempt to reconnect while in WIFI_STA mode. (AutoReconnect works well even with hidden SSID access points)</p> <pre><code>AutoConnect       Portal;\nAutoConnectConfig Config;\nConfig.autoReconnect = true;\nPortal.config(Config);\nPortal.begin();\n</code></pre> <p>The autoReconnect option is only available for AutoConnect::begin without SSID and PASSWORD parameter. If you use AutoConnect::begin with an SSID and PASSWORD, no reconnection attempt will be made if the 1st-WiFi.begin fails to connect to that SSID.</p> <p>The autoReconnect is not autoreconnect</p> <p>The WiFiSTAClass::disconnect function implemented in the arduino-esp32 has extended parameters than the ESP8266's arduino-core. The second parameter of WiFi.disconnect on the arduino-esp32 core that does not exist in the ESP8266WiFiSTAClass has the effect of deleting the currently connected WiFi configuration and its default value is \"false\". On the ESP32 platform, even if WiFi.disconnect is executed, WiFi.begin without the parameters in the next turn will try to connect to that AP. That is, automatic reconnection is implemented in arduino-esp32 already. Although this behavior appears seemingly competent, it is rather a disadvantage in scenes where you want to change the access point each time. When explicitly disconnecting WiFi from the Disconnect menu, AutoConnect will erase the AP connection settings saved by the arduino-esp32 core. AutoConnect's automatic reconnection is a mechanism independent from the automatic reconnection of the arduino-esp32 core.</p>"},{"location":"adconnection.html#automatic-reconnect-background","title":"Automatic reconnect (Background)","text":"<p>Combining autoReconnect with AutoConnectConfig::reconnectInterval allows you to periodically repeat connection attempts to known access points within AutoConnect::handleClient. This process is pseudo-asynchronous and does not block the Sketch process in the <code>loop()</code> function.</p> <p>The reconnectInterval specifies the interval time to seek for known access points with saved credentials during the handleClient loop and attempt to connect to the AP.</p> <pre><code>AutoConnect       Portal;\nAutoConnectConfig Config;\n\nvoid setup() {\n  Config.autoReconnect = true;    // Attempt automatic reconnection.\n  Config.reconnectInterval = 6;   // Seek interval time is 180[s].\n  Portal.config(Config);\n  Portal.begin();\n}\n\nvoid loop() {\nif (WiFi.status() == WL_CONNECTED) {\n// Here to do when WiFi is connected.\n  }\nelse {\n// Here to do when WiFi is not connected.\n  }\n\n  Portal.handleClient();\n}\n</code></pre> <p>Above Sketch shows a configuration example that you want to keep connecting to known access points as long as possible. When the WiFi connection is lost, it will start seeking the WiFi network every 30 seconds during the handleClient loop.</p> <p>Limitation for automatic reconnection to a specific access point</p> <p>An access point that ESP module to reconnect automatically depends on whether the SSID and password argument existence with AutoConnect::begin. If the Sketch calls AutoConnect::begin without specifying an SSID or password, the autoReconnect will connect to one of the detected access points and cannot be pre-determined. The other one, the case of the Sketch specifies SSID and password with AutoConnect::begin, the autoReconnect will try to reconnect to a specified access point periodically during the handleClient loop.</p> <p>Also, you can combine the background automatic reconnect performing inside the loop function by handleClient with AutoConnectConfig::retainPortal and AutoConnectConfig::autoReset, to enable pop up the captive portal automatically on the client device each time the ESP module disconnects from the access point.</p> <pre><code>AutoConnect       Portal;\nAutoConnectConfig Config;\n\nvoid setup() {\n  Config.autoReset = false;     // Not reset the module even by intentional disconnection using AutoConnect menu.\n  Config.autoReconnect = true;  // Reconnect to known access points.\n  Config.reconnectInterval = 6; // Reconnection attempting interval is 3[min].\n  Config.retainPortal = true;   // Keep the captive portal open.\n  Portal.config(Config);\n  Portal.begin();\n}\n\nvoid loop() {\nif (WiFi.status() == WL_CONNECTED) {\n// Here to do when WiFi is connected.\n  }\nelse {\n// Here to do when WiFi is not connected.\n  }\n}\n</code></pre> <p>The effective range of the reconnectInterval depending on the setting value</p> <p>The range of values that reconnectInterval can take is 0 to 255. (Actual seconds are from 0 to 255\u00d7AUTOCONNECT_UNITTIME) Reconnect behavior depends on the setting value. If it is 0, reconnection will work if the 1st-WiFi.begin in AutoConnect::begin fails and will suspend during the handleClient loop. If reconnectInterval is greater than 0, AutoConnect will attempt to reconnect both in AutoConnect::begin and during the handleClient loop.</p>"},{"location":"adconnection.html#configure-wifi-channel","title":"Configure WiFi channel","text":"<p>Appropriately specifying the WiFi channel to use for ESP8266 and ESP32 is essential for a stable connection with the access point. AutoConnect remembers the WiFi channel with a credential of the access point once connected and reuses it.</p> <p>The default channel when a captive portal starts and AutoConnect itself becomes an access point is the AutoConnectConfig::channel member. If this channel is different from the channel of the access point you will attempt to connect, WiFi.begin may fail. The cause is that the ESP module shares the same channel in AP mode and STA mode. If the connection attempt is not stable, specifying a proper channel using AutoConnectConfig::channel may result in a stable connection.</p>"},{"location":"adconnection.html#connects-depending-on-the-wifi-signal-strength","title":"Connects depending on the WiFi signal strength","text":"<p>When the ESP module found the multiple available access points (i.e. AutoConnect has connected in the past), the default behavior AutoConnect will attempt to connect to the least recent one. However, If the ESP module can operate properly with any access point, it is advantageous to establish a connection with the best one of the reception sensitivity. </p> <p>The AutoConnectConfig::principle parameter has the connection disposition, and specifying AC_PRINCIPLE_RSSI will attempt to connect to one of the highest RSSI value among multiple available access points. Also You can expect stable WiFi connection by specifying the lower limit of signal strength using AutoConnectConfig::minRSSI. Combining these two parameters allows you to filter the destination AP when multiple available access points are found.</p> <p>AutoConnectConfig::principle affects the behavior of both 1st-WiFi.begin and autoReconnect. If you specify AC_PRINCIPLE_RECENT for the principle, it will try according to the conventional connection rules, but if you specify AC_PRINCIPLE_RSSI, it will try to connect to the access point that is sending the strongest WiFi signal at that time instead of the last accessed AP. Also, the static IPs will be restored from a saved credential instead of AutoConnectConfig. (The values specified by AutoConnectConfig is ignored)</p> SSID &amp;Password AutoConnectConfig::principle Which credentials would be selected Static IPs AutoConnect::begin NULL specified AC_PRINCIPLE_RECENT Nothing, depends on SDK saves Use the specified value of AutoConnectConfig AC_PRINCIPLE_RSSI Auto-selected credentials with max RSSI Restoring static IPs suitable for the SSID from saved credentials Specified with the Sketch Not effective By AutoConnect::begin parameters Use the specified value of AutoConnectConfig AutoReconnect Load fromsaved credential AC_PRINCIPLE_RECENT Recently saved SSID would be chosen Restoring static IPs suitable for the SSID from saved credentials AC_PRINCIPLE_RSSI Auto-selected credentials with max RSSI <p>In ESP32, the difference between the AutoConnectConfig::principle and <code>WIFI_ALL_CHANNEL_SCAN</code> in <code>WiFi.begin</code></p> <p>In ESP32, if there are multiple access points with the same SSID and PW within reach, <code>WiFi.begin</code> with the SSID and PW explicitly specified will scan all radio channels and connect to the AP which has the highest signal strength. This feature has been enabled since ESP32 Arduino Release 1.0.6. The <code>principle</code> setting is slightly different from this feature. AutoConnect does not specify the SSID and PW in the 1st-WiFi.begin. It leaves that to the contents stored in the SDK. Even if there is an AP with a stronger signal nearby, it will try to connect to an AP with a smaller channel number. However, in the case where <code>autoReconnect</code> setting will attempt to reconnect, AutoConnect will read the SSID and PW from the saved credentials and explicitly pass them to <code>WiFi.begin</code>. Therefore, in this case, the connection will be made to the AP with the highest signal strength by <code>WIFI_ALL_CHANNEL_SCAN</code>. But it is only valid across multiple APs with the same SSID and PW. On the other hand, AC_PRINCIPLE_RSSI tries to connect the AP with the strongest signal from the connection candidates after selecting the SSID when multiple APs with different SSIDs are mixed in the reachable range.</p>"},{"location":"adconnection.html#detects-connection-establishment-to-ap","title":"Detects connection establishment to AP","text":"<p>The Sketch can detect that the ESP module has established a WiFi connection as a station to the access point. The AutoConnect::begin or AutoConnect::handleClient will transit the control temporarily to the function in the Sketch registered by AutoConnect::onConnect when the ESP module establish a WiFi connection. The ConnectExit function registered with AutoConnect::onConnect should have the following types and arguments:</p> <pre><code>void ConnectExit(IPAddress&amp; ip)\n</code></pre> <p>The ConnectExit function is of type void. The argument ip is the IP address assigned to the ESP module by the connected AP. AutoConnect::onConnect allows the Sketch registers a ConnectExit function to AutoConnect. Also, you can make the function using a lambda expression.</p> <pre><code>AutoConnect Portal;\n\nvoid onConnect(IPAddress&amp; ipaddr) {\n  Serial.print(\"WiFi connected with \");\n  Serial.print(WiFi.SSID());\n  Serial.print(\", IP:\");\n  Serial.println(ipaddr.toString());\n}\nvoid setup() {\n  Serial.begin(115200);\n  Portal.onConnect(onConnect);  // Register the ConnectExit function\n  Portal.begin();\n}\n\nvoid loop() {\n  Portal.handleClient();\n}\n</code></pre> <p>In addition, a sketch that shuts down SoftAP when the ESP module connects to the access point can be described using a lambda expression as follows:</p> <pre><code>AutoConnect Portal;\n\nvoid setup() {\n  Serial.begin(115200);\n  Portal.onConnect([](IPAddress&amp; ipaddr){\n    Serial.printf(\"WiiFi connected with %s, IP:%s\\n\", WiFi.SSID().c_str(), ipaddr.toString().c_str());\nif (WiFi.getMode() &amp; WIFI_AP) {\n      WiFi.softAPdisconnect(true);\n      WiFi.enableAP(false);\n      Serial.printf(\"SoftAP:%s shut down\\n\", WiFi.softAPSSID().c_str());\n    }\n  });\n  Portal.begin();\n}\n\nvoid loop() {\n  Portal.handleClient();\n}\n</code></pre> <p>It is not an event</p> <p>AutoConnect::onConnect has the same effect on the Sketch as the WiFi.onStationModeConnected, but AutoConnect does not use the event. Sketch can use <code>WiFi.onEvent</code> independently of AutoConnect.</p>"},{"location":"adconnection.html#match-with-known-access-points-by-ssid","title":"Match with known access points by SSID","text":"<p>By default, AutoConnect uses the BSSID to search for known access points. (Usually, it's the MAC address of the device) By using BSSID as the key to finding the WiFi network, AutoConnect can find even if the access point is hidden. However BSSIDs can change on some mobile hotspots, the BSSID-keyed searches may not be able to find known access points. If you operate inconvenience in aiming at the access point by BSSID, you can change the collation key from BSSID to SSID by uncommenting <code>AUTOCONNECT_APKEY_SSID</code> macro definition in <code>AutoConnectDefs.h</code> library source code.</p> <pre><code>#define AUTOCONNECT_APKEY_SSID\n</code></pre> <p>Allow you to use PlatformIO as a build system and give the following description to the <code>platformio.ini</code>, you can enable AUTOCONNECT_APKEY_SSID each build without modifying the library source code:</p> <pre><code>build_flags=-DAUTOCONNECT_APKEY_SSID\n</code></pre> <p>Can't be found hidden APs in SSID-keyed</p> <p>The hidden access point's SSID will be blank on the broadcast. So if the seek key is an SSID, AutoConnect will not find it.</p>"},{"location":"adconnection.html#preserve-ap-mode","title":"Preserve AP mode","text":"<p>Sketch using AutoConnect can open a gateway to the Internet by connecting to a WiFi router even through use Espressif's peculiar WiFi protocol (e.g. ESP-MESH or ESP-NOW). These specific communication protocols require to keeps AP + STA as the WiFi mode. That is, to apply these protocols, it needs to launch SoftAP by a sketch itself and then call AutoConnect::begin. But the default behavior of AutoConnect::begin will turn off SoftAP always then it will unable to open a connection.</p> <p>AutoConnectConfig::preserveAPMode setting maintains WIFI_AP mode without disabling SoftAP inside AutoConnect::begin. The Sketch can utilize the WiFi connection via AutoConnect with ESP-MESH and ESP-NOW protocol by enabling this option.</p> <p>The following diagram quoted from the ESP-MESH documentation that illustrates the typical topology of the MESH network. The module located at the Root Node bridges between the mesh network and the router by an application that handles two protocols, TCP/IP and ESP-MESH. Its SoftAP communicates with the internal mesh network as an interface of the mesh layer. On the other hand, STA performs station communication with the WiFi router as an interface of the TCP/IP layer. AutoConnect allows assists the connection between the router and the STA of the Root Node using AutoConnectConfig::preserveAPMode and starting the SoftAP via Sketch separately.</p> <p></p> <p>Also in general, the Sketch should set false to AutoConnectConfig::autoRise, true to AutoConnectConfig::immediateStart when applying to those protocols.</p>"},{"location":"adconnection.html#timeout-settings-for-a-connection-attempt","title":"Timeout settings for a connection attempt","text":"<p>AutoConnect uses AutoConnectConfig::beginTimeout value to limit time to attempt when connecting the ESP module to the access point as a WiFi station. The default value is AUTOCONNECT_TIMEOUT defined in <code>AutoConnectDefs.h</code> and the initial value is 30 seconds. (actually specified in milliseconds) For example, the following sketch sets the connection timeout to 15 seconds:</p> <pre><code>AutoConnect Portal;\nAutoConnectConfig Config;\n\nvoid setup() {\n  Config.beginTimeout = 15000; // Timeout sets to 15[s]\n  Portal.config(Config);\n  Portal.begin();\n}\n\nvoid loop () {\n  Portal.handleClient();\n}\n</code></pre> <p>In addition, the limit of the waiting time for connection attempts can be specified by the AutoConnect::begin parameter too. The timeout parameter specified in AutoConnect::begin takes precedence over AutoConnectConfig::beginTimeout.</p> <p>The beginTimeout has an effect on handleClient</p> <p>The beginTimeout value will be applied with handleClient when requesting a connection from the captive portal and when attempting to reconnect with autoReconnect.</p>"},{"location":"adconnection.html#verify-the-wifi-connection-conditions","title":"Verify the WiFi connection conditions","text":"<p>AutoConnect has the following indicators regarding WiFi connection attempts. These states are indicated as bitwise values and are the logical disjunction of multiple states. For example, if the 1st-WiFi.begin fails and the connection is restored by the AutoConnectConfig::autoReconnect setting, this status value will indicate both <code>AC_AUTORECONNECT</code> and <code>AC_ESTABLISHED</code>.</p> <p>A sketch can get this status value using the AutoConnect::portalStatus function. AutoConnect::portalStatus returns a value of type uint8_t. The return value is a bitwise value that indicates each status in the table below. In the sketch, the WiFi connection status is detected by taking the AND of the return value and the <code>enum</code> value shown in the following table:</p> Values of the status indication WiFi connection situations AutoConnect::AC_IDLE Initial state: This is the initial state, AutoConnect is not making any WiFi connection attempts. This state is reached immediately after AutoConnect::begin starts. AutoConnect::AC_ESTABLISHED Connection successful: Successfully connected to the WiFi access point. AutoConnect::AC_AUTORECONNECT The autoReconnect was applied:  AutoConnectConfig::autoReconnect setting was applied during the WiFi connection attempt process. This flag does not indicate a successful connection. It only shows that a condition that triggers autoReconnect has occurred. Whether the connection was actually successful should be determined by <code>WiFi.status()==WL_CONNECTED</code>. AutoConnect::AC_TIMEOUT Connection timeout: WiFi connection attempt timed out. Or, the captive portal was shut down by the AutoConnectConfig::portalTimeout setting. AutoConnect::AC_INTERRUPT Connection interrupted due to an indication with the exit: The whileConnecting exit routine returned false. or the whileCaptivePortal exit routine returned false. AutoConnect aborted the WiFi connection attempt with those indications. AutoConnect::AC_CAPTIVEPORTAL Captive portal is available: SoftAP mode is enabled, and the DNS server is available. AutoConnect will redirect connection requests to SoftAP from client devices to a captive portal site within AutoConnect. The state of this flag is equivalent to the return value of AutoConnect::isPortalAvailable function.NOTE: AC_CAPTIVEPORTAL is false if only SoftAP is available and no DNS server is enabled. AutoConnect::AC_INPROGRESS WiFi.begin in progress: AutoConnect requests WiFi.begin and is waiting for the connection to succeed or times out; this state will reset when terminating WiFi.begin attempts. <pre><code>AutoConnect portal;\nAutoConnectConfig config;\n\nuint8_t state;\n\nvoid setup() {\n// Configure automatic reconnection and captive portal retention, then start\n// AutoConnect. In subsequent steps, it will use the portalStatus function to\n// detect the WiFi connection status in this configuration.\n  config.portalTimeout = 180000;\n  config.autoReconnect = true;\n  config.reconnectInterval = 1;\n  config.retainPortal = true;\n  portal.config(config);\n\n  portal.begin();\n\n  state = portal.portalStatus();\nif (WiFi.status() == WL_CONNECTED) {\nif (state &amp; AutoConnect::AC_AUTORECONNECT)\n      Serial.println(\"Auto reconnection applied\");\n  }\nelse {\nif (state &amp; AutoConnect::AC_TIMEOUT)\n      Serial.println(\"Connection timeout\");\n  }\n\nif (state &amp; AutoConnect::AC_CAPTIVEPORTAL)\n    Serial.println(\"Captive portal is still alive\");\nelse\n    Serial.println(\"Captive portal is not available\");\n}\n\nvoid loop() {\n  portal.handleClient();\nuint8_t transition = portal.portalStatus();\n\nif (transition != state) {\nif (transition &amp; AutoConnect::AC_CAPTIVEPORTAL)\n      Serial.println(\"Captive portal activated\");\nif (transition &amp; AutoConnect::AC_AUTORECONNECT)\n      Serial.println(\"Auto reconnection applied\");\nif (!(transition &amp; AutoConnect::AC_ESTABLISHED))\n      Serial.println(\"WiFi connection lost\");\n\n    state = transition;\n  }\n}\n</code></pre> <p>AutoConnect::portalStatus within the loop of AutoConnect::handleClient</p> <p>AutoConnect::portalStatus function is also valid during the AutoConnect::handleClient loop inside the <code>loop</code> function. With the background reconnection enabled using the AutoConnectConfig::autoReconnect and AutoConnectConfig::reconnectInterval settings, the AutoConnect::portalStatus function will return a value indicating the reconnection status at every time AutoConnect::handleClient in the <code>loop()</code>.</p>"},{"location":"adcpcontrol.html","title":"Captive portal control","text":"<p>The default behavior of AutoConnect is to launch the captive portal if 1st-WiFi.begin attempting inside AutoConnect::begin fails. You can change this default behavior through the AutoConnectConfig settings join together with Sketch code that implements to control the WiFi connection attempting.</p> <ul> <li>Captive portal start control</li> <li>Captive portal start detection</li> <li>Captive portal state identification</li> <li>Captive portal timeout control</li> <li>Disable the captive portal</li> <li>Launch the captive portal on demand by external trigger</li> <li>Launch the captive portal on-demand at losing WiFi</li> <li>Shutdown the captive portal</li> <li>Sketch execution during the captive portal loop</li> </ul>"},{"location":"adcpcontrol.html#captive-portal-start-control","title":"Captive portal start control","text":"<p>AutoConnect will launch the captive portal based on the AutoConnectConfig settings when the WiFi connection status will become to certain conditions. AutoConnectConfig::autoRise and AutoConnectConfig::immediateStart are concern the conditions to launch the captive portal. Also, the AutoConnectConfig::retainPortal controls the continuity of the captive portal state and allows the Sketch to launch the captive portal dynamically even while in a handleClient loop.</p> <p>The autoRise allows or disallows the launch of the captive portal. AutoConnect launches the captive portal only if the autoRise is true. If the autoRise is false, the captive portal will not start even if the WiFi connection is lost.</p> <p>Basically, the captive portal initiation is triggered by the result of 1st-WiFi.begin, but Sketch can control it according to direct the following four actions by configuring AutoConnectConfig with two parameters, the immediateStart and the autoRise.</p> AutoConnectConfig::immediateStart AutoConnectConfig::autoRise true false true Skip *1st-WiFi.begin*ESP module becomes SoftAP and the captive portal starts immediately. Not attempt WiFi connection.Only WebServer will start in STA mode. false Attempts WiFi connection in STA mode.In some cases, the autoReconnect may restore the connection even if 1st-WiFiBeing fails.If the connection is completely lost, the captive portal will be launched.This is the default. Attempts WiFi connection in STA mode.In some cases, the autoReconnect may restore the connection even if 1st-WiFiBeing fails.ESP module stays in STA mode and WebServer will start. <p>The retainPortal specifies the continuity of the captive portal after AutoConnect::begin, allowing the captive portal would be launched after the Sketch execution has transitioned into the loop function. When AutoConnect establishes a WiFi connection while in the captive portal within AutoConnect::begin, it stops the DNS server to close the captive portal with SoftAP still running. In this situation, if the Sketch loses the established WiFi connection while executing the loop function, it can reopen the captive portal.</p> <p>However, this behavior can be redundant depending on the Sketch characteristics. In such a case, you can prevent to starting the captive portal during the <code>loop()</code> by autoRise setting to false.</p>"},{"location":"adcpcontrol.html#captive-portal-start-detection","title":"Captive portal start detection","text":"<p>The captive portal will only be activated if 1st-WiFi::begin fails. Sketch can detect with the AutoConnect::onDetect function that the captive portal has started. For example, the Sketch can be written like as follows that turns on the LED at the start captive portal.</p> <pre><code>AutoConnect Portal;\n\nbool startCP(IPAddress&amp; ip) {\n  digitalWrite(BUILTIN_LED, HIGH);\n  Serial.println(\"C.P. started, IP:\" + ip.toString());\nreturn true;\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(BUILTIN_LED, OUTPUT);\n  digitalWrite(BUILTIN_LED, LOW);\n  Portal.onDetect(startCP);\nif (Portal.begin()) {\n    digitalWrite(BUILTIN_LED, LOW);\n  }\n}\n\nvoid loop() {\n  Portal.handleClient();\n}\n</code></pre>"},{"location":"adcpcontrol.html#captive-portal-state-identification","title":"Captive portal state identification","text":"<p>You can use the AutoConnect::isPortalAvailable function to identify if AutoConnect is in a captive portal state.</p> <p>Captive-Portal - i.e., just a spoofed response to a DNS lookup for Internet connection verification that occurs on a new connection attempt from the client device; it needs a DNS server and SoftAP to work. AutoConnect implements it with HTTP redirection. The AutoConnect::isPortalAvailable function returns true if all of the following conditions are met.</p> <ul> <li>ESP module is in WIFI_AP mode and enable SoftAP.</li> <li>IP address assigned to SoftAP is the equivalent of AutoConnectConfig::apip.</li> <li>AutoConnect is running a DNS server for directing to the captive portal. Through its action, DNS lookups issued by client devices for Internet transparency validation are directed to the ESP module SoftAP.</li> </ul> <p>A similar utility is AutoConnect::portalStatus</p> <p>See Verify the WiFi connection conditions and AutoConnect::portalStatus function.</p>"},{"location":"adcpcontrol.html#captive-portal-timeout-control","title":"Captive portal timeout control","text":"<p>Once AutoConnect has entered the captive portal state due to the above conditions, the default behavior is that AutoConnect::begin will not exit until a WiFi connection is established. Captive portal timeout control prevents AutoConnect from blocking the Sketch progress. It allows Sketch to abort AutoConnect::begin and returns control to Sketch. </p> <p>AutoConnect has two parameters for timeout control. The first is the timeout value used when trying to connect to the specified AP. It works like a typical timeout control for connection attempts with WiFi.begin. This setting is specified by the AutoConnectConfig::beginTimeout or third argument of the AutoConnect::begin function. The default value is the macro defined by AUTOCONNECT_TIMEOUT in the <code>AutoConnectDefs.h</code> header file.</p> <p>Another timeout control is for the captive portal itself. It is useful if you want to keep the Sketch offline running even if a WiFi connection is not possible. You can also combine its setting with the immediateStart option to create highly mobile sketches. The timeout of the captive portal is specified by the AutoConnectConfig::portalTimeout as follows.</p> <pre><code>#include &lt;ESP8266WiFi.h&gt;\n#include &lt;ESP8266WebServer.h&gt;\n#include &lt;AutoConnect.h&gt;\n\nAutoConnect  portal;\nAutoConnectConfig  config;\n\nvoid setup() {\n  config.portalTimeout = 60000;  // It will time out in 60 seconds\n  portal.config(config);\n  portal.begin();\n}\n\nvoid loop() {\nif (WiFi.status() == WL_CONNECTED) {\n// Some sketch code for the connected scene is here.\n  }\nelse {\n// Some sketch code for not connected scene is here.\n  }\n  portal.handleClient();\n}\n</code></pre> <p>Also, if you want to stop AutoConnect completely when the captive portal is timed out, you need to call the AutoConnect::end function. It looks like the following code:</p> <pre><code>bool acEnable;\n\nvoid setup() {\n  config.portalTimeout = 60000;  // It will time out in 60 seconds\n  portal.config(config);\n  acEnable = portal.begin();\nif (!acEnable) {\n    portal.end();\n  }\n}\n\nvoid loop() {\nif (WiFi.status() == WL_CONNECTED) {\n// Some sketch code for the connected scene is here.\n  }\nelse {\n// Some sketch code for not connected scene is here.\n  }\nif (acEnable) {\n    portal.handleClient();\n  }\n}\n</code></pre> <p>AutoConnectConfig has another option related to timeouts that you can enable to take advantage of the captive portal feature after a timeout occurrence. The AutoConnectConfig::retainPortal option will not shut down SoftAP and the internal DNS server even though AutoConnect::begin has aborted due to a timeout occurrence. Even after the captive portal times out, you can always try to connect to the AP while keeping the Sketch running offline.</p> <p>The following sample code is the Sketch above with the retainPortal setting added. As you can see, the implementation for captive portal continuation does not affect the main logic of the Sketch.</p> <pre><code>#include &lt;ESP8266WiFi.h&gt;\n#include &lt;ESP8266WebServer.h&gt;\n#include &lt;AutoConnect.h&gt;\n\nAutoConnect  portal;\nAutoConnectConfig  config;\n\nvoid setup() {\n  config.portalTimeout = 60000;  // It will time out in 60 seconds\n  config.retainPortal = true;\n  portal.config(config);\n  portal.begin();\n}\n\nvoid loop() {\nif (WiFi.status() == WL_CONNECTED) {\n// Some sketch code for the connected scene is here.\n  }\nelse {\n// Some sketch code for not connected scene is here.\n  }\n  portal.handleClient();\n}\n</code></pre>"},{"location":"adcpcontrol.html#disable-the-captive-portal","title":"Disable the captive portal","text":"<p>It can also prevent the captive portal from starting even if the connection at the 1st-WiFi.begin fails. In this case, AutoConnect::begin behaves same as WiFi.begin.</p> <p>For disabling the captive portal, autoRise sets to false with AutoConnectConfig.</p> <pre><code>AutoConnect       portal;\nAutoConnectConfig acConfig;\n\nacConfig.autoRise = false;\nportal.config(acConfig);\nportal.begin();\n</code></pre>"},{"location":"adcpcontrol.html#launch-the-captive-portal-on-demand-by-external-trigger","title":"Launch the captive portal on demand by external trigger","text":"<p>The default behavior of AutoConnect::begin gives priority to connect to the least recently established access point. In general, We expect this behavior in most situations, but will intentionally launch the captive portal on some occasion.</p> <p>Here section describes how to launch on demand the captive portal, and suggests two templates that you can use to implement it.</p> <ol> <li> <p>Offline for usual operation, connect to WiFi with an external switch</p> <p>You can use this template if the ESP module does not connect to WiFi at an ordinal situation and need to establish by a manual trigger. In this case, it is desirable that AutoConnect not start until an external switch fires. This behavior is similar to the WiFiManager's startConfigPortal function. AutoConnectConfig::immediateStart is an option to launch the portal by the SoftAP immediately without attempting 1st-WiFi.begin. Also, by setting the AutoConnectConfig::autoRise option to false, it is possible to suppress unintended automatic pop-ups of the portal screen when connecting to an ESP module SSID. To implement this, execute AutoConnect::config within the setup() function as usual, and handle AutoConnect::begin inside the loop() function.</p> <pre><code>#define TRIGGER_PIN 5     // Trigger switch should be LOW active.\n#define HOLD_TIMER  3000\n\nAutoConnect       Portal;\nAutoConnectConfig Config;\n\nvoid setup() {\n  pinMode(5, INPUT_PULLUP);\n  Config.immediateStart = true;\n// Config.autoRise = false;   // If you don't need to automatically pop-up the portal when connected to the ESP module's SSID.\n  Portal.config(Config);\n}\n\nvoid loop() {\nif (digitalRead(TRIGGER_PIN) == LOW) {\nunsigned long tm = millis();\nwhile (digitalRead(TRIGGER_PIN) == LOW) {\n      yield();\n    }\n// Hold the switch while HOLD_TIMER time to start connect.\nif (millis() - tm &gt; HOLD_TIMER)\n      Portal.begin();\n  }\n\nif (WiFi.status() == WL_CONNECTED) {\n// Here, what to do if the module has connected to a WiFi access point\n  }\n\n// Main process of your sketch\n\n  Portal.handleClient();  // If WiFi is not connected, handleClient will do nothing.\n}\n</code></pre> <p>It will not be automatic reconnect</p> <p>The above example does not connect to WiFi until TRIGGER_PIN goes LOW. When TRIGGER_PIN goes LOW, the captive portal starts and you can connect to WiFi. Even if you reset the module, it will not automatically reconnect.</p> </li> <li> <p>Register new access points on demand</p> <p>The following template is useful for controlling the registration of unknown access points. In this case, the ESP module establishes a WiFi connection using WiFi.begin natively without relying on AutoConnect. Known access point credentials are saved by AutoConnect, to the ESP module can use the saved credentials to handle WiFi.begin natively. This means that you can explicitly register available access points when needed, and the ESP module will not use unknown access points under normal situations.</p> <pre><code>AutoConnect* portal = nullptr;\n\nbool detectSwitch() {\n/*\n  Returns true if an external switch to configure is active.\n  */\n}\n\nbool connectWiFi(const char* ssid, const char* password, unsigned long timeout) {\n  WiFi.mode(WIFI_STA);\n  delay(100);\n  WiFi.begin(ssid, password);\nunsigned long tm = millis();\nwhile (WiFi.status() != WL_CONNECTED) {\nif (millis() - tm &gt; timeout)\nreturn false;\n  }\nreturn true;\n}\n\nvoid setup() {\n  AutoConnectCredential credt;\n  station_config_t  config;\nfor (int8_t e = 0; e &lt; credt.entries(); e++) {\n    credt.load(e, &amp;config);\nif (connectWiFi(config.ssid, config.password, 30000))\nbreak;\n  }\nif (WiFi.status() != WL_CONNECTED) {\n// Here, do something when WiFi cannot reach.\n  }\n}\n\nvoid loop() {\nif (detectSwitch()) {\n    AutoConnectConfig config;\n    config.immediateStart= true;\nif (!portal) {\n      portal = new AutoConnect;\n    }\n    portal-&gt;config(config);\nif (portal-&gt;begin()) {\n      portal-&gt;end();\ndelete portal;\n      portal = nullptr;\n    }\n  }\n// Here, ordinary sketch logic.\n}\n</code></pre> </li> </ol>"},{"location":"adcpcontrol.html#launch-the-captive-portal-on-demand-at-losing-wifi","title":"Launch the captive portal on-demand at losing WiFi","text":"<p>If the ESP module loses the established WiFi connection during the loop of handleClient, you can prevent the ESP module from going absolutely standalone by launching the captive portal on demand.</p> <p>When retainPortal and autoRise settings are enabled, AutoConnect will launch SoftAP and start DNS when it detects a WiFi disconnect with the router during a handleClient loop. This behavior will occur caused by a WiFi disconnect detection even if the WiFi mode is STA.</p> <p>Since AutoConnect v1.2.0, An improved retainPortal option allows the captive portal to be restarted during a handleClient loop even if it is closed once in AutoConnect::begin. In this case, the Sketch execution stage has already transitioned into the loop function, so the Sketch process seems running concurrently with the captive portal loop. Its captive portal launched from inside handleClient does not block the execution of the Sketch, unlike that launched from AutoConnect::begin.</p> <pre><code>AutoConnect       Portal;\nAutoConnectConfig Config;\n\nvoid setup() {\n  Config.autoRise = true; // It's the default, no setting is needed explicitly.\n  Config.retainPortal = true;\n  Portal.config(Config);\n  Portal.begin();\n}\n\nvoid loop() {\n  Portal.handleClient();\n}\n</code></pre> <p>Need autoRise enabled</p> <p>Need AutoConnectConfig::autoRise setting enabled to start the captive portal on demand during a handleClient loop.</p> <p>Although the Sketch above specifies the retainPortal, it does not instruct starts the captive portal always. AutoConnect will try WiFi.begin once in AutoConnect::begin unless the immediateStart option is specified. If AutoConnect fails the 1st-WiFi.begin, the captive portal will be launched at that point and the Sketch execution will stay within the AutoConnect::begin function.</p> <p>There is also a way to avoid starting the captive portal inside AutoConnect::begin and start the captive portal according to the WiFi connection status after the Sketch execution transitions to a handleClient loop. Adjusting the timing of autoRise activation will allow the captive portal to start only from inside AutoConnect::handleClient function.</p> <pre><code>AutoConnect       Portal;\nAutoConnectConfig Config;\n\nvoid setup() {\n  Config.retainPortal = true;\n  Config.autoRise = false;  // Suppresses the launch of the captive portal from AutoConnect::begin.\n  Portal.config(Config);    // Don't forget it.\n  Portal.begin();\n  Config.autoRise = true;   // Enable the launch of the captive portal.\n  Portal.config(Config);    // Don't forget it.\n}\n\nvoid loop() {\n  Portal.handleClient();\n}\n</code></pre> <p>The retainPortal option will keep SoftAP even if WiFi has established a connection as a client with the router.  Since it has the effect of stopping the DNS server, the phenomenon that the portal screen will not pop up automatically even though SoftAP is in action occur. This is a legacy behavior to ensure backward compatibility with up to AutoConnect v1.1.7. To stop SoftAP on escape from the on-demand captive portal, you need to explicitly call <code>WiFi.softAPdisconnect(true)</code> and <code>WiFi.enableAP(false)</code> in the Sketch.</p> <pre><code>AutoConnect       Portal;\nAutoConnectConfig Config;\n\nbool  Connected;\nunsigned long Elapsed;\n\nvoid onConnect(IPAddress&amp; clientIP) {\n  Connected = true;\n  Elapsed = millis();\n}\n\nvoid setup() {\n  Config.retainPortal = true;\n  Portal.config(Config);\n  Portal.onConnect(onConnect);\n  Portal.begin();\n}\n\nvoid loop() {\nif (WiFi.status() != WL_CONNECTED) {\n    connected = false;\n    Elapsed = millis();\n  }\n\nif ((WiFi.getMode() &amp; WIFI_AP) &amp;&amp; Connected) {\nif (millis() - Elapsed &gt; 30000) {\n      WiFi.softAPdisconnect(true);\n      WiFi.enableAP(false);\n    }\n  }\n// Actual sketch process is here.\n\n  Portal.handleClient();\n}\n</code></pre> <p>The above sketch will shutdown the SoftAP after elapsed time exceeds 30 seconds since the connection was re-established. Its logic is a bit tricky and does not stop SoftAP immediately after the connection established, which has several seconds delay. Doing it ensures that AutoConnect can send the HTML response.</p> <p>Stopped SoftAP is still displayed</p> <p>After SoftAP stopped, there is a time lag before it disappears from the detected access points list on the client device.</p>"},{"location":"adcpcontrol.html#shutdown-the-captive-portal","title":"Shutdown the captive portal","text":"<p>There is some complexity in the conditions under which AutoConnect shuts down the captive portal. Making a sketch that activates SoftAP only when needed can seem tedious. But there is a reason why. Even if AutoConnect could establish a connection using a captive portal, your cell phone as a client device would still have to keep connected to the ESP module-generated SoftAP in order to send the page for notifying the connection successful to a user. At that point, your client device that opened the captive portal still needs a connection with SoftAP.</p> <p>What happens, after all, is as follows:</p> <ol> <li>You made a connection to the access point such as WiFi router using the captive portal and took a successful page.</li> <li>Your sketch will rush into the loop function and starts to works well, hooray!</li> <li>Oops. Don't celebrate yet. I can see SoftAP ID on my cell phone. But the AutoConnect page never pops up automatically. Why?</li> </ol> <p>Because, for the above reasons, we can not promptly shut down the SoftAP. (However, DNS will stop)</p> <p>So, If you want to stop SoftAP after connecting to the access point using the captive portal, you need to implement the shutdown process with Sketch explicitly. A template of the basic sketch that can stop the SoftAP after the connection is the following:</p> <pre><code>AutoConnect Portal;\n\nvoid setup() {\nif (Portal.begin()) {\nif (WiFi.getMode() &amp; WIFI_AP) {\n      WiFi.softAPdisconnect(true);\n      WiFi.enableAP(false);\n    }\n  }\n}\n\nvoid loop() {\n  Portal.handleClient();\n}\n</code></pre> <p>If you stop SoftAP, the connection will be lost</p> <p>If you stop SoftAP immediately after the AutoConnect::begin successful, will part with the connection and cannot see the result notifying on your client device. You can expect to receive result notifications if you run handleClient before stopping SoftAP. (although you may not always succeed; it will not work if the WiFi radio signal is weak)</p>"},{"location":"adcpcontrol.html#sketch-execution-during-the-captive-portal-loop","title":"Sketch execution during the captive portal loop","text":"<p>With AutoConnect::begin, once the captive portal is started without being able to connect to a known WiFi access point, control will not return to sketch until the WiFi connection is established or times out. This behavior helps to pin the ESP module's network participation as a WiFi client (that is, AutoConnect::begin is an alternative to WiFi.begin) but it can not rush into the loop function of the Sketch. Therefore, while the ESP module is in the captive portal state and waiting for a connection operation to the access point, the behavior of the Sketch will be restrained by the escape conditions from AutoConnect::begin.</p> <p>The whileCaptivePortal exit allows the Sketch to continue the process temporarily while the ESP module remains standalone and the captive portal is open. AutConnect::whileCaptivePortal function registers the user's sketch function to be called by AutoConnect::begin or AutoConnect::handleClient during the execution of the captive portal session loop.</p> <p>The whileCaptivePortal exit can be registered by following: </p> <pre><code>AutoConnect portal;\n\nbool whileCP(void) {\nbool  rc;\n// Here, something to process while the captive portal is open.\n// To escape from the captive portal loop, this exit function returns false.\n// rc = true;, or rc = false;\nreturn rc;\n}\n\nvoid setup() {\n  ...\n  portal.whileCaptivePortal(whileCP);\n  portal.begin();\n  ...\n}\n</code></pre> <p>AutoConnect will open the captive portal in the AutoConnect::begin and AutoConnect::handleClient scenes, but the whileCaptive portal exit will be called repeatedly from AutoConnect::begin until exits from it. The whileCaptivePortal exit will be called repeatedly while the captive portal is open until WiFi connected or times out occurs. In the Sketch, returning a FALSE value from the whileCaptivePortal function allows the control to escape from the captive portal loop even before the session elapsed time exceeds the limits.</p>"},{"location":"adcredential.html","title":"Credential accesses","text":"<p>AutoConnect automatically saves the credentials of the established WiFi connection according to the AutoConnectConfig::autoSave settings. The save destination differs depending on the type of ESP module. In the case of ESP8266, it is the EEPROM, and in the case of ESP32, it is the NVS (Non-volatile storage) partition implemented by the Preferences class. Sketches can access their stored credentials through a class that is independent of AutoConnect.</p> <ul> <li>Access to saved credentials</li> <li>Autosave Credential</li> <li>Move the saving area of EEPROM for the credentials</li> <li>Save and restore credentials</li> </ul>"},{"location":"adcredential.html#access-to-saved-credentials","title":"Access to saved credentials","text":"<p>AutoConnect stores the credentials of the established WiFi connection in the flash of the ESP8266/ESP32 module and equips the class to access them from the Sketch. The Sketch can read, write, or erase the credentials using this class as the AutoConnectCredential individually. Refer to section Saved credentials access for details.</p> <p>Where to store credentials in ESP32 with AutoConnect v1.0.0 or later</p> <p>Since v1.0.0, credentials are stored in nvs of ESP32. AutoConnect v1.0.0 or later accesses the credentials area using the Preferences class with the arduino esp-32 core. So in ESP32, the credentials are not in the EEPROM, it is in the namespace AC_CREDT of the nvs. See Saved credentials access for details. In ESP8266, it is saved in EEPROM as is conventionally done.</p>"},{"location":"adcredential.html#autosave-credential","title":"Autosave Credential","text":"<p>In the sketch, you can give an indication of when to save the credentials by setting the following three options of AutoConnectConfig::autoSave:</p> <ul> <li>AC_SAVECREDENTIAL_AUTO : AutoConnect will save a credential when the WiFi connection is established with an access point. Its credential contains BSSID which a connection established access point has.</li> <li>AC_SAVECREDENTIAL_ALWAYS : AutoConnect will save a credential entered via Configure new AP menu even if a connection attempt has failed. BSSID does not exist in the credentials registered with this option. (will be 0x00) If this credential is selected as a connection candidate, the SSID will be adopted for matching attempts with the target access point even if <code>AUTOCONNECT_APKEY_SSID</code> is not enabled.</li> <li>AC_SAVECREDENTIAL_NEVER : AutoConnect will not store the credentials even if the connection to the access point is successful. However, the core SDK will save it, so it retains the previously established connection unless you disconnect the ESP module from the connected access point.</li> </ul> <pre><code>AutoConnect       Portal;\nAutoConnectConfig Config;\nConfig.autoSave = AC_SAVECREDENTIAL_NEVER;\nPortal.config(Config);\nPortal.begin();\n</code></pre> <p>Credentials storage location</p> <p>The location where AutoConnect saves credentials depends on the module type and the AutoConnect library version, also arduino-esp32 core version.  AutoConnect Arduino corefor ESP8266 Arduino core for ESP32 1.0.2 earlier 1.0.3 later v0.9.12 earlier EEPROM EEPROM (partition) Not supported v1.0.0 later Preferences (nvs)<p>(Can be used EEPROM with turning off AUTOCONNECT_USE_PREFERENCES macro)</p> Preferences (nvs)"},{"location":"adcredential.html#move-the-saving-area-of-eeprom-for-the-credentials","title":"Move the saving area of EEPROM for the credentials","text":"<p>By default, the credentials saving area is occupied from the beginning of EEPROM area. ESP8266 Arduino core document says that:</p> <p>The following diagram illustrates flash layout used in Arduino environment:</p> <pre><code>|--------------|-------|---------------|--|--|--|--|--|\n^              ^       ^               ^     ^\nSketch    OTA update   File system   EEPROM  WiFi config (SDK)\n</code></pre> <p>and</p> <p>EEPROM library uses one sector of flash located just after the SPIFFS.</p> <p>Also, in ESP32 arduino core 1.0.2 earlier, the placement of the EEPROM area of ESP32 is described in the partition table. So in the default state, the credential storage area used by AutoConnect conflicts with data owned by the user sketch. It will be destroyed together saved data in EEPROM by user sketch and AutoConnect each other. But you can move the storage area to avoid this.</p> <p>The boundaryOffset in AutoConnectConfig specifies the start offset of the credentials storage area. The default value is 0.</p> <p>The boundaryOffset ignored with AutoConnect v1.0.0 later on ESP32 arduino core 1.0.3 later</p> <p>For ESP32 arduino core 1.0.3 and later, AutoConnect will store credentials to Preferences in the nvs. Since it is defined as the namespace dedicated to AutoConnect and separated from the area used for user sketches. Therefore, the boundaryOffset is ignored with the combination of AutoConnect v1.0.0 or later and the arduino-esp32 1.0.3 or later.</p> <p>The AutoConnectConfig::boundaryOffset setting allows AutoConnect to write its data to EEPROM while preserving custom configuration data. Similarly, when a Sketch writes its own data to EEPROM, it must preserve the data written by AutoConnect. The EEPROM library for ESP8266 erases the entire flash sector when it writes to any part of the sector. Therefore, when writing data to EEPROM with a sketch that handles the custom data, it is necessary to call <code>EEPROM.begin</code> using a total amount of a custom data size and the saved credentials size. The following code shows how to use the AutoConnect::getEEPROMUsedSize function to store custom configuration settings in EEPROM without conflicting with AutoConnect's use of that storage.</p> <pre><code>AutoConnect       portal;\nAutoConnectConfig config;\n\n// Defines the custom data should be stored in EEPROM.\ntypedef struct {\nchar  data1[8];\nchar  data2[8];\nchar  data3[8];\n} EEPROM_CONFIG_t;\nEEPROM_CONFIG_t eepromConfig;\n...\n// Declares to reserve the EEPROM_CONFIG_t area for a Sketch using.\nconfig.boundaryOffset = sizeof(eepromConfig);\nportal.config(config);\n...\nstrcpy(eepromComfig.data1, \"data1\");\nstrcpy(eepromComfig.data2, \"data2\");\nstrcpy(eepromComfig.data3, \"data3\");\n\n// Use getEEPROMUsedSize to access the EEPROM with the appropriate region size.\nEEPROM.begin(portal.getEEPROMUsedSize());\nEEPROM.put&lt;EEPROM_CONFIG_t&gt;(0, eepromConfig);\nEEPROM.commit();\nEEPROM.end();\n...\n</code></pre>"},{"location":"adcredential.html#save-and-restore-credentials","title":"Save and restore credentials","text":"<p>AutoConnect can save stored credentials to various file systems. It is also possible to restore from those file systems. The file system can be SPIFFS, LittleFS, or SDFS. AutoConnect::saveCredential and AutoConnect::restoreCredential functions allow the sketch to save and restore credentials to files.</p> <p>Use the AutoConnect::saveCredential function to save AutoConnect credentials. This function bulk outputs while preserving AutoConnect's internal credential data structure, so this output file would be used as an input for restoring by the <code>restoreCredential</code> function. The following code snippet is an example of saving AutoConnect credentials to a file on LittleFS with ESP8266. A subsequent snippet that restores credentials saved by <code>saveCredential</code> with <code>restoreCredential</code> is also shown as an example.</p> <pre><code>#include &lt;FS.h&gt;\n#include &lt;LittleFS.h&gt;\n\n...\n\nAutoConnect portal;\n\nvoid setup() {\n  LittleFS.begin(true);\n\nif (portal.begin()) {\n    portal.saveCredential(\"/cred\", LittleFS);\n  }\n}\n</code></pre> <pre><code>#include &lt;FS.h&gt;\n#include &lt;LittleFS.h&gt;\n\n...\n\nAutoConnect portal;\nAutoConnectConfig config;\n\nvoid setup() {\n  LittleFS.begin();\n\n  config.autoReconnect = true;\n  portal.config(config);\n  portal.restoreCredential(\"/cred\", LittleFS);\n  portal.begin();\n}\n</code></pre> <p>The credentials file output by AutoConnect::saveCredential is compatible with ESP8266 and ESP32. The credentials file output by <code>saveCredential</code> is compatible with ESP8266 and ESP32, so you can output the AutoConnect credentials on ESP8266 to a portable SD and input it as AutoConnect credentials running on ESP32. To use SD for saving and restoring credentials, use the <code>saveCredential</code> and <code>restoreCredential</code> functions with template arguments as shown in the code snippet below. In this case, the template argument must specify the class name of the SD file system that is compatible with the ESP module. It is usually <code>SDClass</code> for ESP8266 or <code>fs::SDFS</code> for ESP32.</p> <pre><code>#include &lt;SPI.h&gt;\n#include &lt;SD.h&gt;\n\n...\n\nAutoConnect portal;\n\nvoid setup() {\n  SD.begin();\n\nif (portal.begin()) {\n    portal.saveCredential&lt;SDClass&gt;(\"/cred\", SDFS);   // For ESP8266\n// portal.saveCredential&lt;fs::SDFS&gt;(\"/credentials\", SDFS);  // For ESP32\n  }\n}\n</code></pre> <pre><code>#include &lt;SPI.h&gt;\n#include &lt;SD.h&gt;\n\n...\n\nAutoConnect portal;\nAutoConnectConfig config;\n\nvoid setup() {\n  SD.begin();\n\n  config.autoReconnect = true;\n  portal.config(config);\n  portal.restoreCredential&lt;SDClass&gt;(\"/cred\", SDFS);  // For ESP8266\n// portal.restoreCredential&lt;fs::SDFS&gt;(\"/credentials\", SDFS);  // For ESP32\n\n  portal.begin();\n}\n</code></pre>"},{"location":"adexterior.html","title":"Customizing page appearance","text":"<p>The design of various AutoConnect web pages is basically inflexible. Its appearance and layout don't have many customizable visual aspects but nevertheless, you can customize the following appearances of your AutoConnect web pages:</p> <ul> <li>AutoConnect menu colorize (See Appendix)</li> <li>Make different menu labels</li> <li>Make different menu title</li> <li>Capture the legacy web pages as items into the menu</li> </ul>"},{"location":"adexterior.html#make-different-menu-labels","title":"Make different menu labels","text":"<p>You can change the label text for each menu item but cannot change them at run time. There are two ways to change the label text, both of which require coding the label literal.</p> <ol> <li> <p>Overwrite the label literal of library source code directly.</p> <p>You can change the label of the AutoConnect menu item by rewriting the default label literal in AutoConnectLabels.h macros. However, changing menu items literal influences all the Sketch's build scenes.</p> <pre><code>#define AUTOCONNECT_MENULABEL_CONFIGNEW   \"Configure new AP\"\n#define AUTOCONNECT_MENULABEL_OPENSSIDS   \"Open SSIDs\"\n#define AUTOCONNECT_MENULABEL_DISCONNECT  \"Disconnect\"\n#define AUTOCONNECT_MENULABEL_RESET       \"Reset...\"\n#define AUTOCONNECT_MENULABEL_UPDATE      \"Update\"\n#define AUTOCONNECT_MENULABEL_HOME        \"HOME\"\n#define AUTOCONNECT_MENULABEL_DEVINFO     \"Device info\"\n#define AUTOCONNECT_BUTTONLABEL_RESET     \"RESET\"\n#define AUTOCONNECT_BUTTONLABEL_UPDATE    \"UPDATE\"\n</code></pre> <p>build_flags with PlatformIO will no effect</p> <p>The mistake that many people make is to use PlatformIO's build_flags to try to redefine any literal at compile time. The AutoConnect library statically contains the label literals which are embedded as binary data when compiling the library code. The label literals will not change without compiling the library source. And PlatformIO is a build system. Library sources will not be compiled unless AutoConnectLabels.h is updated.</p> </li> <li> <p>Change the label literals for each Arduino project</p> <p>Another way to change the label literal is to provide a header file that defines the label literals, as mentioned in Appendix. You can also use this method to display label text and fixed text in the local language on the AutoConnect page. See Change the item's label text section for details.</p> </li> </ol>"},{"location":"adexterior.html#make-different-menu-title","title":"Make different menu title","text":"<p>Although the default menu title is AutoConnect, you can change the title by setting AutoConnectConfig::title. To set the menu title properly, you must set before calling AutoConnect::begin.</p> <pre><code>AutoConnect       Portal;\nAutoConnectConfig Config;\n\nvoid setup() {\n// Set menu title\n  Config.title = \"FSBrowser\";\n  Portal.config(Config);\n  Portal.begin();\n}\n</code></pre> <p>Executing the above sketch will rewrite the menu title for the FSBrowser as the below.</p> <p></p>"},{"location":"adexterior.html#capture-the-legacy-web-pages-as-items-into-the-menu","title":"Capture the legacy web pages as items into the menu","text":"<p>You can embed the ordinary page processed by the ESP8266WebServer request handler as an item into the AutoConnect menu. AutoConnect can capture the legacy web pages for ESP8266WebServer or WebServer of ESP32 and extends the menu containing these items. In ordinary, the Sketch registers the request handler for the page depending on URI using the ESP8266WebServer::on function. AutoConnect allows Sketch to bundle the registered legacy page into a menu. the Sketch is able to include its URI to a menu item using AutoConnect::append function that creates internally an AutoConnectAux depended on its URI and integrates into the menu.</p> <p>The following code has a mixture of both AutoConnectAux and the legacy web page. An AutoConnectAux page is menued automatically with the AutoConnect::join or AutoConnect::load function. Similarly, a legacy page is integrated by the AutoConnect::append function.</p> <pre><code>#include &lt;ESP8266WiFi.h&gt;\n#include &lt;ESP8266WebServer.h&gt;\n#include &lt;AutoConnect.h&gt;\n\nESP8266WebServer server;\nAutoConnect      portal(server);\n\n// Definitions of AutoConnectAux page\nstatic const char PAGE[] PROGMEM = R\"(\n{\n  \"title\": \"PAGE\",\n  \"uri\": \"/page\",\n  \"menu\": true,\n  \"element\": [\n    {\n      \"name\": \"cap\",\n      \"type\": \"ACText\",\n      \"value\": \"This is a custom web page.\"\n    }\n  ]\n}\n)\";\n\nvoid setup() {\n// The Web page handler located to /hello\n  server.on(\"/hello\", [](){\n    server.send(200, \"text/html\", String(F(\n\"&lt;html&gt;\"\n\"&lt;head&gt;&lt;meta name='viewport' content='width=device-width,initial-scale=1.0'&gt;&lt;/head&gt;\"\n\"&lt;body&gt;&lt;h2&gt;Hello, world&lt;/h2&gt;&lt;/body&gt;\"\n\"&lt;/html&gt;\"\n    )));\n  });\n\n  portal.append(\"/hello\", \"HELLO\");  // Adds an item as HELLO into the menu\n  portal.load(FPSTR(PAGE));               // Load AutoConnectAux custom web page\n  portal.begin();\n}\n\nvoid loop() {\n  portal.handleClient();\n}\n</code></pre> <p></p> <p>The AutoConnect::append function also has the third parameter that directly specifies the request handler. It has similar efficacy to calling the append and <code>ESP8266WebSever::on</code> at once. 1</p> <pre><code>portal.append(\"/hello\", \"HELLO\", [](){\n  server.send(200, \"text/html\", String(F(\n\"&lt;html&gt;\"\n\"&lt;head&gt;&lt;meta name='viewport' content='width=device-width,initial-scale=1.0'&gt;&lt;/head&gt;\"\n\"&lt;body&gt;&lt;h2&gt;Hello, world&lt;/h2&gt;&lt;/body&gt;\"\n\"&lt;/html&gt;\"\n  )));\n});\n</code></pre> <p>For more details, see section Attach the menus of Examples page.</p> <p>An instance of ESP8266WebServer/WebServer is needed</p> <p>When calling the append function with request handler parameters, an instance of the WebServer as the registration destination must exist. AutoConnect can instantiate and host a WebServer internally, but in that case, the point in time to call the AutoConnect::append function with a request handler parameter must be after AutoConnect::begin.</p> <ol> <li> <p>However, the pages registered this way remain legacy. Therefore, the AutoConnect menu bar is not appeared.\u00a0\u21a9</p> </li> </ol>"},{"location":"adnetwork.html","title":"Settings and controls for network and WiFi","text":"<p>AutoConnect allows you to make the static configuration of SoftAP at runtime. Its configuration includes the identification information on the network such as the IP address and the access path of the Web page handled by AutoConnect etc. In addition, the mDNS service allows SoftAP to be accessed by hostname on the local network. The configuration settings for the network that can be set by AutoConnect is as follows:</p> <ul> <li>404 handler</li> <li>Assign user sketch's home path</li> <li>Change SSID and Password for SoftAP</li> <li>Combination with mDNS</li> <li>Make SSID of SoftAP unique</li> <li>Relocate the AutoConnect home path</li> <li>SoftAP access point IP settings</li> <li>Static IP assignment as a client</li> <li>Static IP preservation</li> <li>Station hostname</li> </ul>"},{"location":"adnetwork.html#404-handler","title":"404 handler","text":"<p>AutoConnect cannot allow the Sketch registers the \"Not-found\" handler (404-handler) to the ESP8266WebServer natively. AutoConnect traps Not-found handler of the ESP8266WebServer for its own page processing. If the Sketch overrides the Not-found handler, AutoConnect will miss the opportunity to control the HTTP session and becomes unresponsive to the menu. Registering the Not-found handler is a different method than for ESP8266WebServer, use AutoConnect::onNotFound. This restriction applies to the WebServer for ESP32 as well.</p>"},{"location":"adnetwork.html#assign-user-sketchs-home-path","title":"Assign user sketch's home path","text":"<p>HOME for returning to the user's sketch homepage will display at the bottom of the AutoConnect menu. It could be set using the AutoConnect::home function.</p> <p></p> <p>The Sketch HOME path is closely related to the bootUri that specifies the access path on module restart. AutoConnect has the following three parameters concerning control the URIs:</p> <ul> <li>AUTOCONNECT_URI     The ROOT URI of AutoConnect. It is defined in <code>AutoConnectDefs.h</code> file and is assigned to AutoConnect statistics screen by default.</li> <li>AutoConnectConfig::homeUri     It is the hyperlink of listed on the AutoConnect menu as HOME.</li> <li>AutoConnectConfig::bootUri     Which page appears at the captive portal, <code>AUTOCONNECT_URI</code>, or the homeUri. Its page will pop up automatically when you visit the captive portal.</li> </ul> The definition of HOME Behavior Specified by Default value Possible value ROOT of AutoConnect Default for AC_ONBOOTURI_ROOT <code>#define AUTOCONNECT_URI</code> in <code>AutoConnectDefs.h</code> <code>/_ac</code> URI string HOME for Application-specific Listed on the menu list as HOMEAlso, It may be linked from the menu title and is redundant with the HOME menu item.eg. Case of bootURI = AC_ONBOOTURI_HOME AutoConnectConfig::homeURI <code>/</code> URI string Which page loads at the boot time, ROOT or HOME Appears after module reboot by RESET button with AutoConnect menu AutoConnectConfig::bootURI AC_ONBOOTURI_ROOT AC_ONBOOTURI_HOME Which page appears at the captive portal, ROOT or HOME Auto pop-up AutoConnectConfig::bootURI AC_ONBOOTURI_ROOT AC_ONBOOTURI_HOME"},{"location":"adnetwork.html#change-ssid-and-password-for-softap","title":"Change SSID and Password for SoftAP","text":"<p>An esp8266ap is default SSID name for SoftAP of captive portal and password is 12345678 for ESP8266. Similarly, esp32ap and 12345678 for ESP32. You can change both by setting apid and psk.</p> <pre><code>AutoConnect portal;\nAutoConnectConfig config;\n\nvoid setup() {\n config.apid = \"ap_portal\";\n  config.psk  = \"new_password\";\n  portal.config(config);\n  portal.begin();\n}\n</code></pre> <p>Also, you can specify the SSID, password for SoftAP with the constructor of the AutoConnectConfig as below.</p> <pre><code>AutoConnect portal;\nAutoConnectConfig config(\"ap_portal\", \"new_password\");\nvoid setup() {\n  portal.config(config);\n  portal.begin();\n}\n</code></pre> <p>You can also assign no password to SoftAP launched as a captive portal. Assigning a null string as <code>String(\"\")</code> to AutoConnectConfig::psk does not require a password when connecting to SoftAP. But this method is not recommended. The broadcast radio of SSID emitted from SoftAP will leak and reach several tens of meters.</p>"},{"location":"adnetwork.html#combination-with-mdns","title":"Combination with mDNS","text":"<p>With mDNS library, you can access to ESP8266 by name instead of IP address after connection. The Sketch can start the MDNS responder after AutoConnect::begin.</p> <pre><code>#include &lt;ESP8266WiFi.h&gt;\n#include &lt;ESP8266mDNS.h&gt;\n#include &lt;ESP8266WebServer.h&gt;\nAutoConnect Portal;\nvoid setup() {\nif (Portal.begin()) {\nif (MDNS.begin(\"esp8266\")) {\n      MDNS.addService(\"http\", \"tcp\", 80);\n    }\n  }\n}\n\nvoid loop() {\n  Portal.handleClient();\n}\n</code></pre>"},{"location":"adnetwork.html#make-ssid-of-softap-unique","title":"Make SSID of SoftAP unique","text":"<p>You can change SoftAP's SSID and password programmatically when the captive portal starts up. By using chip specific ID of esp8266/esp32 you can make SSID of SoftAP unique. SSID and password for SoftAP is AutoConnectConfig::apid and AutoConnectConfig::psk.</p> <pre><code>AutoConnect       portal;\nAutoConnectConfig acConfig;\n\nacConfig.apid = \"ESP-\" + String(ESP.getChipId(), HEX);\naConfig.psk = YOUR_PASSWORD;\nportal.config(acConfig);\nportal.begin();\n</code></pre> <p>Obtaining chip ID for ESP32</p> <p><code>acConfig.apid = \"ESP-\" + String((uint32_t)(ESP.getEfuseMac() &gt;&gt; 32), HEX);</code></p>"},{"location":"adnetwork.html#relocate-the-autoconnect-home-path","title":"Relocate the AutoConnect home path","text":"<p>A home path of AutoConnect is /_ac by default. You can access from the browser with <code>http://IPADDRESS_OF_ESP_MODULE/_ac</code>. You can change the home path by revising AUTOCONNECT_URI macro in <code>AutoConnectDefs.h</code> header file.</p> <pre><code>#define AUTOCONNECT_URI         \"/_ac\"\n</code></pre>"},{"location":"adnetwork.html#softap-access-point-ip-settings","title":"SoftAP access point IP settings","text":"<p>AutoConnect will activate SoftAP at failed the 1st-WiFi.begin. Its SoftAP settings are stored in AutoConnectConfig as the following parameters. The Sketch could be configured SoftAP using these parameters, refer the AutoConnectConfig API for details.</p> AutoConnectConfig member Settings for Defined symbol Initial value apip SoftAP IP address AUTOCONNECT_AP_IP 172.217.28.1 gateway Gateway IP address AUTOCONNECT_AP_GW 172.217.28.1 netmask Subnet mask for the SoftAP AUTOCONNECT_AP_NM 255.255.255.0 channel WiFi channel for the SoftAP AUTOCONNECT_AP_CH 1 hidden Hide the SoftAP false"},{"location":"adnetwork.html#static-ip-assignment-as-a-client","title":"Static IP assignment as a client","text":"<p>It is possible to assign a static IP Address to ESP8266/ESP32 in STA mode.1 By default DHCP is enabled and it becomes the IP address assigned by the DHCP server with WiFi.begin.</p> <p>These settings are made via AutoConnectConfig as in the case of SoftAP settings. To assign a static IP to ESP8266/ESP32 with WIFI_STA, the following parameters are required:</p> AutoConnectConfig member Settings for Initial value staip Station IP address 0.0.0.0 staGateway Gateway address for the station 0.0.0.0 staNetmask Subnet mask for the the station 0.0.0.0 dns1 Primary DNS server IP address 0.0.0.0 dns2 Secondary DNS server IP address 0.0.0.0 <p>The above parameters must be set using AutoConnect::config prior to AutoConnect::begin call as following:</p> <pre><code>AutoConnect        portal;\nAutoConnectConfig  Config;\nConfig.staip = IPAddress(192, 168, 1, 10);\nConfig.staGateway = IPAddress(192, 168, 1, 1);\nConfig.staNetmask = IPAddress(255, 255, 255, 0);\nConfig.dns1 = IPAddress(192,168,1,1);\nportal.config(Config);\nportal.begin();\n</code></pre>"},{"location":"adnetwork.html#static-ip-preservation","title":"Static IP preservation","text":"<p>Prioritizing the station IP configuration specified in AutoConnectConfig over the existing configuration must be accompanied by an explicit indication via the AutoConnectConfig::preserveIP. The AutoConnectConfig::preserveIP setting allows AutoConnect to override existing credentials applied at reconnecting with static IP assignments made with the AutoConnectConfig::staip, AutoConnectConfig::staGateway, and AutoConnectConfig::staNetmask settings. The following sketch shows a use case where the preserveIP setting can override an existing static IP configuration.</p> <pre><code>AutoConnect portal;\nAutoConnectConfig config;\n\nvoid setup() {\n// If the connection to the last established AP fails, attempt to\n// connect to the nearest AP using known credentials.\n  config.autoReconnect = true;\n\n// Apply the following static IP configuration to reconnect.\n  config.staip = IPAddress(192, 168, 1, 10);\n  config.staGateway = IPAddress(192, 168, 1, 1);\n  config.staNetmask = IPAddress(255, 255, 255, 0);\n  config.dns1 = IPAddress(192, 168, 1, 1);\n\n// The above settings take precedence over the IP settings of the\n// stored credentials.\n// If this value is left false, the station IP configuration contained\n// in the stored credentials takes precedence.\n  config.preserveIP = true;\n  portal.config(config);\n  portal.begin();\n}\n\nvoid loop() {\n  portal.handleClient();\n}\n</code></pre> <p>Also, an example sketch with UI for static IP configuration using custom web pages is included in the AutoConnect repository as ConfigIP.ino.  This example is useful for overwriting stored IP settings with new IP settings entered from the UI.</p> <p>Background on the need for preserveIP indication</p> <p>By default, AutoConnectConfig::autoReconnect restores IP settings along with a credential. So even if the sketch explicitly specifies the static IP settings with AutoConnectConfig, there are cases where they will not be applied upon reconnection.</p>"},{"location":"adnetwork.html#station-hostname","title":"Station hostname","text":"<p>AutoConnectConfig::hostName assigns a station DHCP hostname to the ESP module. The hostname must satisfy RFC952 compliant and meet the following restrictions:</p> <ul> <li>Up to 24 characters</li> <li>Only the alphabet (a-z, A-Z), digits (0-9), minus sign (-)</li> <li>No '-' as last character</li> </ul> <ol> <li> <p>Static IP address assignment is available from version 0.9.3.\u00a0\u21a9</p> </li> </ol>"},{"location":"adothers.html","title":"Other operation settings and controls","text":"<p>AutoConnect also has features that are not directly related to WiFi connection abilities. They're mostly like a little accessory but can reduce the amount of sketch code. </p> <ul> <li>Built-in OTA update</li> <li>Choice of the filesystem for ESP8266</li> <li>Debug Print</li> <li>File uploading via built-in OTA feature</li> <li>Refers the hosted ESP8266WebServer/WebServer</li> <li>Reset the ESP module after disconnecting from WLAN</li> <li>Ticker for WiFi status</li> <li>Usage for automatically instantiated ESP8266WebServer/WebServer</li> <li>Use with the PageBuilder library</li> </ul>"},{"location":"adothers.html#built-in-ota-update-feature","title":"Built-in OTA update feature","text":"<p>AutoConnect features a built-in OTA function to update ESP module firmware. You can easily make the Sketch that equips OTA and able to operate with the AutoConnect menu.</p> <p></p> <p>AutoConnectConfig::ota specifies to import the built-in OTA update class into the Sketch. See the Updates with the Web Browser chapter for details.</p>"},{"location":"adothers.html#choice-of-the-filesystem-for-esp8266","title":"Choice of the filesystem for ESP8266","text":"<p>For ESP8266, since the Arduino core v2.7.0, SPIFFS has deprecated and the migration to LittleFS is being promoted currently. AutoConnect has adopted LittleFS as the default filesystem to follow the core standard.</p> <p>However, SPIFFS is still valid. AutoConnect can correctly compile and execute sketches made with SPIFFS assumed. When you make an AutoConnect sketch with SPIFFS enabled, you need to change the macro definition that <code>AutoConnectDefs.h</code> has. AC_USE_SPIFFS definition will enable SPIFFS as the filesystem.</p> <pre><code>#define AC_USE_SPIFFS\n</code></pre> <p>See also the FAQ to help you enable AC_USE_SPIFFS correctly. Note that refers to the Using Filesystem chapter to know the utilization capabilities of the file system with AutoConnect.</p>"},{"location":"adothers.html#debug-print","title":"Debug Print","text":"<p>You can output AutoConnect monitor messages to the Serial. A monitor message activation switch is in an include header file <code>AutoConnectDefs.h</code> of library source. Define AC_DEBUG macro to output the monitor messages.1</p> <pre><code>#define AC_DEBUG\n</code></pre> <p>AutoConnect does not automatically start the Serial even if AC_DEBUG is activated. The Sketch should start the Serial during its setup phase using <code>Serial.begin(BAUDRATE)</code>.</p> <p>How to enable AC_DEBUG</p> <p>The #define is a C++ preprocessor directive. The build process of the Sketch by the Arduino IDE is processed independently of the subsequent C++ compilation unit. Writing the #define directive for AC_DEBUG in the Sketch has no effect on the AutoConnect library. To compile the AutoConnect library with the AC_DEBUG directive, you can either edit the library source code directly (usually it is located in ~/Arduino/libraries/AutoConnect/src) or use a build system which can configure the preprocessor directives externally such as PlatformIO. To enable AC_DEBUG using PlatformIO without modifying the library source, specify the <code>build_flags</code> directive in the <code>platformio.ini</code> file with each project. <pre><code>build_flags = -DAC_DEBUG\n</code></pre></p>"},{"location":"adothers.html#file-uploading-via-built-in-ota-feature","title":"File uploading via built-in OTA feature","text":"<p>The built-in OTA update feature can update the firmware as well as upload regular files placed in the file system on the ESP module. It allows a regular file is uploaded via OTA using the Update of AutoConnect menu without adding a particular custom Web page that contains AutoConnectFile. This ability is useful for transferring the JSON document of the custom web page definition, the external parameter file of your sketch, and so on into the target ESP module via OTA.</p> <p>The built-in OTA update feature determines where to save the uploaded file according to the filename pattern. By default, a filename with ends a <code>.bin</code> extension is subject to firmware updates. A file that has the other extension will be saved as a regular to the filesystem in the flash. The file extension that should be treated as the firmware is defined as the <code>AUTOCONNECT_UPLOAD_ASFIRMWARE</code> macro in AutoConnectDefs.h header file of the library source code. When dealing with another extension for the updating file as firmware change this macro definition.</p> <pre><code>#define AUTOCONNECT_UPLOAD_ASFIRMWARE \".bin\"\n</code></pre> <p>Specify with the PlatformIO</p> <p><code>AUTOCONNECT_UPLOAD_ASFIRMWARE</code> pattern will be embedded into the binary sketch is determined at compile time. The PlatformIO build system allows you to change the pattern expression for each project without modifying the library source code.</p> <pre><code>build_flags=-DAUTOCONNECT_UPLOAD_ASFIRMWARE='\".bin\"'\n</code></pre>"},{"location":"adothers.html#refers-the-hosted-esp8266webserverwebserver","title":"Refers the hosted ESP8266WebServer/WebServer","text":"<p>Constructing an AutoConnect object variable without parameters then creates and starts an ESP8266WebServer/WebServer inside the AutoConnect. This object variable could be referred by AutoConnect::host function to access ESP8266WebServer/WebServer instance as like below.</p> <pre><code>AutoConnect Portal;\n\nPortal.begin();\nESP8266WebServer&amp; server = Portal.host();\nserver.send(200, \"text/plain\", \"Hello, world\");\n</code></pre> <p>When host() is valid</p> <p>The host() can be referred at after AutoConnect::begin.</p>"},{"location":"adothers.html#reset-the-esp-module-after-disconnecting-from-wlan","title":"Reset the ESP module after disconnecting from WLAN","text":"<p>Disconnect by menu operation allows the ESP8266/ESP32 module to reset automatically after disconnecting from WLAN. This behavior is enabled by default and can be disabled by AutoConnectConfig::autoReset settings.</p> <pre><code>AutoConnect       Portal;\nAutoConnectConfig Config;\nConfig.autoReset = false; // Continue sketch processing even after disconnecting from by AutoConnect menu.\nPortal.config(Config);\nPortal.begin();\n</code></pre> <p>The autoReset setting will automatically reset the ESP module when disconnecting WiFi only if you intentionally navigate the menu. And it does not participate in passive disconnection conditions such as disconnection due to sketch processing or loss of WiFi signal. </p> <p>You can combine autoReset with autoReconnect to disconnect from WiFi and automatically reconnect to another AP while continuing the Sketch operation.</p> <p>The Sketch below shows an example of a  meaningful combination of autoReset and autoReconnect. It can connect to the access point once with the captive portal but assumes that it can be disconnected from the WLAN by intentional menu navigation. In that case, the Sketch will continue processing without resetting the module. Then an external switch allows to start automatic reconnecting. In this situation, if known access points appear nearby, the ESP module will automatically reconnect to them in the handleClient loop. In this state transition, the module continues the Sketch process without resetting.</p> <pre><code>AutoConnect       Portal;\nAutoConnectConfig Config;\n\nconst int reconnectSwitch = 14; // Assign the reconnect switch to GPIO14\n\nICACHE_RAM_ATTR void detectsReconnect() {\nif (!Config.autoReconnect) {  // Chattering elimination\n// autoReconnect is enabled by interrupt of the GPIO trigger,\n    Config.autoReconnect = true;  // Activate reconnection\n    Config.reconnectInterval = 2; // Attempt to reconnect at 60 seconds intervals.\n    Portal.config(Config);\n    Serial.printf(\"Turn on autoReconnect, interval %d[s]\\n\", Config.reconnectInterval * AUTOCONNECT_UNITTIME);\n  }\n}\n\nvoid setup() {\n  delay(1000);\n  Serial.begin(115200);\n  Serial.println();\n\n  Config.ticker = true;   // Setting up WiFi connection indicator\n  Portal.config(Config);  \n\nif (Portal.begin()) {\n    Config.autoReset = false;\n    Portal.config(Config);\n\n// Set external switch pin to reconnect as interrupt, assign interrupt function and set RISING mode\n    pinMode(reconnectSwitch, INPUT_PULLUP);\n    attachInterrupt(digitalPinToInterrupt(reconnectSwitch), detectsReconnect, RISING);\n  }\n}\n\nvoid loop() {\nif (WiFi.status() == WL_CONNECTED) {\n/*\n    Here, your sketch process with WiFi connection\n    */\n  }\nelse {\n/*\n    Here, your sketch process without WiFi connection\n    */\n  }\n\n// Post process, turn to initial state of autoReconnect.\nif (Config.autoReconnect) {\nif (WiFi.status() == WL_CONNECTED) {\n      Config.autoReconnect = false;\n      Portal.config(Config);\n    }\n  }\n\n// The actual reconnection takes place within handleClient.\n  Portal.handleClient();\n}\n</code></pre> <p>An external switch wiring to GPIO</p> <p>The wiring for the above Sketch assumes a momentary effects switch that connects the GPIO pin 14 to GND. You can experience it with easily wire on a breadboard using a NodeMCU as like:</p> <p></p>"},{"location":"adothers.html#ticker-for-wifi-status","title":"Ticker for WiFi status","text":"<p>Flicker signal can be output from the ESP8266/ESP32 module according to WiFi connection status. By wiring the LED to the signal output pin with the appropriate limiting resistor, you can know the WiFi connection status through the LED blink during the inside behavior of AutoConnect::begin and loop of AutoConnect::handleClient.</p> <p>AutoConnectConfig::ticker option specifies flicker signal output. The following sketch is an example of blinking the active-low LED connected to <code>GPIO16</code> depending on the WiFi connection status.2</p> <pre><code>AutoConnect        portal;\nAutoConnectConfig  Config;\nConfig.ticker = true;\nconfig.tickerPort = 16;\nConfig.tickerOn = LOW;\nportal.config(Config);\nportal.begin();\n</code></pre> <p>The AutoConnect ticker indicates the WiFi connection status in the following three flicker patterns:</p> <ul> <li>Short blink: The ESP module stays in AP_STA mode.</li> <li>Short-on and long-off: No STA connection state. (i.e. WiFi.status != WL_CONNECTED)</li> <li>No blink: WiFi connection with access point established and data link enabled. (i.e. WiFi.status = WL_CONNECTED)</li> </ul> <p>The flicker cycle length is defined by some macros in <code>AutoConnectDefs.h</code> header file.</p> <pre><code>#define AUTOCONNECT_FLICKER_PERIODAP  1000 // [ms]\n#define AUTOCONNECT_FLICKER_PERIODDC  (AUTOCONNECT_FLICKER_PERIODAP &lt;&lt; 1) // [ms]\n#define AUTOCONNECT_FLICKER_WIDTHAP   96  // (8 bit resolution)\n#define AUTOCONNECT_FLICKER_WIDTHDC   16  // (8 bit resolution)\n</code></pre> <ul> <li>AUTOCONNECT_FLICKER_PERIODAP:   Assigns a flicker period when the ESP module stays in AP_STA mode.</li> <li>AUTOCONNECT_FLICKER_PERIODDC:   Assigns a flicker period when WiFi is disconnected.</li> <li>AUTOCONNECT_FLICKER_WIDTHAP and AUTOCONNECT_FLICKER_WIDTHDC:   Specify the duty rate for each period [ms] in 8-bit resolution.</li> </ul> <p>Ticker during OTA</p> <p>The LED blinking will always be a short blinking during the update via OTA, regardless of the definition of the flicker cycle.</p> <p>AutoConnectConfig::tickerPort specifies a port that outputs the flicker signal. If you are using an LED-equipped ESP module board, you can assign a LED pin to the tick-port for the WiFi connection monitoring without the external LED. The default pin is arduino valiant's LED_BUILTIN. You can refer to the Arduino IDE's variant information to find out which pin actually on the module assign to LED_BUILTIN.3</p> <p>AutoConnectConfig::tickerOn specifies the active logic level of the flicker signal. This value indicates the active signal level when driving the ticker. For example, if the LED connected to tickPort lights by LOW, the tickerOn is LOW. The logic level of LED_BUILTIN for popular modules are as follows:</p> module Logic level LED_BUILTIN Pin Arduino alias NodeMCU V1.0 Active-low 16 D0 WEMOS D1 mini Active-low 2 D4 SparkFun ESP8266 Thing Active-high 5 Adafruit Feather HUZZAH ESP8266 Active-low 0 NodeMCU 32s Active-high 2 T2 LOLIN32 Pro Active-low 5 SS SparkFun ESP32 Thing Active-high 5 Adafruit Feather HUZZAH32 Active-high 13 A12"},{"location":"adothers.html#usage-for-automatically-instantiated-esp8266webserverwebserver","title":"Usage for automatically instantiated ESP8266WebServer/WebServer","text":"<p>The Sketch can handle URL requests using ESP8266WebServer or WebServer that AutoConnect started internally. ESP8266WebServer/WebServer instantiated dynamically by AutoConnect can be referred to by AutoConnect::host function. The Sketch can use the 'on' function, 'send' function, 'client' function and others by ESP8266WebServer/WebServer reference of its return value.</p> <pre><code>#include &lt;ESP8266WiFi.h&gt;\n#include &lt;ESP8266WebServer.h&gt;\n#include &lt;AutoConnect.h&gt;\n\nAutoConnect       Portal;\n\nvoid handleRoot() {\n  ESP8266WebServer&amp; IntServer = Portal.host();\n  IntServer.send(200, \"text/html\", \"Hello, world\");\n}\n\nvoid handleNotFound() {\n  ESP8266WebServer&amp; IntServer = Portal.host();\n  IntServer.send(404, \"text/html\", \"Unknown.\");\n}\n\nvoid setup() {\nbool r = Portal.begin();\nif (r) {\n    ESP8266WebServer&amp; IntServer = Portal.host();\n    IntServer.on(\"/\", handleRoot);\n    Portal.onNotFound(handleNotFound);    // For only onNotFound.\n  }\n}\n\nvoid loop() {\n  Portal.host().handleClient();\n  Portal.handleRequest();\n/* or following one line code is equ.\n  Portal.handleClient();\n  */\n}\n</code></pre> <p>ESP8266WebServer/WebServer function should be called after AutoConnect::begin</p> <p>The Sketch cannot refer to an instance of ESP8266WebServer/WebServer until AutoConnect::begin completes successfully.</p> <p>Do not use with ESP8266WebServer::begin or WebServer::begin</p> <p>ESP8266WebServer/WebServer is already running inside the AutoConnect.</p>"},{"location":"adothers.html#use-with-the-pagebuilder-library","title":"Use with the PageBuilder library","text":"<p>In ordinary, the URL handler will respond to the request from the client by sending some HTML. It will dynamically generate the HTML to respond to based on the sensing data etc. for the changing scene, but it contains elements of variable values in the middle of the HTML fixed string. Therefore, sketches tend to be in a tangled that repeats the logic for data handling and string splicing in turn, which tends to be less readable and maintainable.</p> <p>PageBuilder library is an HTML assembly aid. it can handle predefined HTML like the template and simplify an HTML string assemble logic, and also the generated HTML send automatically.</p> <p>An example sketch used with the PageBuilder as follows and it explains how it aids for the HTML generating. Details for GitHub repository.</p> <p></p> <ol> <li> <p>The source code placement of common macros for AutoConnect since v0.9.7 has changed.\u00a0\u21a9</p> </li> <li> <p>The ESP module pin mapping is different for each breakout. Definitions for assigning pin numbers to pin names usually exist in the variant definition program of Arduino core packages. (e.g. esp8266/arduino core, arduino-esp32 core) You may find the definition as <code>pins_arduino.h</code>.\u00a0\u21a9</p> </li> <li> <p>It's defined in the <code>pins_arduino.h</code> file, located in the sub-folder named variants wherein Arduino IDE installed folder.\u00a0\u21a9</p> </li> </ol>"},{"location":"advancedusage.html","title":"Advanced usage","text":""},{"location":"advancedusage.html#summary","title":"Summary","text":"<p>To make sketches work as you intended with AutoConnect, make sure you understand the implications of the setting parameters and configure AutoConnect. AutoConnectConfig allows you to incorporate settings into AutoConnect that coordinate control over WiFi connectivity and captive portal behavior. For advanced usages, the configuration settings and the Sketch examples are followings:</p> <ul> <li>AutoConnect WiFi connection control</li> <li>Captive portal control</li> <li>Authentication settings</li> <li>Credential accesses</li> <li>Settings for customizing the page exterior</li> <li>Settings and controls for network and WiFi</li> <li>Other operation settings and controls</li> </ul> <p>Don't forget AutoConnect::config</p> <p>The configuration cannot be reflected by only changing the member variables of AutoConnectConfig settings. It will be reflected in the actual ones by AutoConnect::config function. Don't forget to run the AutoConnect::config after changing the AutoConnectConfig member variables.</p> <pre><code>AutoConnect portal;\nAutoConnectConfig config;\n\nvoid setup() {\n  config.autoReconnect = true;\n  portal.config(config);  // Don't forget.\n  portal.begin();\n}\n</code></pre>"},{"location":"api.html","title":"AutoConnect API","text":""},{"location":"api.html#include-headers","title":"Include headers","text":"<p>The AutoConnect class is limited in its available APIs by the AutoConnect component it contains. The <code>AutoConnect.h</code> header file makes all AutoConnect features available. On the other hand, the <code>AutoConnectCore.h</code> header file does not include extensions such as custom web pages or OTAs; AutoConnectCore.h reduces memory consumption by limiting functionality to WiFi connectivity utilities only. See the Reducing Binary Size chapter for details.</p>"},{"location":"api.html#autoconnecth","title":"AutoConnect.h","text":"<pre><code>#include &lt;AutoConnect.h&gt;\n</code></pre> <p><code>AutoConnect.h</code> header file provides all AutoConnect features.</p>"},{"location":"api.html#autoconnectcoreh","title":"AutoConnectCore.h","text":"<pre><code>#include &lt;AutoConnectCore.h&gt;\n</code></pre> <p><code>AutoConnectCore.h</code> header file provides the AutoConnect class that excludes Custom Web pages and OTA-related components of the AutoConnect features. When you include this header in your sketch, you cannot use the AutoConnectAux, AutoConnectElements, AutoConnectOTA, and AutoConnectUpdate classes.</p>"},{"location":"api.html#defined-macros","title":"Defined macros","text":"<p>They contain in <code>AutoConnectDefs.h</code>.</p> <pre><code>#define AC_USE_SPIFFS                           // Use SPIFFS for the file system on the onboard flash\n#define AC_USE_LITTLEFS                         // Use LittleFS for the file system on the onboard fash\n#define AC_DEBUG                                // Monitor message output activation\n#define AC_DEBUG_PORT           Serial          // Default message output device\n#define AUTOCONNECT_AP_IP       0x011CD9AC      // Default SoftAP IP\n#define AUTOCONNECT_AP_GW       0x011CD9AC      // Default SoftAP Gateway IP\n#define AUTOCONNECT_AP_NM       0x00FFFFFF      // Default subnet mask\n#define AUTOCONNECT_DNSPORT     53              // Default DNS port at captive portal\n#define AUTOCONNECT_HTTPPORT    80              // Default HTTP\n#define AUTOCONNECT_MENU_TITLE  \"AutoConnect\"   // Default AutoConnect menu title\n#define AUTOCONNECT_URI         \"/_ac\"          // Default AutoConnect root path\n#define AUTOCONNECT_TIMEOUT     30000           // Default connection timeout[ms]\n#define AUTOCONNECT_CAPTIVEPORTAL_TIMEOUT  0    // Captive portal timeout value\n#define AUTOCONNECT_STARTUPTIME 30              // Default waiting time[s] for after reset\n#define AUTOCONNECT_USE_JSON                    // Allow AutoConnect elements to be handled by JSON format\n#define AUTOCONNECT_USE_UPDATE                  // Indicator of whether to use the AutoConnectUpdate feature.\n#define AUTOCONNECT_UPDATE_PORT 8000            // Available HTTP port number for the update\n#define AUTOCONNECT_UPDATE_TIMEOUT  8000        // HTTP client timeout limitation for the update [ms]\n#define AUTOCONNECT_TICKER_PORT LED_BUILTIN     // Ticker port\n#endif\n</code></pre> <p>Macros placement moved</p> <p>Source code placement of the above macros provided for user sketch changed from v0.9.7. The new code is in <code>AutoConnectDefs.h</code>.</p>"},{"location":"api.html#constructors","title":"Constructors","text":""},{"location":"api.html#autoconnect","title":"AutoConnect","text":"<pre><code>AutoConnect()\n</code></pre> <p>AutoConnect default constructor. This entry internally allocates the ESP8266WebServer for ESP8266 or WebServer for ESP32 and is activated internally.</p> <p>AutoConnect will call the user added handler to respond to the HTTP request using the ESP8266WebServer::on (WebServer::on for ESP32) funtion. This call will be made from during the handleClient of AutoConnect function. Therefore, in the use case of assigning AutoConnect in this constructor, it is necessary to know the instance of ESP8266WebServer in order to register the request handler. Sketch can use host functions to obtain a reference to an ESP8266WebServer instance that is internally hosted by AutoConnect.</p> <ul> <li>For ESP8266</li> </ul> <pre><code>AutoConnect(ESP8266WebServer&amp; webServer)\n</code></pre> <ul> <li>For ESP32</li> </ul> <pre><code>AutoConnect(WebServer&amp; webServer)\n</code></pre> <p>Run the AutoConnect site using the externally ensured ESP8266WebServer for ESP8266 or WebServer for ESP32. Parameter webServerA reference of ESP8266WebServer or WebServer instance.</p>"},{"location":"api.html#public-member-functions","title":"Public member functions","text":""},{"location":"api.html#append","title":"append","text":"<ul> <li>ESP8266/ESP32 Common</li> </ul> <pre><code>AutoConnectAux* append(const String&amp; uri, const String&amp; title)\n</code></pre> <ul> <li>For ESP8266</li> </ul> <pre><code>AutoConnectAux* append(const String&amp; uri, const String&amp; title, ESP8266WebServer::THandlerFunction handler)\n</code></pre> <ul> <li>For ESP32</li> </ul> <pre><code>AutoConnectAux* append(const String&amp; uri, const String&amp; title, WebServer::THandlerFunction handler)\n</code></pre> <p>Creates an AutoConnectAux dynamically with the specified URI and integrates it into the menu. Calls with a request handler parameter can use this function as menu registration for a legacy page of ESP8266WebServer/WebServer. If the handler parameter specified, also it will register the request handler for the ESP8266WebServer/WebServer. AutoConnect manages the menu items using a sequence list, and this function always adds the item to the end of the list. Therefore, the order of the menu items is the additional order. Returns the pointer to created AutoConnectAux instance, the <code>nullptr</code> if an AutoConnectAux with the same URI already exists. Parameter uriA string of the URI. titleTitle for menu item. handlerRequest handler function as type of ESP8266WebServer::THandlerFunction/WebServer::THandlerFunction. Return value A Pointer to a created AutoConnectAux instance.</p> <p>An instance of ESP8266WebServer/WebServer is needed</p> <p>The WebServer must have instantiated for calling with a request handler parameter. AutoConnect can instantiate and host a WebServer internally, but in that case, the point in time to call the append function with a request handler parameter must be after AutoConnect::begin.</p>"},{"location":"api.html#aux","title":"aux","text":"<pre><code>AutoConnectAux* aux(const String&amp; uri) const\n</code></pre> <p>Returns a pointer to AutoConnectAux with the URI specified by uri. If AutoConnectAux with that URI is not bound, it returns nullptr. Parameter uriA string of the URI. Return value A Pointer of the AutoConnectAux instance. </p>"},{"location":"api.html#begin","title":"begin","text":"<pre><code>bool begin()\n</code></pre> <pre><code>bool begin(const char* ssid, const char* passphrase)\n</code></pre> <pre><code>bool begin(const char* ssid, const char* passphrase, unsigned long timeout)\n</code></pre> <p>Starts establishing the WiFi connection. The WiFi mode at this time is WIFI_STA. AutoConnect first invokes WiFi.begin. If the ssid and the passphrase are missing, its WiFi.begin has no SSID and Password. Regardless of the result, ESP8266WebServer/WebServer will start immediately after the first WiFi.begin. The captive portal will not be started if the connection has been established with first WiFi.begin. If the connection cannot establish, switch to WIFI_AP_STA mode and activate SoftAP. Then DNS server starts. Parameters ssidSSID to be connected. passphrasePassword for connection. timeoutA time out value in milliseconds for waiting connection. Return value trueConnection established, AutoConnect service started with WIFI_STA mode. falseCould not connected, Captive portal started with WIFI_AP_STA mode.</p>"},{"location":"api.html#config","title":"config","text":"<pre><code>bool config(AutoConnectConfig&amp; config)\n</code></pre> <pre><code>bool config(const char* ap, const char* password = nullptr)\n</code></pre> <p>Set AutoConnect configuration settings. Parameters configReference to AutoConnectConfig containing SoftAP's parameters and static IP parameters. apSSID for SoftAP. The default value is esp8266ap for ESP8266, esp32ap for ESP32. passwordPassword for SodtAP. The default value is 12345678. Return value trueSuccessfully configured. falseConfiguration parameter is invalid, some values out of range.</p>"},{"location":"api.html#detach","title":"detach","text":"<pre><code>bool detach(const String&amp; uri)\n</code></pre> <p>Detach the AutoConnectAux with the specified URI from the management of AutoConnect. An unmanaged AutoConnectAux will no longer appear in menu items, and its page handler will no longer respond even if the URI is accessed directly. Parameter uriURI of AutoConnectAux to be detached. Return value trueSuccessfully detached. falseAn AutoConnectAux with the specified URI does not exist.</p> <p>If the request handler registered in the detaching AutoConnectAux is for a legacy page of the ESP8266WebServer/WebServer, the URI is still valid after detaching. AutoConnect does not delete the request handler registered to ESP8266WebServer/WebServer with the <code>on</code> function. (It cannot be removed)</p> <p>Deleting the AutoConnectAux</p> <p>If the AutoConnectAux to detach was added by AutoConnect::append, it will be automatically removed and freed from memory.</p>"},{"location":"api.html#disablemenu","title":"disableMenu","text":"<pre><code>void disableMenu(const uint16_t items)\n</code></pre> <p>Disable the AutoConnect menu items specified by the items parameter with logical OR value using AC_MENUITEM_t constant. This function only works for AutoConnect primary menu items. It has no effect on disable for AutoConnectAux items. To disable the items by AutoConnectAux, use the AutoConnectAux::menu function. Parameter itemsSpecify the combined value of AC_MENUITEM_t of the items deleting from the AutoConnect menu. It provides the value calculated from the logical OR by the AC_MENUITEM_t value of each item. Refer to the enableMenu about AC_MENUITEM_t.</p>"},{"location":"api.html#enablemenu","title":"enableMenu","text":"<pre><code>void enableMenu(const uint16_t items)\n</code></pre> Enable the AutoConnect menu items specified by the items parameter with logical OR value using AC_MENUITEM_t constant. This function only works for AutoConnect primary menu items. It has no effect on enable for AutoConnectAux items. To enable the items by AutoConnectAux, use the AutoConnectAux::menu function. Parameter itemsSpecify the combined value of AC_MENUITEM_t of the items applying to the AutoConnect menu. It provides the value calculated from the logical OR by the AC_MENUITEM_t value of each item applied as a menu. AC_MENUITEM_t is enumeration type to identify each menu item and it has the below values. <ul> <li>AC_MENUITEM_CONFIGNEW : Configure new AP</li> </ul> <ul> <li>AC_MENUITEM_OPENSSIDS : Open SSIDs</li> </ul> <ul> <li>AC_MENUITEM_DISCONNECT : Disconnect</li> </ul> <ul> <li>AC_MENUITEM_RESET : Reset...</li> </ul> <ul> <li>AC_MENUITEM_HOME : HOME</li> </ul> <ul> <li>AC_MENUITEM_DEVINFO : Device statistics as AutoConnect root page</li> </ul> <ul> <li>AC_MENUITEM_DELETESSID : Enable to delete credentials on Open SSIDs.</li> </ul> <p>It is added, not replaced.</p> <p>The initial configuration of the AutoConnect menu items: <code>AC_MENUITEM_CONFIGNEW | AC_MENUITEM_OPENSSIDS | AC_MENUITEM_DISCONNECT | AC_MENUITEM_RESET | AC_MENUITEM_HOME</code> The enableMenu function adds an indication of the specified items to the current. Therefore, use the disableMenu to remove the specified item from the initial menu.</p>"},{"location":"api.html#end","title":"end","text":"<pre><code>void end(void)\n</code></pre> <p>Stops AutoConnect captive portal service. Release ESP8266WebServer/WebServer and DNSServer. </p> <p>Attention to end</p> <p>The end function releases the instance of ESP8266WebServer/WebServer and DNSServer. It can not process them after the end function.</p>"},{"location":"api.html#geteepromusedsize","title":"getEEPROMUsedSize","text":"<pre><code>uint16_t getEEPROMUsedSize(void)\n</code></pre> <p>Returns the total amount of memory required to hold the AutoConnect credentials and any custom configuration settings stored in EEPROM. The Sketch that writes its own custom data to the EEPROM must call <code>EEPROM.begin</code> with this value. Return value Total amount size of saved AutoConnect credentials and custom data.</p> <p>The getEEPROMUsedSize is available for only ESP8266 use</p> <p>It is available for only ESP8266 use and will return 0 when used with ESP32.</p>"},{"location":"api.html#handleclient","title":"handleClient","text":"<pre><code>void handleClient(void)\n</code></pre> <p>Process the AutoConnect menu interface. The ESP8266WebServer::handleClient1 function hosted by AutoConnect is also called from within AutoConnect to handle the request handlers contained in Sketch.</p> <p>Enhanced AutoConnect::handleClient</p> <p>The handleClient function enhanced since AutoConnect 1.2.0 can start the captive portal according to the WiFi connection status. By properly specifying AutoConnectConfig::retainPortal and AutoConnectConfig::autoRise, when handleClient detects WiFi disconnection, it shifts WiFi mode to WIFI_AP_STA and starts the DNS server together with SoftAP dynamically. Then trapping for incoming HTTP requests from client devices will be started by AutoConnect. Thus it will open the captive portal behind the execution of the sketch <code>loop()</code> function. The captive portal launched by enhanced handleClient does not interfere with sketch execution except waiting for the result of WiFi.begin. Also, AutoConnectConfig::autoReconnect has improved. The Sketch can specify the AutoConnectConfig::reconnectInterval to continue retrying the reconnection with enhanced handleClient.</p>"},{"location":"api.html#handlerequest","title":"handleRequest","text":"<pre><code>void handleRequest(void)\n</code></pre> <p>Handling for the AutoConnect menu request.</p> <p>About used in combination with handleClient</p> <p>The handleRequest function is not supposed to use with AutoConnect::handleClient. It should be used following ESP8266WebServer::handleClient or WebServer::handleClient.</p>"},{"location":"api.html#home","title":"home","text":"<pre><code>void home(String&amp; uri)\n</code></pre> <p>Put a user site's home URI. The URI specified by home is linked from \"HOME\" in the AutoConnect menu. Parameter uriA URI string of user site's home path.</p>"},{"location":"api.html#host","title":"host","text":"<ul> <li>For ESP8266</li> </ul> <pre><code>ESP8266WebServer&amp; host(void)\n</code></pre> <ul> <li>For ESP32</li> </ul> <pre><code>WebServer&amp; host(void)\n</code></pre> <p>Returns the reference of the ESP8266WebServer/WebServer which is allocated in AutoConnect automatically. Return value A reference of the ESP8266WebServer/WebServer.</p> <p>&amp;reference is not a pointer</p> <p>A reference cannot be re-assigned, and must be assigned at initialization. It's like as bind as alias.     <pre><code>ESP8266WebServer&amp; server = portal.host();\nserver.handleClient();\n</code></pre> or <pre><code>portal.host().handleClient();\n</code></pre></p>"},{"location":"api.html#isportalavailable","title":"isPortalAvailable","text":"<pre><code>bool isPortalAvailable(void)\n</code></pre> <p>Returns a boolean value indicating whether a captive portal is available. Return value trueCaptive portal is available. It has SoftAP enabled and is spoofing DNS lookup responses by AutoConnect. Usually, in this state, requests from client devices for Internet transparency validation are redirected to the ESP module. falseAutoConnect is not in captive portal state.</p> <p></p> <pre><code>void join(std::vector&lt;std::reference_wrapper&lt;AutoConnectAux&gt;&gt; aux)\n</code></pre>"},{"location":"api.html#join","title":"join","text":"<pre><code>void join(AutoConnectAux&amp; aux)\n</code></pre> <pre><code>void join(std::vector&lt;std::reference_wrapper&lt;AutoConnectAux&gt;&gt; aux)\n</code></pre> <p>Join the AutoConnectAux object to AutoConnect. AutoConnectAux objects can be joined one by one, or joined altogether. The AutoConnectAux object joined by the join function can be handled from the AutoConnect menu. Parameter auxReference to AutoConnectAux. It can be std::vector of std::reference_wrapper of AutoConnectAux with list initialization.</p>"},{"location":"api.html#load","title":"load","text":"<pre><code>bool load(const String&amp; aux)\n</code></pre> <pre><code>bool load(PGM_P aux)\n</code></pre> <pre><code>bool load(const __FlashStringHelper* aux)\n</code></pre> <pre><code>bool load(Stream&amp; aux)\n</code></pre> <p>Load JSON document of AutoConnectAux which contains AutoConnectElements. If there is a syntax error in the JSON document, false is returned. Parameter auxThe input string to be loaded. Return value trueThe JSON document as AutoConnectAux successfully loaded. falseLoading JSON document unsuccessful, probably syntax errors have occurred or insufficient memory. You can diagnose the cause of loading failure using the ArduinoJson Assistant.</p>"},{"location":"api.html#locate","title":"locate","text":"<pre><code>AutoConnectAux&amp; locate(const String&amp; uri)\n</code></pre> <p>Returns a reference to the AutoConnectAux assigned to the uri passed in the argument. Parameter uriURI string of the custom web page to be located. Return value A reference to the AutoConnectAux that has a specified URI.</p> <p>AutoConnectAux for the specified uri must exist</p> <p>If the AutoConnectAux for the uri specified to the locate function does not exist, the function returns a reference to an empty AutoConnectAux. It's just a frame without any AutoConnectElements. No processing can continue using that AutoConnectAux. (causes an exception) A common cause of exceptions for the locate function is syntax errors in the JSON description of a custom web page.</p>"},{"location":"api.html#on","title":"on","text":"<pre><code>bool on(const String&amp; uri, const AuxHandlerFunctionT handler, AutoConnectExitOrder_t order = AC_EXIT_AHEAD)\n</code></pre> Register the handler function of the AutoConnectAux. Parameters uriA string of the URI assigned to the AutoConnectAux page. handlerA function that behaves when a request to the AutoConnectAux page occurs. AuxHandlerFunctionT type is defined by the following declaration.<p><code>String handler(AutoConnectAux&amp;, PageArgument&amp;)</code></p> orderSpecifies when the handler is called with the following enumeration value. <ul> <li>AC_EXIT_AHEAD : Called before AutoConnect generates the HTML of the page. You set the value of AutoConnectElements in the handler then its value will be displayed on the page.</li> </ul> <ul> <li>AC_EXIT_LATER : Called after AutoConnect generates the HTML of the page. You can append to HTML generated by AutoConnect.</li> </ul> <ul> <li>AC_EXIT_BOTH : Called even before generating HTML and after generated.</li> </ul> <p>It is not ESP8266WebServer::on, not WebServer::on for ESP32.</p> <p>This function effects to AutoConnectAux only. However, it coexists with that of ESP8266WebServer::on or WebServer::on of ESP32. </p>"},{"location":"api.html#onconnect","title":"onConnect","text":"<pre><code>void onConnect(ConnectExit_ft fn)\n</code></pre> <p>Register the function which will call from AutoConnect at the WiFi connection established. Parameter fnA function called at the WiFi connected. </p> <p>An fn specifies the function called when the WiFi connected. Its prototype declaration is defined as ConnectExit_ft.</p> <pre><code>typedef std::function&lt;void(IPAddress&amp; localIP)&gt; ConnectExit_ft\n</code></pre> Parameter localIPAn IP address of the ESP module as STA."},{"location":"api.html#ondetect","title":"onDetect","text":"<pre><code>void onDetect(DetectExit_ft fn)\n</code></pre> <p>Register the function which will call from AutoConnect at the start of the captive portal. Parameter fnA function called at the captive portal start. </p> <p>An fn specifies the function called when the captive portal starts. Its prototype declaration is defined as DetectExit_ft.</p> <pre><code>typedef std::function&lt;bool(IPAddress&amp; softapIP)&gt;  DetectExit_ft\n</code></pre> Parameter softapIPAn IP address of SoftAP for the captive portal. Return value trueContinues captive portal handling. falseCancel the captive portal. AutoConnect::begin function will return with a false."},{"location":"api.html#onnotfound","title":"onNotFound","text":"<ul> <li>For ESP8266</li> </ul> <pre><code>void onNotFound(ESP8266WebServer::THandlerFunction fn)\n</code></pre> <ul> <li>For ESP32</li> </ul> <pre><code>void onNotFound(WebServer::THandlerFunction fn)\n</code></pre> <p>Register the handler function for undefined URL request detected. Parameter fnA function of the \"not found\" handler.</p>"},{"location":"api.html#onotaend","title":"onOTAEnd","text":"<pre><code>void onOTAEnd(OTAEndExit_ft fn)\n</code></pre> <p>Register the on-end exit routine that is called only once when the OTA is finished. Parameter fnA function called when the OTA has been finished. </p> <p>An fn specifies the function called when the OTA has been finished. Its prototype declaration is defined as OTAEndExit_ft.</p> <pre><code>typedef std::function&lt;void(void)&gt; OTAEndExit_ft\n</code></pre>"},{"location":"api.html#onotaerror","title":"onOTAError","text":"<pre><code>void onOTAError(OTAErrorExit_ft fn)\n</code></pre> <p>Register the exit routine that is called when some error occurred. Parameter fnA function called when some OTA error occurs. </p> <p>An fn specifies the function called when the some error occurred. Its prototype declaration is defined as OTAErrorExit_ft.</p> <pre><code>typedef std::function&lt;void(uint8_t error)&gt; OTAErrorExit_ft\n</code></pre> Parameter errorError code of OTA. It is defined in the Updater class or the Update class of the Arduino core for each platform."},{"location":"api.html#onotaprogress","title":"onOTAProgress","text":"<pre><code>void onOTAProgress(OTAProgressExit_ft fn)\n</code></pre> <p>Register the exit routine that is called during the OTA progress. Parameter fnA function called during the OTA progress.</p> <p>An fn specifies the function called during the OTA progress. Its prototype declaration is defined as OTAProgressExit_ft.</p> <pre><code>typedef std::function&lt;void(unsigned int amount, unsigned int size)&gt; OTAProgressExit_ft\n</code></pre> Parameters amountTotal amount of bytes received. sizeBlock size of current send."},{"location":"api.html#onotastart","title":"onOTAStart","text":"<pre><code>void onOTAStart(OTAStartExit_ft fn)\n</code></pre> <p>Register the on-start exit routine that is called only once when the OTA has been started. Parameter fnA function called at the OTA start.</p> <p>An fn specifies the function called when the OTA starts. Its prototype declaration is defined as OTAStartExit_ft.</p> <pre><code>typedef std::function&lt;void(void)&gt; OTAStartExit_ft\n</code></pre>"},{"location":"api.html#portalstatus","title":"portalStatus","text":"<pre><code>uint8_t portalStatus(void)\n</code></pre> Returns the status of the portal inside AutoConnect::begin and AutoConnect::handleClient. Return value A bitwise value that indicates each status and is the logical disjunction of multiple states. <ul> <li>AutoConnect::AC_IDLE: Initial state. AutoConnect is not making any WiFi connection attempts. This state is reached immediately after AutoConnect::begin starts.</li> </ul> <ul> <li>AutoConnect::AC_ESTABLISHED: Successfully connected to the WiFi access point.</li> </ul> <ul> <li>AutoConnect::AC_AUTORECONNECT: AutoConnectConfig::autoReconnect setting was applied during the WiFi connection attempt process. This flag does not indicate a successful connection. It only shows that a condition that triggers autoReconnect has occurred. Whether the connection was actually successful should be determined by <code>WiFi.status()==WL_CONNECTED</code>.</li> </ul> <ul> <li>AutoConnect::AC_TIMEOUT: WiFi connection attempt timed out. Or, the captive portal was shut down by the AutoConnectConfig::portalTimeout setting.</li> </ul> <ul> <li>AutoConnect::AC_INTERRUPT: Connection interrupted due to an indication with the exit. The whileConnecting exit routine returned false. or the whileCaptivePortal exit routine returned false. AutoConnect aborted the WiFi connection attempt with those indications.</li> </ul> <ul> <li>AutoConnect::AC_CAPTIVEPORTAL: Captive portal is available. It means that SoftAP mode is enabled, and the DNS server is available. The state of this flag is equivalent to the return value of AutoConnect::isPortalAvailable function.</li> </ul> <ul> <li>AutoConnect::AC_INPROGRESS: <code>WiFi.begin</code> in progress. AutoConnect is waiting for the connection to succeed or times out; this state will reset when terminating WiFi.begin attempts.</li> </ul>"},{"location":"api.html#restorecredential","title":"restoreCredential","text":"<ul> <li>For ESP8266</li> </ul> <pre><code>bool restoreCredential(const char* filename = \"/ac_credt\", fs::FS&amp; fs = FS)\n</code></pre> <ul> <li>For ESP32</li> </ul> <pre><code>bool restoreCredential(const char* filename = \"/ac_credt\", fs::SPIFFSFS&amp; fs = SPIFFS)\n</code></pre> <pre><code>bool restoreCredential(const char* filename = \"/ac_credt\", fs::LittleFSFS&amp; fs = LittleFS)\n</code></pre> <ul> <li>For using SD</li> </ul> <pre><code>bool restoreCredential&lt;fs::SDFS&gt;(const char* filename, fs::SDFS&amp; fs)\n</code></pre> <p>Restore credentials from the file as named <code>filename</code> with specified <code>fs</code> file system. The file containing the credentials of the restore source must have been saved with the <code>AutoConnect::saveCredential</code> function. Parameter filenameSpecify the file from which to restore the credentials. The <code>filename</code> must include <code>/</code>, the root directory. If this parameter is not specified, <code>ac_credt</code> is assumed. fsSpecifies the file system of the source file to be restored. It must be mounted by the <code>begin</code> function of the file system concerned. Return value trueCredentials has been restored. falseFailed to restore the credentials. Current credentials may have been lost.</p>"},{"location":"api.html#savecredential","title":"saveCredential","text":"<ul> <li>For ESP8266</li> </ul> <pre><code>bool saveCredential(const char* filename = \"/ac_credt\", fs::FS&amp; fs = FS)\n</code></pre> <ul> <li>For ESP32</li> </ul> <pre><code>bool saveCredential(const char* filename = \"/ac_credt\", fs::SPIFFSFS&amp; fs)\n</code></pre> <pre><code>bool saveCredential(const char* filename = \"/ac_credt\", fs::LittleFSFS&amp; fs)\n</code></pre> <ul> <li>For using SD</li> </ul> <pre><code>bool saveCredential&lt;fs::SDFS&gt;(const char* filename, fs::SDFS&amp; fs)\n</code></pre> <p>Saves the current credentials stored by AutoConnect to the specified file. A credential file saved with this function can be treated as input to the <code>AutoConnect::restoreCredential</code> function. Parameter filenameSpecify the file from which to save the credentials. The <code>filename</code> must include <code>/</code>, the root directory. If this parameter is not specified, <code>ac_credt</code> is assumed. fsSpecifies the file system of the destination file to be saved. It must be mounted by the <code>begin</code> function of the file system concerned. Return value trueCredentials has been saved. falseFailed to save the credentials.</p>"},{"location":"api.html#where","title":"where","text":"<pre><code>String where(void)\n</code></pre> <p>Returns an uri string of the AutoConnectAux uri object of the custom Web page that caused the request to the page. AutoConnect identifies the URI (ie. the referrer URI) that caused the request each time from the client occurs and will save the URI If the request source is a custom Web page of AutoConnectAux. The where function returns a pointer of AutoConnectAux which is a URI of a least recent request from the custom Web page. This function is provided to access the fields (ie. the AutoConnectElements) with a custom Web page handler of a page and is available only for request source that is the custom Web pages. It is invalid for HTTP requests from individual pages registered with the on handler of ESP8266WebServer/WebServer for ESP32. In other words, this function only returns the AutoConnecAux page which is a least recently displayed. Return value An uri string of the AutoConnectAux that caused the request the page.</p> <p>The where function usage is described in the section Where to pick up the values.</p>"},{"location":"api.html#whilecaptiveportal","title":"whileCaptivePortal","text":"<pre><code>void whileCaptivePortal(WhileCaptivePortalExit_ft fn)\n</code></pre> <p>Register the function which will call from AutoConnect during a stay in the captive portal. Parameter fnFunction called at the captive portal start.</p> <p>An fn specifies the function called while staying in the captive portal. Its prototype declaration is defined as WhileCaptivePortalExit_ft.</p> <pre><code>typedef std::function&lt;bool(void)&gt;   WhileCaptivePortalExit_ft\n</code></pre> Return value trueContinues captive portal handling. falseCancel the captive portal. AutoConnect::begin function will return with a false."},{"location":"api.html#whileconnecting","title":"whileConnecting","text":"<pre><code>void whileConnecting(WhileConnectingExit_ft fn)\n</code></pre> <p>Register the function that will call from AutoConnect while waiting for connection after WiFi.begin. Parameter fnFunction that will call from AutoConnect while waiting for connection.</p> <p>An fn specifies the a function called while waiting for a WiFi connection. Its prototype declaration is defined as WhileConnectingExit_ft.</p> <pre><code>typedef std::function&lt;bool(String&amp;)&gt;    WhileConnectingExit_ft\n</code></pre> Parameter ssidSSID of an access point to which connection is being attempted. Return value trueContinue attempts to connect to WiFi. falseCancel the WiFi connection attempt. <ol> <li> <p>Equivalent to the WebServer::handleClient function on the ESP32 platform.\u00a0\u21a9</p> </li> </ol>"},{"location":"apiaux.html","title":"AutoConnectAux API","text":"<p>Only for AutoConnect</p> <p>The following AutoConnectAux API are valid only for AutoConnect; they are not available for AutoConnectCore.</p>"},{"location":"apiaux.html#constructor","title":"Constructor","text":""},{"location":"apiaux.html#autoconnectaux","title":"AutoConnectAux","text":"<pre><code>AutoConnectAux(const String&amp; uri = String(\"\"), const String&amp; title = String(\"\"), const bool menu = true, const AutoConnectElementVT addons = AutoConnectElementVT(), const bool responsive = true, const bool CORS = false)\n</code></pre> Parameters uriURI of this custom Web Page. titlePage title of this custom Web page. It will appear on the auto connection menu and at the top of that page. menuSpecifies whether to display this page on menu. addonsReference to AutoConnectElement collection. responsiveSpecifies whether to make HTTP response or not. CORSInclude <code>Access-Control-Allow-Origin:*</code> in the HTTP response headers of the custom web page. This indicates that the response can be shared."},{"location":"apiaux.html#public-member-functions","title":"Public member functions","text":""},{"location":"apiaux.html#operator","title":"operator [ ]","text":"<pre><code>AutoConnectElement&amp; operator[](const char* name)\n</code></pre> <pre><code>AutoConnectElement&amp; operator[](const __FlashStringHelper* name)\n</code></pre> <p><pre><code>AutoConnectElement&amp; operator[](const String&amp; name)\n</code></pre> Returns a reference to the element specified by name. An operator <code>[]</code> is a shortcut for getElement function with the reference casting. Unlike getElement, which returns a pointer to that element, an operator <code>[]</code> returns a reference to that element. You also need to cast the return value to the actual type, just like the getElement function. Parameter nameName of the AutoConnectElements to be retrieved. Return valueA reference to AutoConnectElement. It is different from the actual element type.</p>"},{"location":"apiaux.html#add","title":"add","text":"<pre><code>void add(AutoConnectElement&amp; addon)\n</code></pre> <pre><code>void add(AutoConnectElementVT addons)\n</code></pre> <p>Add an element to the AutoConnectAux. An added element is displayed on the custom Web page invoked from the AutoConnect menu. Parameters addonReference of AutoConnectElements. Specifies one of the AutoConnectElements classes. addonsAn array list of reference of AutoConnectElements. The list initialization with braced-init-list of the std::vector can be used for the addons parameter cause the actual definition of type AutoConnectElementVT is <code>std::vector&lt;std::reference_wrapper&lt;AutoConnectElement&gt;&gt;</code>.</p>"},{"location":"apiaux.html#authentication","title":"authentication","text":"<pre><code>void authentication(const AC_AUTH_t auth)\n</code></pre> <p>Set to require authentication with access to a page. When you access a page that requires authentication, HTTP authentication will be performed according to the scheme specified with the auth parameter. Parameters authSpecifies authentication scheme with the following enumeration value. <ul> <li>AC_AUTH_BASIC : Basic scheme.</li> <li>AC_AUTH_DIGEST : Digest scheme.     </li> </ul>"},{"location":"apiaux.html#content","title":"content","text":"<pre><code>size_t content(void)\n</code></pre> <p>Returns the number of AutoConnectElements the AutoConnectAux contains. Return valueA number of the registered AutoConnectElements.</p>"},{"location":"apiaux.html#fetchelement","title":"fetchElement","text":"<p><pre><code>void fetchElement(void)\n</code></pre> Retrieve the values of the AutoConnectElements on the custom Web page. Refer to how to use the fetchElement.</p>"},{"location":"apiaux.html#getelement","title":"getElement","text":"<pre><code>T&amp; getElement&lt;T&gt;(const String&amp; name)\n</code></pre> <pre><code>AutoConnectElement* getElement(const char* name)\n</code></pre> <pre><code>AutoConnectElement* getElement(const __FlashStringHelper* name)\n</code></pre> <pre><code>AutoConnectElement* getElement(const String&amp; name)\n</code></pre> <p>Get a registered AutoConnectElement as specified name. If T is specified as an actual type of AutoConnectElements, it returns a reference to that instance. Parameters TActual type name of AutoConnectElements as AutoConnectButton, AutoConnectCheckbox, AutoConnectElement, AutoConnectFile, AutoConnectInput, AutoConnectRadio, AutoConnectSelect, AutoConnectSubmit, AutoConnectText. nameName of the AutoConnectElements to be retrieved. Return valueA reference of the AutoConnectElements. If a type is not specified returns a pointer.</p>"},{"location":"apiaux.html#getelements","title":"getElements","text":"<pre><code>AutoConnectElementVT&amp; getElements(void)\n</code></pre> <p>Get vector of reference of all elements. Return value A reference to std::vector of reference to AutoConnecctElements.</p> <p>The getElements returns a reference to std::vector of reference to AutoConnecctElements. This function is provided to handle AutoConnectElemets owned by AutoConnectAux in bulk, and you can use each method of std::vector for a return value.</p> <pre><code>// An example of getting type and name of all AutoConnectElements registered in AutoConnectAux.\nAutoConnectAux aux;\n// some code here...\nAutoConnectElementVt&amp; elements = aux.getElements();\nfor (AutoConnectElement&amp; elm : elements) {\n    Serial.printf(\"name&lt;%s&gt; as type %d\\n\", elm.name.c_str(), (int)elm.typeOf());\n}\n</code></pre>"},{"location":"apiaux.html#ismenu","title":"isMenu","text":"<pre><code>bool isMenu(void)\n</code></pre> <p>Returns whether embedded in the menu or not. The isMenu is a function that complements the menu function. Return value trueThe custom Web page has been incorporated into the AutoConnect menu as a menu item. falseThis custom Web page is not currently a menu item.</p>"},{"location":"apiaux.html#isvalid","title":"isValid","text":"<pre><code>bool isValid(void)\n</code></pre> <p>Performs validation of all AutoConnectInput elements owned by AutoConnectAux and returns the result. The isValid function will return the true even if the AutoConnectAux does not own AutoConnectInputs. Return value trueValidation is successful. A value of all AutoConnectInputs match with each pattern. falseSome elements failed validation.</p>"},{"location":"apiaux.html#load","title":"load","text":"<pre><code>bool load(const String&amp; in)\n</code></pre> <pre><code>bool load(PGM_P in)\n</code></pre> <pre><code>bool load(const __FlashStringHelper* in)\n</code></pre> <pre><code>bool load(Stream&amp; in)\n</code></pre> <p>Load all AutoConnectElements elements from JSON document into AutoConnectAux as custom Web pages. The JSON document specified by the load function must be the document structure of AutoConnectAux. Its JSON document can describe multiple pages as an array. Parameter inSpecifies the JSON document to be load. The load function can input the following objects. <ul> <li>String : Read-only String</li> <li>PROGMEM : Character array contained in the flash</li> <li>Stream : An entity that inherits stream class, generally SPIFFS or SD.      Return value trueJSON document as the custom Web pages successfully loaded. falseJSON document loading failed.</li> </ul> <p>Load multiple custom Web pages separately</p> <p>Multiple custom Web pages can be loaded at once with JSON as an array. But it will consume a lot of memory. By loading a JSON document by page as much as possible, you can reduce memory consumption.</p>"},{"location":"apiaux.html#loadelement","title":"loadElement","text":"<pre><code>bool loadElement(const String&amp; in, const String&amp; name = String(\"\"))\n</code></pre> <pre><code>bool loadElement(const String&amp; in, std::vector&lt;String&gt; const&amp; names)\n</code></pre> <pre><code>bool loadElement(PGM_P in, const String&amp; name = String(\"\"))\n</code></pre> <pre><code>bool loadElement(PGM_P in, std::vector&lt;String&gt; const&amp; names)\n</code></pre> <pre><code>bool loadElement(const __FlashStringHelper* in, const String&amp; name = String(\"\"))\n</code></pre> <pre><code>bool loadElement(const __FlashStringHelper* in, std::vector&lt;String&gt; const&amp; names)\n</code></pre> <pre><code>bool loadElement(Stream&amp; in, const String&amp; name = String(\"\"))\n</code></pre> <pre><code>bool loadElement(Stream&amp; in, std::vector&lt;String&gt; const&amp; names)\n</code></pre> <p>Load specified element from JSON document into AutoConnectAux. The JSON document specified by the loadElement function must be the AutoConnectElement document structure. When loading from a JSON document that describes multiple elements, its description must be an array syntax. Parameters inSpecifies the JSON document to be load. The load function can input the following objects. <ul> <li>String : Read-only String</li> <li>PROGMEM : Character array contained in the flash</li> <li>Stream : An entity that inherits stream class, generally SPIFFS or SD.      nameSpecifies the name to be load. If the name is not specified, the loadElement function will load all elements contained in the JSON document. names Specifies an array list of String indicating the name of the element to be loaded. The list initialization with braced-init-list of the std::vector can be used. Return value trueSpecified AutoConnectElements successfully loaded. falseJSON document loading failed.</li> </ul> <p>Maybe it is an array</p> <p>Please note that the JSON document that is the input for loadElement is an array syntax of AutoConnectElements when there are multiple elements. For example, the following JSON document has a syntax error:</p> <p><pre><code>{\n\"name\": \"Caption\",\n\"type\": \"ACText\",\n\"value\": \"Hello, world\"\n},\n{\n\"name\": \"Server\",\n\"type\": \"ACInput\",\n\"label\": \"Server address\"\n}\n</code></pre> The outermost <code>[</code>, <code>]</code> is missing.</p>"},{"location":"apiaux.html#menu","title":"menu","text":"<pre><code>void menu(const bool post)\n</code></pre> <p>Set or reset the display as menu item for this AutoConnectAux. This function programmatically manipulates the menu parameter of the AutoConnectAux constructor. Parameter trueShow on the menu. falseHidden on the menu.</p>"},{"location":"apiaux.html#on","title":"on","text":"<pre><code>void on(const AuxHandlerFunctionT handler, const AutoConnectExitOrder_t order = AC_EXIT_AHEAD)\n</code></pre> Register the handler function of the AutoConnectAux. Parameters handlerA function that behaves when a request to the AutoConnectAux page occurs. AuxHandlerFunctionT type is defined by the following declaration.<p><code>String handler(AutoConnectAux&amp;, PageArgument&amp;)</code></p> orderSpecifies when the handler is called with the following enumeration value. <ul> <li>AC_EXIT_AHEAD : Called before AutoConnect generates the HTML of the page. You set the value of AutoConnectElements in the handler then its value will be displayed on the page.</li> </ul> <ul> <li>AC_EXIT_LATER : Called after AutoConnect generates the HTML of the page. You can append to HTML generated by AutoConnect.</li> </ul> <ul> <li>AC_EXIT_BOTH : Called even before generating HTML and after generated.</li> </ul>"},{"location":"apiaux.html#onupload","title":"onUpload","text":"<pre><code>void onUpload&lt;T&amp;&gt;(T handler)\n</code></pre> <pre><code>void onUpload(PageBuilder::UploadFuncT uploadFunc)\n</code></pre> <p>Register the upload handler of the AutoConnectAux. Parameters TSpecifies a class name of the custom uploader inherited from AutoConnectUploadHandler class. Refer to the appendix for details. handlerSpecifies the custom uploader inherited from AutoConnectUploadHandler class. Refer to the appendix for details. uploadFuncA function that behaves when request to upload with the AutoConnectAux page. UploadFuncT type is defined by the following declaration.<p><code>void(const String&amp;, const HTTPUpload&amp;)</code></p><p>A data structure of the upload file as HTTPUpload. It is defined in the ESP8266WebServer (the WebServer for ESP32) library as follows:</p> <pre><code>typedef struct {\n  HTTPUploadStatus status;\n  String  filename;\n  String  name;\n  String  type;\nsize_t  totalSize;\nsize_t  currentSize;\nsize_t  contentLength;\nuint8_t buf[HTTP_UPLOAD_BUFLEN];\n} HTTPUpload;\n</code></pre> <p></p>Refer to 'To upload to a device other than Flash or SD' in section appendix for details.</p>"},{"location":"apiaux.html#redirect","title":"redirect","text":"<pre><code>void redirect(const char* url)\n</code></pre> <p>Generate a Location header field with the specified <code>url</code> and responds with a 302 response code to the client. This function is intended to be used from within the Custom Web Page handler. If the AutoConnectAux is going to redirect to another page without responding with page content, declare the <code>responsive</code> argument <code>false</code> in the AutoConnectAux constructor. With this construction, AutoConnectAux will not respond to HTTP responses. The <code>redirect</code> function can be useful in this situation to respond to a 302 redirect. Parameter urlSpecifies the URL to redirect a page to.</p>"},{"location":"apiaux.html#referer","title":"referer","text":"<pre><code>AutoConnectAux&amp; referer(void)\n</code></pre> <p>Returns a reference to the AutoConnectAux from which this AutoConnectAux was called. Return value A reference to the AutoConnectAux from which this AutoConnectAux was called. If the source of the transition is not an AutoConnectAux page, it returns a reference to itself.</p>"},{"location":"apiaux.html#release","title":"release","text":"<pre><code>bool release(const String&amp; name)\n</code></pre> <p>Release a specified AutoConnectElement from AutoConnectAux. The release function is provided to dynamically change the structure of the custom Web pages with the Sketch. By combining the release function and the add function or the loadElement function, the Sketch can change the style of the custom Web page according to its behavior. Parameter nameSpecifies the name of AutoConnectElements to be released. Return value trueThe AutoConnectElement successfully released. falseThe AutoConnectElement can not be released.</p>"},{"location":"apiaux.html#saveelement","title":"saveElement","text":"<pre><code>size_t saveElement(Stream&amp; out, std::vector&lt;String&gt; const&amp; names = {})\n</code></pre> <p>Write elements of AutoConnectAux to the stream. The saveElement function outputs the specified AutoConnectElements as a JSON document using the prettyPrintTo function of the ArduinoJson library. Parameters outOutput stream to be output. SPIFFS, SD also Serial can be specified generally. namesThe array of the name of AutoConnectElements to be output. If the names parameter is not specified, all AutoConnectElements registered in AutoConnectAux are output. Return value The number of bytes written.</p> <p>The output format is pretty</p> <p>The saveElement function outputs a prettified JSON document.</p> <p>It is not complementary with loadElement</p> <p>The saveElement function which missing the names parameter without name list to be saved that saves an entire AutoConnectAux element, not just AutoConnectElements. Its saved JSON document is not a complementary input to the loadElement function. The JSON document describing AutoConnectAux saved without the names parameter must be loaded by the AutoConnectAux::load function or AutoConnect::load function.</p>"},{"location":"apiaux.html#setelementvalue","title":"setElementValue","text":"<pre><code>bool setElementValue(const String&amp; name, const String value)\n</code></pre> <pre><code>bool setElementValue(const String&amp; name, std::vector&lt;String&gt; const&amp; values)\n</code></pre> <p>Sets the value of the specified AutoConnectElement. If values is specified as a std::vector of String, the element that can set the values is the AutoConnectRadio or the AutoConnectSelect.  Parameters nameSpecifies the name of the AutoConnectElements that you want to set the value. valueSpecifies the value to be set. valuesSpecifies a reference of a std::vector of String. It contains the values of the AutoConnectRadio or the AutoConnectSelect. Return value trueThe value has been set. falseAutoConnectElements with the specified name are not registered. Or the type of the value is not consistent with the specified AutoConnectElements.</p> <p>You can directly access the value member variable.</p> <p>If you are gripping with the Sketch to the AutoConnectElements of the target that sets the value, you can access the value member variable directly. The following sketch code has the same effect. <pre><code>AutoConnectAux aux;\n// ... Griping the AutoConnectText here.\naux.setElementValue(\"TEXT_FIELD\", \"New value\");\n</code></pre> <pre><code>AutoConnectAux aux;\n// ... Griping the AutoConnectText here.\nAutoConnectText&amp; text = aux.getElement&lt;AutoConnectText&gt;(\"TEXT_FIELD\");\ntext.value = \"New value\";\n</code></pre> The difference between the setElementValue and the value access with the getElement is the certainty of the registration state for the element. The getElement returns an empty object if the element is not registered then a sketch assigns the value to it. May occur unexpected results and crashes. You should use the setElementValue if its registration is unsettled.</p>"},{"location":"apiaux.html#settitle","title":"setTitle","text":"<pre><code>void setTitle(const String&amp; title)\n</code></pre> <p>Set the title string of the custom Web page. This title will be displayed as the menu title of the custom Web page. Parameter titleTitle string to be display.</p> <p>Not the menu title</p> <p>The setTitle function is not set for the AutoConnect menu title. The effect of this function is that custom Web page only. To change the AutoConnect menu title use AutoConnectConfig::title.</p>"},{"location":"apiconfig.html","title":"AutoConnectConfig API","text":"<p>The AutoConnectConfig class does not present some members regarding custom web page features due to differences in the AutoConnect component used in the sketch.</p> <p>Sketch allows by including either <code>AutoConnect.h</code> or <code>AutoConnectCore.h</code> header file to use the AutoConnect library. If you include the <code>AutoConnectCore.h</code> with the sketch, AutoConnect will drop the functions involved custom web page facility. And correspondingly, some members that depend on custom web page functions will omit from the AutoConnectConfig class. See the Reducing Binary Size chapter for details.</p>"},{"location":"apiconfig.html#constructor","title":"Constructor","text":""},{"location":"apiconfig.html#autoconnectconfig","title":"AutoConnectConfig","text":"<pre><code>AutoConnectConfig()\n</code></pre> <pre><code>AutoConnectConfig(const char* ap, const char* password)\n</code></pre> <pre><code>AutoConnectConfig(const char* ap, const char* password, const unsigned long timeout)\n</code></pre> <pre><code>AutoConnectConfig(const char* ap, const char* password, const unsigned long timeout, const uint8_t channel)\n</code></pre> Parameters apSSID for SoftAP. The length should be up to 31. The default value is esp8266ap for ESP8266, esp32ap for ESP32. passwordPassword for SoftAP. The length should be from 8 to up to 63. The default value is 12345678. timeoutThe timeout value of the captive portal in [ms] units. The default value is 0. channelThe channel number of WIFi when SoftAP starts. The default values is 1."},{"location":"apiconfig.html#public-member-variables","title":"Public member variables","text":""},{"location":"apiconfig.html#apid","title":"apid","text":"<p>SoftAP's SSID. Type StringThe default value is esp8266ap for ESP8266, esp32ap for ESP32.</p>"},{"location":"apiconfig.html#apip","title":"apip","text":"<p>Sets IP address for Soft AP in captive portal. When AutoConnect fails the initial WiFi.begin, it starts the captive portal with the IP address specified this. Type IPAddressThe default value is 172.217.28.1</p>"},{"location":"apiconfig.html#auth","title":"auth","text":"<p>Apply HTTP authentication with the AutoConnect web page. This This setting allows the Sketch to authenticate with \"BASIC\" or \"DIGEST\" scheme. It is given as an enumeration value of AC_AUTH_t that indicates the authentication scheme. This setting determines the default scheme for HTTP authentication with AutoConnect. When the AutoConnectConfig::authScope is AC_AUTHSCOPE_PARTIAL, each AutoConnectAux authentication scheme has priority. Type AC_AUTH_t Value AC_AUTH_NONE No authentication. This is the default. AC_AUTH_DIGEST Use the digest scheme. AC_AUTH_BASIC Use the basic scheme.</p>"},{"location":"apiconfig.html#authscope","title":"authScope","text":"<p>Specifies the authentication scope of AutoConnect Web pages. The Sketch will be able to expand or narrow the range of authentication by this setting, which can be either as AC_AUTHSCOPE_t enumeration value. Type AC_AUTHSCOPE_t Value AC_AUTHSCOPE_AUX Require authentication to access for all custom Web pages, excepting AutoConnect's pages. This is the Default. AC_AUTHSCOPE_PARTIAL Authenticate only specific custom Web pages which are specified by AutoConnectAux::authentication function or JSON description. AC_AUTHSCOPE_PORTAL Require authentication to access for all AutoConnect's pages, including custom Web pages. </p> <p>This setting is available only when AutoConnectConfig::auth is other than AC_AUTH_NONE. Ignored if it is AC_AUTH_NONE.</p> <p>Also, the authScope setting has another bit that indicates to allow authentication in the captive portal state. Its enum value cannot be used alone and is always for qualifying the above three enum values. Value AC_AUTHSCOPE_WITHCP Allow authentication with the captive portal state. This value cannot be used alone to declare an authentication scope. It indicates to enable authentication in the captive portal by the logical OR operator with one of the AC_AUTHSCOPE_t values above.</p>"},{"location":"apiconfig.html#autoreconnect","title":"autoReconnect","text":"<p>Automatically will try to reconnect with the past established access point (BSSID) when the current configured SSID in ESP8266/ESP32 could not be connected. By enabling this option, AutoConnect::begin() function will attempt to reconnect to a known access point using credentials stored in the flash, even if the connection failed by current SSID. If the connection fails, starts the captive portal in SoftAP+STA mode. Type bool Value trueReconnect automatically. falseStarts Captive Portal in SoftAP + STA mode without trying to reconnect. This is the default.</p> <p>When the autoReconnect option is enabled, an automatic connection will behave if the following conditions are satisfied.</p> <ul> <li>Invokes AutoConnect::begin without user name and password parameter as <code>begin()</code>.</li> <li>If one of the saved credentials matches the BSSID (or SSID) detected by the network scan.</li> </ul> <p>Either BSSID or SSID to aim the access point</p> <p>Whether or not it points to the target access point is determined by matching the SSID or BSSID. The default key to collate is BSSID. The BSSID is usually fixed to the MAC address unique to its access point device, but when using some mobile hotspots, the BSSID may change even for the same access point. If you operate inconvenience in aiming at the access point by BSSID, you can change the collation key to SSID by uncomment the below line in <code>AutoConnectDefs.h</code>:</p> <pre><code>#define AUTOCONNECT_APKEY_SSID\n</code></pre> <p>If <code>AUTOCONNECT_APKEY_SSID</code> macro is defined when the library is compiled, the access points are collated by the SSID.</p>"},{"location":"apiconfig.html#autoreset","title":"autoReset","text":"<p>Reset ESP8266 module automatically after WLAN disconnected. Type bool Value trueReset after WiFi disconnected automatically. falseNo reset.</p>"},{"location":"apiconfig.html#autorise","title":"autoRise","text":"<p>Captive portal activation switch. False for disabling the captive portal. It prevents starting the captive portal even if the connection at the 1st-WiFi.begin fails. Type bool Value trueEnable the captive portal. This is the default. falseDisable the captive portal.</p>"},{"location":"apiconfig.html#autosave","title":"autoSave","text":"<p>The credential saved automatically at the connection establishment. Type AC_SAVECREDENTIAL_t Value AC_SAVECREDENTIAL_AUTO The credential saved automatically. This is the default. AC_SAVECREDENTIAL_ALWAYS Save specified SSID and Password always even if a specified credential has been rejected. AC_SAVECREDENTIAL_NEVER The credential no saved.</p>"},{"location":"apiconfig.html#begintimeout","title":"beginTimeout","text":"<p>Specify the limit time to attempt WiFi connection to the access point. AutoConnect uses this value to abort the connection attempt at WiFi.begin. Its actual value specified in milliseconds unit. The default value is <code>AUTOCONNECT_TIMEOUT</code> defined in <code>AutoConnectDefs.h</code> and the initial value is 30 seconds. Type unsigned long</p>"},{"location":"apiconfig.html#booturi","title":"bootUri","text":"<p>Specify the location to be redirected after module reset in the AutoConnect menu. It is given as an enumeration value of AC_ONBOOTURI_t indicating either the AutoConnect root path or the user screen home path. Type AC_ONBOOTURI_t Value AC_ONBOOTURI_ROOT Resetting the module redirects it to the AutoConnect root path. The root path is assumed to be AUTOCONNECT_URI defined in <code>AutoConnectDefs.h</code>. AC_ONBOOTURI_HOME It is redirected to the URI specified by AutoConnectConfig::homeUri.</p>"},{"location":"apiconfig.html#boundaryoffset","title":"boundaryOffset","text":"<p>Sets the offset address of the credential storage area for EEPROM. This value must be between greater than 4 and less than flash sector size. (4096 by SDK) The default value is 0. This option is valid only for ESP8266 or ESP32 arduino core 1.0.2 earlier. Type uint16_t</p> <p>It will conflict with user data.</p> <p>If the Sketch leaves this offset at zero, it will conflict the storage area of credentials with the user sketch owned data. It needs to use the behind of credential area.</p>"},{"location":"apiconfig.html#channel","title":"channel","text":"<p>The channel number of WIFi when SoftAP starts. Type uint8_t Value 1 ~ 14. The default value is 1.</p> <p>How do I choose Channel</p> <p>Espressif Systems had announced the application note about Wi-Fi channel selection.</p>"},{"location":"apiconfig.html#dns1","title":"dns1","text":"<p>Set primary DNS server address when using static IP address. Type IPAddress</p>"},{"location":"apiconfig.html#dns2","title":"dns2","text":"<p>Set secondary DNS server address when using static IP address. Type IPAddress</p>"},{"location":"apiconfig.html#gateway","title":"gateway","text":"<p>Sets gateway address for Soft AP in captive portal. When AutoConnect fails the initial WiFi.begin, it starts the captive portal with the IP address specified this. Type IPAddressThe default value is 172.217.28.1</p>"},{"location":"apiconfig.html#hidden","title":"hidden","text":"<p>Sets SoftAP to hidden SSID. Type uint8_t Value 0SSID will be appeared. This is the default. 1SSID will be hidden.</p>"},{"location":"apiconfig.html#homeuri","title":"homeUri","text":"<p>Sets the home path of user sketch. This path would be linked from 'HOME' in the AutoConnect menu. The default for homeUri is \"/\". Type String</p>"},{"location":"apiconfig.html#hostname","title":"hostName","text":"<p>Sets the station host name of ESP8266/ESP32. Type String</p>"},{"location":"apiconfig.html#immediatestart","title":"immediateStart","text":"<p>Disable the 1st-WiFi.begin and start the captive portal. If this option is enabled, the module will be in AP_STA mode and the captive portal. The evaluation rank of this parameter is lower than the AutoConnectConfig::autoRise. Even if immediateStart is true, the captive portal will not launch if autoRise is false. Type bool Value trueStart the captive portal with AutoConnect::begin. falseEnable the 1st-WiFi.begin and it will start captive portal when connection failed. This is default.</p>"},{"location":"apiconfig.html#menuitems","title":"menuItems","text":"<p>Configure applying items of the AutoConnect menu. You can arbitrarily combine valid menus by coordinating the menuItems value. Type uint16_tIt provides the combined AC_MENUITEM_t value of the item to apply to the AutoConnect menu.Specify the value calculated from the logical OR by the AC_MENUITEM_t value of each item applied as a menu.  It affects not only disappear the items from the menu also invalidates the URI they have. As a consequence, even if it accesses the URL directly will occur a 404 error.The default value is logical OR of AC_MENUITEM_CONFIGNEW, AC_MENUITEM_OPENSSIDS, AC_MENUITEM_DISCONNECT, AC_MENUITEM_RESET, AC_MENUITEM_UPDATE and AC_MENUITEM_HOME. Value AC_MENUITEM_NONE No assign items except for the AutoConnectAux page item. AC_MENUITEM_CONFIGNEW Appends Configure new AP item. AC_MENUITEM_OPENSSIDS Appends Open SSIDs item. AC_MENUITEM_DISCONNECT Appends Disconnect item. AC_MENUITEM_RESET Appends Reset... item. AC_MENUITEM_UPDATE Appends Update item. This value is valid only for AutoConnect; it is not available for AutoConnectCore.  AC_MENUITEM_HOME Appends HOME item. AC_MENUITEM_DEVINFO Appends the Device info item which links to AutoConnect statistics page. AC_MENUITEM_DELETESSID Enables the ability to interactively delete credentials on the Open SSIDs menu screen.</p> <p>How to specify the value of the menu items</p> <p>An menuItems accepts the logical OR of AC_MENUITEM_t type value. For example, to enable only Open SSIDs and HOME items, specify: <pre><code>AutoConnect portal;\nAutoConnectConfig config;\n\nconfig.menuItems = AC_MENUITEM_OPENSSIDS | AC_MENUITEM_HOME;\nportal.config(config);\n</code></pre> Also, to enable the credentials removal feature, follow these settings procedures. <pre><code>AutoConnect portal;\nAutoConnectConfig config;\n\nconfig.menuItems = config.menuItems | AC_MENUITEM_DELETESSID;\nportal.config(config);\n</code></pre> However, even if you specify like the above, the AutoConnectAux page items still display on the menu. To remove the AutoConnectAux items, use the AutoConnectAux::menu function.</p>"},{"location":"apiconfig.html#minrssi","title":"minRSSI","text":"<p>Specify the lower limit of the WiFi signal strength allowed to use as an access point. This value should be greater than -120 as RSSI. Generally, a data link will not be established unless it exceeds -90 dBm. Also, packet transmission is not reliable below -70 dBm to -80 dBm. Type int16_tThe default value is -120</p>"},{"location":"apiconfig.html#netmask","title":"netmask","text":"<p>Sets subnet mask for Soft AP in captive portal. When AutoConnect fails the initial WiFi.begin, it starts the captive portal with the IP address specified this. Type IPAddressThe default value is 255.255.255.0</p>"},{"location":"apiconfig.html#ota","title":"ota","text":"<p>Specifies to import the built-in OTA update class into the Sketch. When this option is enabled, an Update item will appear in the AutoConnect menu, and the OTA update via Web browser will be automatically embedded to the Sketch. Type AC_OTA_t Value AC_OTA_EXTRA AutoConnect does not import AutoConnectOTA. This is the default. AC_OTA_BUILTIN Specifies to include AutoConnectOTA in the Sketch.</p>"},{"location":"apiconfig.html#otaextracaption","title":"otaExtraCaption","text":"<p>Specifies the caption to be displayed as an extra on the OTA update screen. The extra caption you specified will be displayed in the upper right corner of the OTA update screen. Also, you can only specify the caption string, and you cannot specify the style individually. An extra caption will draw up with the default style of AutoConnect. Type const char* An extra caption string pointer.</p>"},{"location":"apiconfig.html#password","title":"password","text":"<p>Set the password for authentication. Type String The default value is same as psk.</p>"},{"location":"apiconfig.html#portaltimeout","title":"portalTimeout","text":"<p>Specify the timeout value of the captive portal in [ms] units. It is valid when the station is not connected and does not time out if the station is connected to the ESP module in SoftAP mode (i.e. Attempting WiFi connection with the portal function). If 0, the captive portal will not be timed-out. Type unsigned longCaptive portal timeout value. The default value is 0.</p>"},{"location":"apiconfig.html#preserveapmode","title":"preserveAPMode","text":"<p>Specifies starting the STA while maintaining the state of the SoftAP mode in the AutoConnect::begin. This setting only applies when the AutoConnectConfig::autoRise is false. Type bool Value trueAutoConnect::begin keeps AP mode. falseAutoConnect::begin will stop SoftAP at the beginning of the process.</p> <p>Note that this option is not for starting the SoftAP forcibly in AutoConnect::begin and only keeps AP mode, SoftAP initiation is left to the Sketch.</p>"},{"location":"apiconfig.html#preserveip","title":"preserveIP","text":"<p>When using existing credentials to connect WiFi, the station IP configuration specified with the AutoConnectConfig::staip, AutoConnectConfig::staGateway, and AutoConnectConfig::staNetmask are preferred over the IP settings of the stored credentials. If this value is set to true, IP configurations stored with credentials will not be restored. Type bool Value trueUse IP addresses specified with the AutoConnectConfig::staip, AutoConnectConfig::staGateway, and AutoConnectConfig::staNetmask as the station IP configuration. falseWhen reconnecting, the station IP configuration specified with AutoConnectConfig is ignored and the saved credential values are used.</p>"},{"location":"apiconfig.html#principle","title":"principle","text":"<p>Specify the connection order will attempt to connect to one of the highest RSSI values among multiple available access points. It is given as an enumeration value of AC_PRINCIPLE_t indicating. Type AC_PRINCIPLE_t Value AC_PRINCIPLE_RECENT Attempts to connect in the order of the saved credentials entries. The entry order is generally a time series connected in the past. AC_PRINCIPLE_RSSI Attempts to connect to one of the highest RSSI values among multiple available access points.</p>"},{"location":"apiconfig.html#psk","title":"psk","text":"<p>Sets password for SoftAP. The length should be from 8 to up to 63. The default value is 12345678. Type String</p>"},{"location":"apiconfig.html#reconnectinterval","title":"reconnectInterval","text":"<p>Specifies the number of units for interval time to attempt automatic reconnection when AutoConnectConfig::autoReconnect is enabled. This value is specified by the number of unit times from 0 to 255, and one unit time is macro-defined as <code>AUTOCONNECT_UNITTIME</code> in <code>AutoConnectDefs.h</code> file of library source code, and its initial value is 30[s]. Type uint8_t</p> <p>WiFi connection retry is repeated inside AutoConnect::handleClient after the number of seconds that the reconnectInterval value is multiplied by <code>AUTOCONNECT_UNITTIME</code> from the previous attempt. Then, when the connection with one of the saved credentials is established, the automatic reconnection will stop. And while AutoConnectConfig::autoReconnect is enabled, if the WiFi connection is lost, it will start to auto-reconnect again inside AutoConnect::handleClient.</p> <p>If 0 is specified for the reconnectInterval, background reconnection attempt repeatedly will not be made, and only once at the 1st-WiFi.begin failure in AutoConnect::begin. (Only when AutoConnectConfig::autoReconnect is enabled) The default value is 0.</p> <p>AUTOCONNECT_UNITTIME</p> <p><code>AUTOCONNECT_UNITTIME</code> as macro defined in <code>AutoConnectDefs.h</code> file of library source code as the below: <pre><code>// Number of seconds in uint time [s]\n#ifndef AUTOCONNECT_UNITTIME\n#define AUTOCONNECT_UNITTIME    30\n#endif\n</code></pre></p>"},{"location":"apiconfig.html#retainportal","title":"retainPortal","text":"<p>Specify whether to continue the portal function even if the captive portal timed out. If the true, when a timeout occurs, the AutoConnect::begin function is exited with returns false, but the portal facility remains alive. So SoftAP remains alive and you can invoke AutoConnect while continuing sketch execution. The default is false. Type bool Value trueContinue the portal function even if the captive portal times out. The STA + SoftAP mode of the ESP module continues and accepts the connection request to the AP. falseWhen the captive portal times out, STA + SoftAP mode of the ESP module is stopped. This is default.</p> <p>Connection request after timed-out</p> <p>With the retainPortal, even if AutoConnect::begin in the setup() is timed out, you can execute the Sketch and the portal function as a WiFi connection attempt by calling AutoConnect::handleClient in the loop().</p> <p>All unresolved addresses redirects /_ac</p> <p>If you enable the retainPortal option, all unresolved URIs will be redirected to <code>SoftAPIP/_ac</code>. It happens frequently as client devices repeat captive portal probes in particular. To avoid this, you need to exit from the WiFi connection Apps on your device once.</p>"},{"location":"apiconfig.html#staip","title":"staip","text":"<p>Set a static IP address. The IP will behave with STA mode. Type IPAddress</p>"},{"location":"apiconfig.html#stagateway","title":"staGateway","text":"<p>Set the gateway address when using static IP address. Type IPAddress</p>"},{"location":"apiconfig.html#stanetmask","title":"staNetmask","text":"<p>Set the subnetmask when using static IP address. Type IPAddress</p>"},{"location":"apiconfig.html#ticker","title":"ticker","text":"<p>Set flicker signal output according to WiFi connection status during AutoConnect::begin behavior. Type bool Value trueOutput the flicker signal while AutoConnect::begin operation. The <code>AUTOCONNECT_TICKER_PORT</code> macro in the <code>AutoConnectDefs.h</code> header file assigns pins for signal output. The default pin is arduino valiant's <code>LED_BUILTIN</code>. For boards without the LED_BUILTIN pin, assume pin #2. falseNo flicker signal output.</p>"},{"location":"apiconfig.html#tickerport","title":"tickerPort","text":"<p>Specifies the GPIO port number to output the flicker signal of the ticker. The default assumes on the board dependent definition LED_BUILTIN macro redefined by <code>AUTOCONNECT_TICKER_PORT</code> in <code>AutoConnectDefs.h</code>. Type uint8_t</p>"},{"location":"apiconfig.html#tickeron","title":"tickerOn","text":"<p>Specifies the active logic level of the flicker signal. This value indicates the active signal level when driving the ticker. Type uint8_t Value LOWA flicker signal is an active-high. HIGHA flicker signal is an active-low.</p>"},{"location":"apiconfig.html#title","title":"title","text":"<p>Set the menu title. Type String</p>"},{"location":"apiconfig.html#uptime","title":"uptime","text":"<p>Specifies the waiting time for the module to reboot. Type intThe default value is AUTOCONNECT_TIMEOUT/1000.</p>"},{"location":"apiconfig.html#username","title":"username","text":"<p>Set the username for authentication. Type StringThe default value is same as apid.</p>"},{"location":"apiconfig.html#autoconnectconfig-initial-values","title":"AutoConnectConfig Initial values","text":"Public member Data type Initial value definition Defined symbol 1 apid String <code>esp8266ap</code><code>esp32ap</code> AUTOCONNECT_APID apip IPAddress 172.217.28.1 AUTOCONNECT_AP_IP auth AC_AUTH_t AC_AUTH_NONE AC_AUTH_NONEAC_AUTH_DIGESTAC_AUTH_BASIC authScope AC_AUTHSCOPE_t AC_AUTHSCOPE_AUX AC_AUTHSCOPE_PARTIALAC_AUTHSCOPE_AUXAC_AUTHSCOPE_ACAC_AUTHSCOPE_PORTALAC_AUTHSCOPE_WITHCP autoReconnect bool false autoReset bool true autoRise bool true autoSave AC_SAVECREDENTIAL_t AC_SAVECREDENTIAL_AUTO AC_SAVECREDENTIAL_AUTOAC_SAVECREDENTIAL_ALWAYSAC_SAVECREDENTIAL_NEVER beginTimeout unsinged long 30000UL AUTOCONNECT_TIMEOUT bootUri AC_ONBOOTURI_t AC_ONBOOTURI_ROOT AC_ONBOOTURI_ROOTAC_ONBOOTURI_HOME boundaryOffset uint16_t 0 AC_IDENTIFIER_OFFSET channel uint8_t 1 AUTOCONNECT_AP_CH dns1 IPAddress 0UL dns2 IPAddress 0UL gateway IPAddress 172.217.28.1 AUTOCONNECT_AP_GW hidden uint8_t 0 homeUri String <code>/</code> AUTOCONNECT_HOMEURI hostName String NULL immediateStart bool false menuItems uint16_t AC_MENUITEM_CONFIGNEW+ AC_MENUITEM_OPENSSIDS+ AC_MENUITEM_DISCONNECT+ AC_MENUITEM_RESET+ AC_MENUITEM_UPDATE+ AC_MENUITEM_HOME AC_MENUITEM_CONFIGNEWAC_MENUITEM_OPENSSIDSAC_MENUITEM_DISCONNECTAC_MENUITEM_RESETAC_MENUITEM_UPDATEAC_MENUITEM_HOME minRSSI int16_t -120 AUTOCONNECT_MIN_RSSI netmask IPAddress 172.217.28.1 AUTOCONNECT_AP_NM ota AC_OTA_t AC_OTA_EXTRA AC_OTA_EXTRAAC_OTA_BUILTIN otaExtraCaption const char* nullptr password String Follow psk portalTimeout unsigned long 0UL AUTOCONNECT_CAPTIVEPORTAL_TIMEOUT preserveAPMode bool false principle AC_PRINCIPLE_t AC_PRINCIPLE_RECENT AC_PRINCIPLE_RECENTAC_PRINCIPLE_RSSI psk String <code>12345678</code> AUTOCONNECT_PSK reconnectInterval uint8_t 0 retainPortal bool false staGateway IPAddress 0UL staip IPAddress 0UL staNetmask IPAddress 0UL ticker bool false tickerOn uint8_t LOW AUTOCONNECT_UPDATE_LEDON tickerPort uint8_t LED_BUILTIN AUTOCONNECT_TICKER_PORT title String <code>AutoConnect</code> AUTOCONNECT_MENU_TITLE uptime int AUTOCONNECT_TIMEOUT/1000 AUTOCONNECT_STARTUPTIME username String Follow apid"},{"location":"apiconfig.html#autoconnectconfig-example","title":"AutoConnectConfig example","text":"<pre><code>AutoConnect        Portal;\nAutoConnectConfig  Config(\"\", \"passpass\");    // SoftAp name is determined at runtime\nConfig.apid = ESP.hostname();                 // Retrieve host name to SotAp identification\nConfig.apip = IPAddress(192,168,10,101);      // Sets SoftAP IP address\nConfig.gateway = IPAddress(192,168,10,1);     // Sets WLAN router IP address\nConfig.netmask = IPAddress(255,255,255,0);    // Sets WLAN scope\nConfig.autoReconnect = true;                  // Enable auto-reconnect\nConfig.autoSave = AC_SAVECREDENTIAL_NEVER;    // No save credential\nConfig.boundaryOffset = 64;                   // Reserve 64 bytes for the user data in EEPROM.\nConfig.portalTimeout = 60000;                 // Sets timeout value for the captive portal\nConfig.retainPortal = true;                   // Retains the portal function after timed-out\nConfig.homeUri = \"/index.html\";               // Sets home path of Sketch application\nConfig.title =\"My menu\";                      // Customize the menu title\nConfig.staip = IPAddress(192,168,10,10);      // Sets static IP\nConfig.staGateway = IPAddress(192,168,10,1);  // Sets WiFi router address\nConfig.staNetmask = IPAddress(255,255,255,0); // Sets WLAN scope\nConfig.dns1 = IPAddress(192,168,10,1);        // Sets primary DNS address\nPortal.config(Config);                        // Configure AutoConnect\nPortal.begin();                               // Starts and behaves captive portal\n</code></pre> <ol> <li> <p>Those symbols are defined in <code>AutoConnectDefs.h</code>.\u00a0\u21a9</p> </li> </ol>"},{"location":"apielements.html","title":"AutoConnectElements API","text":"<p>Only for AutoConnect</p> <p>The following AutoConnectElements are valid only for AutoConnect; they are not available for AutoConnectCore.</p>"},{"location":"apielements.html#autoconnectbutton","title":"AutoConnectButton","text":""},{"location":"apielements.html#constructor","title":"Constructor","text":"<pre><code>AutoConnectButton(const char* name = \"\", const char* value = \"\", const String&amp; action = String(), const ACPosterior_t post = AC_Tag_None)\n</code></pre> Parameters nameThe element name. valueValue of the element. actionNative code of the action script executed when the button is clicked. postSpecifies the tag to be output afterward the element."},{"location":"apielements.html#public-member-variables","title":"Public member variables","text":""},{"location":"apielements.html#action","title":"action","text":"<p>HTML native code of the action script to be executed when the button is clicked. It is mostly used with a JavaScript to activate a script.1 Type String</p>"},{"location":"apielements.html#enable","title":"enable","text":"<p>Enable HTML tag generation for the element. Type boolAutoConnect will generate the element into HTML only if the enable attribute is true.</p>"},{"location":"apielements.html#global","title":"global","text":"<p>The global attribute copies input values between elements of the same name on different custom Web pages. Type boolAn entered value will be copied to elements of the same name in other AutoConnectAuxes during page transition.However, it will be copied only when the destination element has the true for a global attribute.</p>"},{"location":"apielements.html#name","title":"name","text":"<p>The element name. Type String</p>"},{"location":"apielements.html#post","title":"post","text":"<p>Specifies a tag to add behind the HTML code generated from the element. Type ACPosterior_t <ul> <li><code>AC_Tag_None</code> : No generate additional tags.</li> <li><code>AC_Tag_BR</code> : Add a <code>&lt;br&gt;</code> tag to the end of the element.</li> <li><code>AC_Tag_P</code> : Include the element in the <code>&lt;p&gt; ~ &lt;/p&gt;</code> tag.</li> <li><code>AC_Tag_DIV</code> : Include the element in the <code>&lt;div&gt; ~ &lt;/div&gt;</code> tag. </li> </ul>"},{"location":"apielements.html#value","title":"value","text":"<p>Value of the element. Type String</p>"},{"location":"apielements.html#public-member-functions","title":"Public member functions","text":""},{"location":"apielements.html#canhandle","title":"canHandle","text":"<pre><code>bool canHandle(void)\n</code></pre> <p>Returns whether the AutoConnectButton element has a registered event handler and can respond to a click event. Return value trueAn event handler is registered. The element can correspond to a click event. falseAn event handler is not registered.</p>"},{"location":"apielements.html#off","title":"off","text":"<pre><code>void off(void)\n</code></pre> <p>Release a registered event handler so that the element does not react to events. </p>"},{"location":"apielements.html#on","title":"on","text":"<pre><code>void on(std::function&lt;void(AutoConnectButton&amp;, AutoConnectAux&amp;)&gt; eventHandler)\n</code></pre> <p>Register an event handler function so that the element can respond to a click event. Parameter eventHandlerA function instance corresponding to a click event on AutoConnectButton. It allows giving with lambda expressions.</p> <p>An eventHandler function will be called when a click event occurs with the AutoConnectButton. Its prototype declaration is follows:</p> <pre><code>void eventHandler(AutoConnectButton&amp; me, AutoConnectAux&amp; aux)\n</code></pre> Parameter meA reference to the instance of the AutoConnectButton that fired the click event. auxReference to the AutoConnectAux instance to which the AutoConnectButton that generated the click event belongs."},{"location":"apielements.html#response","title":"response","text":"<pre><code>void response(const char* value)\n</code></pre> <pre><code>void response(const char* attribute, const char* value)\n</code></pre> <p>Reply the value or attribute of an element to the client. The <code>response</code> is usually used for sending a reply to the client with the element's value or attribute that has been updated in an event handler function.</p> <p>The <code>response</code> function itself does not perform communication. It only temporarily accumulates updated values. The stored content constitutes the response data to the HTTP POST request sent from the client browser caused by the AutoConnectElements event.</p> <p>The <code>response</code> function has two overloads with different numbers of arguments. A <code>response</code> function suitable for just one argument will only update the value of the AutoConnectButton. It also stores the updated value of the button caption text (i.e., the <code>innerHTML</code> attribute dependent on the <code>button type=\"button\"</code> element) into the response data for real-time rendering in the browser upon response. Also, a <code>response</code> function suitable for two arguments allows updating all attributes of the HTML <code>button type=\"button\"</code> element derived from AutoConnectButton. Parameter valueSuitable for one argument format: A changing value of AutoConnectButton::value as response. It also will update the <code>innerHTML</code> attribute of the <code>button type=\"button\"</code> element derived from AutoConnectButton.Suitable for two argument format: Specifies a value of the HTML <code>button type=\"button\"</code> element to be modified as specified in the <code>attribute</code> argument. attributeAn attribute name of an HTML <code>button type=\"button\"</code> element to be changed.</p>"},{"location":"apielements.html#typeof","title":"typeOf","text":"<pre><code>ACElement_t typeOf(void)\n</code></pre> <p>Returns type of AutoConnectButton. Return value AC_Button</p>"},{"location":"apielements.html#autoconnectcheckbox","title":"AutoConnectCheckbox","text":""},{"location":"apielements.html#constructor_1","title":"Constructor","text":"<pre><code>AutoConnectCheckbox(const char* name = \"\", const char* value = \"\", const char* label = \"\", const bool checked = false, const ACPosition_t labelPosition = AC_Behind, const ACPosterior_t post = AC_Tag_BR)\n</code></pre> Parameters nameThe element name. valueValue of the element. labelA label string prefixed to the checkbox. checkChecked state of the checkbox. labelPositionSpecifies the position of the label to generate. postSpecifies the tag to be output afterward the element."},{"location":"apielements.html#public-member-variables_1","title":"Public member variables","text":""},{"location":"apielements.html#checked","title":"checked","text":"<p>It indicates the checked status of the checkbox. The value of the checked checkbox element is packed in the query string and sent by submit. Type bool"},{"location":"apielements.html#enable_1","title":"enable","text":"<p>Enable HTML tag generation for the element. Type boolAutoConnect will generate the element into HTML only if the enable attribute is true.</p>"},{"location":"apielements.html#global_1","title":"global","text":"<p>The global attribute copies input values between elements of the same name on different custom Web pages. Type boolAn entered value will be copied to elements of the same name in other AutoConnectAuxes during page transition.However, it will be copied only when the destination element has the true for a global attribute.</p>"},{"location":"apielements.html#label","title":"label","text":"<p>A label is an optional string. A label is always arranged on the right side of the checkbox. Specification of a label will generate an HTML <code>&lt;label&gt;</code> tag with an <code>id</code> attribute. The checkbox and the label are connected by the id attribute. Type String</p>"},{"location":"apielements.html#labelposition","title":"labelPosition","text":"<p>Specifies the position of the label to generate with ACPostion_t enumeration value. Type ACPosition_t <ul> <li><code>AC_Infront</code> : Place a label in front of the check box.</li> <li><code>AC_Behind</code> : Place a label behind the check box. </li> </ul>"},{"location":"apielements.html#name_1","title":"name","text":"<p>The element name. Type String</p>"},{"location":"apielements.html#post_1","title":"post","text":"<p>Specifies a tag to add behind the HTML code generated from the element. Type ACPosterior_t <ul> <li><code>AC_Tag_None</code> : No generate additional tags.</li> <li><code>AC_Tag_BR</code> : Add a <code>&lt;br&gt;</code> tag to the end of the element.</li> <li><code>AC_Tag_P</code> : Include the element in the <code>&lt;p&gt; ~ &lt;/p&gt;</code> tag.</li> <li><code>AC_Tag_DIV</code> : Include the element in the <code>&lt;div&gt; ~ &lt;/div&gt;</code> tag. </li> </ul>"},{"location":"apielements.html#value_1","title":"value","text":"<p>Value of the element. It becomes a value attribute of an HTML <code>&lt;input type=\"checkbox\"&gt;</code> tag. Type String</p>"},{"location":"apielements.html#public-member-functions_1","title":"Public member functions","text":""},{"location":"apielements.html#canhandle_1","title":"canHandle","text":"<pre><code>bool canHandle(void)\n</code></pre> <p>Returns whether the AutoConnectCheckbox element has a registered event handler and can respond to a change event. Return value trueAn event handler is registered. The element can correspond to a change event. falseAn event handler is not registered.</p>"},{"location":"apielements.html#off_1","title":"off","text":"<pre><code>void off(void)\n</code></pre> <p>Release a registered event handler so that the element does not react to events. </p>"},{"location":"apielements.html#on_1","title":"on","text":"<pre><code>void on(std::function&lt;void(AutoConnectCheckbox&amp;, AutoConnectAux&amp;)&gt; eventHandler)\n</code></pre> <p>Register an event handler function so that the element can respond to a change event. Parameter eventHandlerA function instance corresponding to a change event on AutoConnectCheckbox. It allows giving with lambda expressions.</p> <p>An eventHandler function will be called when a change event occurs with the AutoConnectCheckbox. Its prototype declaration is follows:</p> <pre><code>void eventHandler(AutoConnectCheckbox&amp; me, AutoConnectAux&amp; aux)\n</code></pre> Parameter meA reference to the instance of the AutoConnectCheckbox that fired the change event. auxReference to the AutoConnectAux instance to which the AutoConnectCheckbox that generated the change event belongs."},{"location":"apielements.html#response_1","title":"response","text":"<pre><code>void response(const bool checked)\n</code></pre> <pre><code>void response(const char* attribute, const char* value)\n</code></pre> <p>Reply the value or attribute of an element to the client. The <code>response</code> is usually used for sending a reply to the client with the element's value or attribute that has been updated in an event handler function.</p> <p>The <code>response</code> function itself does not perform communication. It only temporarily accumulates updated values. The stored content constitutes the response data to the HTTP POST request sent from the client browser caused by the AutoConnectElements event.</p> <p>The <code>response</code> function has two overloads with different numbers of arguments. A <code>response</code> function suitable for just one argument will only update the check status of the AutoConnectCheckbox. Also, a <code>response</code> function suitable for two arguments allows updating all attributes of the HTML <code>input type=\"checkbox\"</code> element derived from AutoConnectCheckbox. Parameter checkedA changing checked status of AutoConnectCheckbox::checked as response. valueSpecifies a value of the HTML <code>input type=\"checkbox\"</code> element to be modified as specified in the <code>attribute</code> argument. attributeAn attribute name of an HTML <code>input type=\"checkbox\"</code> element to be changed.</p>"},{"location":"apielements.html#typeof_1","title":"typeOf","text":"<pre><code>ACElement_t typeOf(void)\n</code></pre> <p>Returns type of AutoConnectCheckbox. Return value AC_Checkbox</p>"},{"location":"apielements.html#autoconnectelement","title":"AutoConnectElement","text":""},{"location":"apielements.html#constructor_2","title":"Constructor","text":"<pre><code>AutoConnectElement(const char* name = \"\", const char* value = \"\", const ACPosterior_t post = AC_Tag_None)\n</code></pre> Parameters nameThe element name. valueValue of the element. postSpecifies the tag to be output afterward the element."},{"location":"apielements.html#public-member-variables_2","title":"Public member variables","text":""},{"location":"apielements.html#enable_2","title":"enable","text":"<p>Enable HTML tag generation for the element. Type boolAutoConnect will generate the element into HTML only if the enable attribute is true.</p>"},{"location":"apielements.html#global_2","title":"global","text":"<p>The global attribute copies input values between elements of the same name on different custom Web pages. Type boolAn entered value will be copied to elements of the same name in other AutoConnectAuxes during page transition.However, it will be copied only when the destination element has the true for a global attribute.</p>"},{"location":"apielements.html#name_2","title":"name","text":"<p>The element name. Type String</p>"},{"location":"apielements.html#post_2","title":"post","text":"<p>Specifies a tag to add behind the HTML code generated from the element. Type ACPosterior_t <ul> <li><code>AC_Tag_None</code> : No generate additional tags.</li> <li><code>AC_Tag_BR</code> : Add a <code>&lt;br&gt;</code> tag to the end of the element.</li> <li><code>AC_Tag_P</code> : Include the element in the <code>&lt;p&gt; ~ &lt;/p&gt;</code> tag.</li> <li><code>AC_Tag_DIV</code> : Include the element in the <code>&lt;div&gt; ~ &lt;/div&gt;</code> tag. </li> </ul>"},{"location":"apielements.html#value_2","title":"value","text":"<p>Value of the element. It is output as HTML as it is as a source for generating HTML code. Type String</p>"},{"location":"apielements.html#public-member-functions_2","title":"Public member functions","text":""},{"location":"apielements.html#typeof_2","title":"typeOf","text":"<pre><code>ACElement_t typeOf(void)\n</code></pre> <p>Returns type of AutoConnectElement. Return value AC_Element</p>"},{"location":"apielements.html#ast","title":"as&lt;T&gt;","text":"<pre><code>AutoConnectElement&amp; as&lt;T&gt;(void)\n</code></pre> <p>Casts the reference to the AutoConnectElement the specified type. Parameter TThe element type. AutoConnectElements type such as AutoConnectButton, AutoConnectCheckbox, AutoConnectFile, AutoConnectInput, AutoConnectRadio, AutoConnectSelect, AutoConnectStyle, AutoConnectSubmit, AutoConnectText. Return value A reference to the AutoConnectElement with actual type.</p>"},{"location":"apielements.html#autoconnectfile","title":"AutoConnectFile","text":""},{"location":"apielements.html#constructor_3","title":"Constructor","text":"<pre><code>AutoConnectFile(const char* name = \"\", const char* value = \"\", const char* label = \"\", const ACFile_t store = AC_File_FS, const ACPosterior_t post = AC_Tag_BR)\n</code></pre> Parameters nameThe element name. valueFile name to be upload. labelLabel string. storeThe ACFile_t enumerator that represents the media to save the uploaded file. postSpecifies the tag to be output afterward the element."},{"location":"apielements.html#public-member-variables_3","title":"Public member variables","text":""},{"location":"apielements.html#enable_3","title":"enable","text":"<p>Enable HTML tag generation for the element. Type boolAutoConnect will generate the element into HTML only if the enable attribute is true.</p>"},{"location":"apielements.html#global_3","title":"global","text":"<p>The global attribute copies input values between elements of the same name on different custom Web pages. Type boolAn entered value will be copied to elements of the same name in other AutoConnectAuxes during page transition.However, it will be copied only when the destination element has the true for a global attribute.</p>"},{"location":"apielements.html#label_1","title":"label","text":"<p>A label is an optional string. A label is always arranged on the left side of the file input box. Specification of a label will generate an HTML <code>&lt;label&gt;</code> tag with an id attribute. The file input box and the label are connected by the id attribute. Type String</p>"},{"location":"apielements.html#mimetype","title":"mimeType","text":"<p>The mime type of the upload file which included as Media type in the http post request. Set by the client (usually the browser) that requested the upload. It is determined by the file type as <code>application/octet-stream</code>, <code>text</code> etc. which is described in IANA Media Type. Type String</p>"},{"location":"apielements.html#name_3","title":"name","text":"<p>The element name. Type String</p>"},{"location":"apielements.html#post_3","title":"post","text":"<p>Specifies a tag to add behind the HTML code generated from the element. Type ACPosterior_t <ul> <li><code>AC_Tag_None</code> : No generate additional tags.</li> <li><code>AC_Tag_BR</code> : Add a <code>&lt;br&gt;</code> tag to the end of the element.</li> <li><code>AC_Tag_P</code> : Include the element in the <code>&lt;p&gt; ~ &lt;/p&gt;</code> tag.</li> <li><code>AC_Tag_DIV</code> : Include the element in the <code>&lt;div&gt; ~ &lt;/div&gt;</code> tag. </li> </ul>"},{"location":"apielements.html#size","title":"size","text":"<p>Size of the uploading file. Type size_t</p>"},{"location":"apielements.html#store","title":"store","text":"<p>Specifies the save destination of the uploaded file. You can use the built-in uploader to save uploaded file to the flash of the ESP8266/ESP32 module or external SD media without writing a dedicated sketch code. It also supports saving to any destination using a custom uploader that inherits from the AutoConnectUploadHandler class. Type ACFile_t <ul> <li><code>AC_File_FS</code> : Save the uploaded file to SPIFFS in the flash.</li> <li><code>AC_File_SD</code> : Save the uploaded file to SD.</li> <li><code>AC_File_Extern</code> : Save the file using your own upload handler.     </li> </ul>"},{"location":"apielements.html#value_3","title":"value","text":"<p>File name to be upload. The value contains the value entered by the client browser to the <code>&lt;input type=\"file\"&gt;</code> tag and is read-only. Type String</p>"},{"location":"apielements.html#public-member-functions_3","title":"Public member functions","text":""},{"location":"apielements.html#typeof_3","title":"typeOf","text":"<pre><code>ACElement_t typeOf(void)\n</code></pre> <p>Returns type of AutoConnectFile. Return value AC_File </p>"},{"location":"apielements.html#autoconnectinput","title":"AutoConnectInput","text":""},{"location":"apielements.html#constructor_4","title":"Constructor","text":"<pre><code>AutoConnectInput(const char* name = \"\", const char* value = \"\", const char* label = \"\", const char* pattern = \"\", const char* placeholder = \"\", const ACPosterior_t post = AC_Tag_BR, const ACInput_t apply = AC_Input_Text)\n</code></pre> Parameters nameThe element name. valueValue of the element. labelLabel string. patternRegular expression string for checking data format. placeholderA placeholder string. postSpecifies the tag to be output afterward the element. applySpecifies the type of input that the text box accepts."},{"location":"apielements.html#public-member-variables_4","title":"Public member variables","text":""},{"location":"apielements.html#enable_4","title":"enable","text":"<p>Enable HTML tag generation for the element. Type boolAutoConnect will generate the element into HTML only if the enable attribute is true.</p>"},{"location":"apielements.html#global_4","title":"global","text":"<p>The global attribute copies input values between elements of the same name on different custom Web pages. Type boolAn entered value will be copied to elements of the same name in other AutoConnectAuxes during page transition.However, it will be copied only when the destination element has the true for a global attribute.</p>"},{"location":"apielements.html#label_2","title":"label","text":"<p>A label is an optional string. A label is always arranged on the left side of the input box. Specification of a label will generate an HTML <code>&lt;label&gt;</code> tag with an id attribute. The input box and the label are connected by the id attribute. Type String</p>"},{"location":"apielements.html#name_4","title":"name","text":"<p>The element name. Type String</p>"},{"location":"apielements.html#pattern","title":"pattern","text":"<p>A pattern specifies a regular expression that the input-box's value is checked against on form submission. Type String</p>"},{"location":"apielements.html#placeholder","title":"placeholder","text":"<p>A placeholder is an option string. Specification of a placeholder will generate a <code>placeholder</code> attribute for the input tag. Type String</p>"},{"location":"apielements.html#post_4","title":"post","text":"<p>Specifies a tag to add behind the HTML code generated from the element. Type ACPosterior_t <ul> <li><code>AC_Tag_None</code> : No generate additional tags.</li> <li><code>AC_Tag_BR</code> : Add a <code>&lt;br&gt;</code> tag to the end of the element.</li> <li><code>AC_Tag_P</code> : Include the element in the <code>&lt;p&gt; ~ &lt;/p&gt;</code> tag.</li> <li><code>AC_Tag_DIV</code> : Include the element in the <code>&lt;div&gt; ~ &lt;/div&gt;</code> tag. </li> </ul>"},{"location":"apielements.html#value_4","title":"value","text":"<p>Value of the element. It becomes a value attribute of an HTML <code>&lt;input type=\"text\"&gt;</code> tag. An entered text in the custom Web page will be sent with a query string of the form. The value set before accessing the page is displayed as the initial value. Type String</p>"},{"location":"apielements.html#apply","title":"apply","text":"<p>Specifies the type of input that the text box accepts. AutoConnectInput will generate either a <code>&lt;input type=\"text\"&gt;</code>, <code>&lt;input type=\"password\"&gt;</code>, or <code>&lt;input type=\"number\"&gt;</code> tag based on the <code>apply</code> specifying as input type. The input type can be specified the following values in the ACInput_t enumeration type. 1 Type ACInput_t <ul> <li><code>AC_Input_Text</code> : <code>input type=\"text\"</code></li> <li><code>AC_Input_Password</code> : <code>input type=\"password\"</code></li> <li><code>AC_Input_Number</code> : <code>input type=\"number\"</code> </li> </ul>"},{"location":"apielements.html#public-member-functions_4","title":"Public member functions","text":""},{"location":"apielements.html#canhandle_2","title":"canHandle","text":"<pre><code>bool canHandle(void)\n</code></pre> <p>Returns whether the AutoConnectInput element has a registered event handler and can respond to a change event. Return value trueAn event handler is registered. The element can correspond to a change event. falseAn event handler is not registered.</p>"},{"location":"apielements.html#isvalid","title":"isValid","text":"<pre><code>bool isValid(void)\n</code></pre> <p>Evaluate the pattern as a regexp and return whether value matches. Always return true if the pattern is undefined. Return value trueThe value matches a pattern. falseThe value does not match a pattern.</p>"},{"location":"apielements.html#off_2","title":"off","text":"<pre><code>void off(void)\n</code></pre> <p>Release a registered event handler so that the element does not react to events. </p>"},{"location":"apielements.html#on_2","title":"on","text":"<pre><code>void on(std::function&lt;void(AutoConnectInput&amp;, AutoConnectAux&amp;)&gt; eventHandler)\n</code></pre> <p>Register an event handler function so that the element can respond to a change event. Parameter eventHandlerA function instance corresponding to a change event on AutoConnectInput. It allows giving with lambda expressions.</p> <p>An eventHandler function will be called when a change event occurs with the AutoConnectInput. Its prototype declaration is follows:</p> <pre><code>void eventHandler(AutoConnectInput&amp; me, AutoConnectAux&amp; aux)\n</code></pre> Parameter meA reference to the instance of the AutoConnectInput that fired the change event. auxReference to the AutoConnectAux instance to which the AutoConnectInput that generated the change event belongs."},{"location":"apielements.html#response_2","title":"response","text":"<pre><code>void response(const char* value)\n</code></pre> <pre><code>void response(const char* attribute, const char* value)\n</code></pre> <p>Reply the value or attribute of an element to the client. The <code>response</code> is usually used for sending a reply to the client with the element's value or attribute that has been updated in an event handler function.</p> <p>The <code>response</code> function itself does not perform communication. It only temporarily accumulates updated values. The stored content constitutes the response data to the HTTP POST request sent from the client browser caused by the AutoConnectElements event.</p> <p>The <code>response</code> function has two overloads with different numbers of arguments. A <code>response</code> function suitable for just one argument will only update the value of the AutoConnectInput. Also, a <code>response</code> function suitable for two arguments allows updating all attributes of the HTML <code>input type=\"text\"</code> element derived from AutoConnectInput. Parameter valueSuitable for one argument format: A changing value of AutoConnectInput::value as response.Suitable for two argument format: Specifies a value of the HTML <code>input type=\"text\"</code> element to be modified as specified in the <code>attribute</code> argument. attributeAn attribute name of an HTML <code>input type=\"text\"</code> element to be changed.</p>"},{"location":"apielements.html#typeof_4","title":"typeOf","text":"<pre><code>ACElement_t typeOf(void)\n</code></pre> <p>Returns type of AutoConnectInput. Return value AC_Input</p>"},{"location":"apielements.html#autoconnectradio","title":"AutoConnectRadio","text":""},{"location":"apielements.html#constructor_5","title":"Constructor","text":"<pre><code>AutoConnectRadio(const char* name = \"\", std::vector&lt;String&gt; const&amp; values = {}, const char* label = \"\", const ACArrange_t order = AC_Vertical, const uint8_t checked = 0, const ACPosterior_t post = AC_Tag_BR)\n</code></pre> Parameters nameThe element name. valuesAn array of values of the radio buttons. Specifies a std::vector object. labelLabel string. orderThe direction to arrange the radio buttons. checkedAn index to be checked in the radio buttons. postSpecifies the tag to be output afterward the element."},{"location":"apielements.html#public-member-variables_5","title":"Public member variables","text":""},{"location":"apielements.html#checked_1","title":"checked","text":"<p>Specifies the index number (1-based) of the values to be checked. If this parameter is not specified neither item is checked. Type uint8_t</p>"},{"location":"apielements.html#enable_5","title":"enable","text":"<p>Enable HTML tag generation for the element. Type boolAutoConnect will generate the element into HTML only if the enable attribute is true.</p>"},{"location":"apielements.html#global_5","title":"global","text":"<p>The global attribute copies input values between elements of the same name on different custom Web pages. Type boolAn entered value will be copied to elements of the same name in other AutoConnectAuxes during page transition.However, it will be copied only when the destination element has the true for a global attribute.</p>"},{"location":"apielements.html#label_3","title":"label","text":"<p>A label is an optional string. A label will be arranged in the left or top of the radio buttons according to the order. Type String</p>"},{"location":"apielements.html#name_5","title":"name","text":"<p>The element name. Type String</p>"},{"location":"apielements.html#order","title":"order","text":"<p>Specifies the direction to arrange the radio buttons. A label will place in the left or the top according to the order. It is a value of ACArrange_t type and accepts one of the following: Type ACArrange_t <ul> <li><code>AC_Horizontal</code> : Horizontal arrangement.</li> <li><code>AC_Vertical</code> : Vertical arrangement.     </li> </ul>"},{"location":"apielements.html#post_5","title":"post","text":"<p>Specifies a tag to add behind the HTML code generated from the element. Type ACPosterior_t <ul> <li><code>AC_Tag_None</code> : No generate additional tags.</li> <li><code>AC_Tag_BR</code> : Add a <code>&lt;br&gt;</code> tag to the end of the element.</li> <li><code>AC_Tag_P</code> : Include the element in the <code>&lt;p&gt; ~ &lt;/p&gt;</code> tag.</li> <li><code>AC_Tag_DIV</code> : Include the element in the <code>&lt;div&gt; ~ &lt;/div&gt;</code> tag. </li> </ul>"},{"location":"apielements.html#values","title":"values","text":"<p>An array of String type for the radio button options. It is an initialization list can be used. The <code>&lt;input type=\"radio\"&gt;</code> tags will be generated from each entry in the values. Type std::vector&lt;String&gt;</p>"},{"location":"apielements.html#public-member-functions_5","title":"Public member functions","text":""},{"location":"apielements.html#add","title":"add","text":"<pre><code>void add(const String&amp; value)\n</code></pre> <p>Adds an option for the radio button. Parameter valueAn option string to add to the radio button.</p>"},{"location":"apielements.html#canhandle_3","title":"canHandle","text":"<pre><code>bool canHandle(void)\n</code></pre> <p>Returns whether the AutoConnectRadio element has a registered event handler and can respond to a change event. Return value trueAn event handler is registered. The element can correspond to a change event. falseAn event handler is not registered.</p>"},{"location":"apielements.html#check","title":"check","text":"<pre><code>void check(const String&amp; value)\n</code></pre> <p>Indicates the check of the specified option for the radio buttons. You can use the check function for checking dynamically with arbitrary of the radio button. Parameter valueAn option string to be checked.</p>"},{"location":"apielements.html#empty","title":"empty","text":"<pre><code>void empty(const size_t reserve = 0)\n</code></pre> <p>Clear the array of option strings that AutoConnectRadio has in the values. When the reserve parameter is specified, a vector container of that size is reserved.</p> <p>The empty function resets the checked value to zero. When the empty function is executed, any button will be turned off. Parameter reserveReserved size of a container for the radio button option strings.</p>"},{"location":"apielements.html#off_3","title":"off","text":"<pre><code>void off(void)\n</code></pre> <p>Release a registered event handler so that the element does not react to events. </p>"},{"location":"apielements.html#on_3","title":"on","text":"<pre><code>void on(std::function&lt;void(AutoConnectRadio&amp;, AutoConnectAux&amp;)&gt; eventHandler)\n</code></pre> <p>Register an event handler function so that the element can respond to a change event. Parameter eventHandlerA function instance corresponding to a change event on AutoConnectRadio. It allows giving with lambda expressions.</p> <p>An eventHandler function will be called when a change event occurs with the AutoConnectRadio. Its prototype declaration is follows:</p> <pre><code>void eventHandler(AutoConnectRadio&amp; me, AutoConnectAux&amp; aux)\n</code></pre> Parameter meA reference to the instance of the AutoConnectRadio that fired the change event. auxReference to the AutoConnectAux instance to which the AutoConnectRadio that generated the change event belongs."},{"location":"apielements.html#operator","title":"operator [\u00a0]","text":"<pre><code>const String&amp; operator[] (const std::size_t n)\n</code></pre> <p>Returns a value string of the index specified by n. Parameter nIndex of values array to return. Its base number is 0. Return value A reference of a value string indexed by the specified the n.</p>"},{"location":"apielements.html#size_1","title":"size","text":"<pre><code>size_t size(void)\n</code></pre> <p>Returns number of options which contained. Return value Number of options which contained.</p>"},{"location":"apielements.html#typeof_5","title":"typeOf","text":"<pre><code>ACElement_t typeOf(void)\n</code></pre> <p>Returns type of AutoConnectRadio. Return value AC_Radio</p>"},{"location":"apielements.html#value_5","title":"value","text":"<pre><code>  const String&amp; value(void) const\n</code></pre> <p>Returns current checked option of the radio buttons. Return value A String of an option current checked. If there is no checked option, a null string returned.</p>"},{"location":"apielements.html#autoconnectrange","title":"AutoConnectRange","text":""},{"location":"apielements.html#constructor_6","title":"Constructor","text":"<pre><code>AutoConnectRange(const char* name = \"\", const int value = 0, const char* label = \"\", const int min = 0, const int max = 0, const int step = 1, const ACPosition_t magnify = AC_Void, const ACPosterior_t post = AC_Tag_BR, const char* style = \"\")\n</code></pre> Parameters nameThe element name. valueThe initial value in the range. labelLabel string. minThe most negative value within the range of allowed values. maxThe greatest value in the range of permitted values. stepThe granularity that the value must adhere to. magnifySpecifies the display position of the current value of the range. postSpecifies the tag to be output afterward the element. styleA style code with CSS format that qualifiers the range slider."},{"location":"apielements.html#public-member-variables_6","title":"Public member variables","text":""},{"location":"apielements.html#enable_6","title":"enable","text":"<p>Enable HTML tag generation for the element. Type boolAutoConnect will generate the element into HTML only if the enable attribute is true.</p>"},{"location":"apielements.html#global_6","title":"global","text":"<p>The global attribute copies input values between elements of the same name on different custom Web pages. Type boolAn entered value will be copied to elements of the same name in other AutoConnectAuxes during page transition.However, it will be copied only when the destination element has the true for a global attribute.</p>"},{"location":"apielements.html#label_4","title":"label","text":"<p>A label is an optional string. A label is always arranged on the left side of the input box. Specification of a label will generate an HTML <code>&lt;label&gt;</code> tag with an id attribute. The range slider and the label are connected by the id attribute. Type String</p>"},{"location":"apielements.html#magnify","title":"magnify","text":"Display position of the current value of the range. Type ACPosition_t <ul> <li>AC_Infront : Displays the current value on the left side.</li> </ul> <ul> <li>AC_Behind : Displays the current value on the right side.</li> </ul> <ul> <li>AC_Void :  No display the current value. This is the default. </li> </ul>"},{"location":"apielements.html#max","title":"max","text":"<p>The greatest value in the range. Type int</p>"},{"location":"apielements.html#min","title":"min","text":"<p>The most negative value within the range. Type int</p>"},{"location":"apielements.html#name_6","title":"name","text":"<p>The element name. Type String</p>"},{"location":"apielements.html#post_6","title":"post","text":"<p>Specifies a tag to add behind the HTML code generated from the element. Type ACPosterior_t <ul> <li><code>AC_Tag_None</code> : No generate additional tags.</li> <li><code>AC_Tag_BR</code> : Add a <code>&lt;br&gt;</code> tag to the end of the element.</li> <li><code>AC_Tag_P</code> : Include the element in the <code>&lt;p&gt; ~ &lt;/p&gt;</code> tag.</li> <li><code>AC_Tag_DIV</code> : Include the element in the <code>&lt;div&gt; ~ &lt;/div&gt;</code> tag. </li> </ul>"},{"location":"apielements.html#step","title":"step","text":"<p>The granularity that the value must adhere to. Type int</p>"},{"location":"apielements.html#style","title":"style","text":"<p>A style code with CSS format that qualifiers the range slider. Type String</p>"},{"location":"apielements.html#value_6","title":"value","text":"<p>Value of the element. It becomes a value attribute of an HTML <code>&lt;input type=\"range\"&gt;</code> tag. A value of range in the custom Web page will be sent with a query string of the form. Type int</p>"},{"location":"apielements.html#public-member-functions_6","title":"Public member functions","text":""},{"location":"apielements.html#typeof_6","title":"typeOf","text":"<pre><code>ACElement_t typeOf(void)\n</code></pre> <p>Returns type of AutoConnectRange. Return value AC_Range</p>"},{"location":"apielements.html#autoconnectselect","title":"AutoConnectSelect","text":""},{"location":"apielements.html#constructor_7","title":"Constructor","text":"<pre><code>AutoConnectSelect(const char* name = \"\", std::vector&lt;String&gt; const&amp; options = {}, const char* label = \"\", const uint8_t selected = 0, const ACPosterior_t post = AC_Tag_BR)\n</code></pre> Parameters nameThe element name. optionsAn array of options of the select element. Specifies a std::vector object. labelLabel string. selectedAn option should be pre-selected when the page loads. postSpecifies the tag to be output afterward the element."},{"location":"apielements.html#public-member-variables_7","title":"Public member variables","text":""},{"location":"apielements.html#enable_7","title":"enable","text":"<p>Enable HTML tag generation for the element. Type boolAutoConnect will generate the element into HTML only if the enable attribute is true.</p>"},{"location":"apielements.html#global_7","title":"global","text":"<p>The global attribute copies input values between elements of the same name on different custom Web pages. Type boolAn entered value will be copied to elements of the same name in other AutoConnectAuxes during page transition.However, it will be copied only when the destination element has the true for a global attribute.</p>"},{"location":"apielements.html#name_7","title":"name","text":"<p>The element name. Type String</p>"},{"location":"apielements.html#label_5","title":"label","text":"<p>A label is an optional string. A label will be arranged in the top of the selection list. Type String</p>"},{"location":"apielements.html#options","title":"options","text":"<p>An array of String type for the selection options. It is an initialization list can be used. The <code>&lt;option value&gt;</code> tags will be generated from each entry in the options. Type std::vector&lt;String&gt;</p>"},{"location":"apielements.html#post_7","title":"post","text":"<p>Specifies a tag to add behind the HTML code generated from the element. Type ACPosterior_t <ul> <li><code>AC_Tag_None</code> : No generate additional tags.</li> <li><code>AC_Tag_BR</code> : Add a <code>&lt;br&gt;</code> tag to the end of the element.</li> <li><code>AC_Tag_P</code> : Include the element in the <code>&lt;p&gt; ~ &lt;/p&gt;</code> tag.</li> <li><code>AC_Tag_DIV</code> : Include the element in the <code>&lt;div&gt; ~ &lt;/div&gt;</code> tag. </li> </ul>"},{"location":"apielements.html#selected","title":"selected","text":"<p>A <code>selected</code> is an optional value. Specifies 1-based index value of an options array that an option should be pre-selected when the page loads. Type uint8_t</p>"},{"location":"apielements.html#public-member-functions_7","title":"Public member functions","text":""},{"location":"apielements.html#add_1","title":"add","text":"<pre><code>void add(const String&amp; option)\n</code></pre>"},{"location":"apielements.html#canhandle_4","title":"canHandle","text":"<pre><code>bool canHandle(void)\n</code></pre> <p>Returns whether the AutoConnectSelect element has a registered event handler and can respond to a change event. Return value trueAn event handler is registered. The element can correspond to a change event. falseAn event handler is not registered.</p> <p>Adds a selectable option string for the selection list. Parameter optionA string of selectable item to be contained in the select element.</p>"},{"location":"apielements.html#empty_1","title":"empty","text":"<pre><code>void empty(const size_t reserve = 0)\n</code></pre> <p>Clear the array of options list that AutoConnectSelect has in the options. When the reserve parameter is specified, a vector container of that size is reserved.</p> <p>The empty function resets the selected value to zero. When the empty function is executed, there are no selected options and the first item is placed at the beginning. Parameter reserveReserved size of a container for the options.</p>"},{"location":"apielements.html#off_4","title":"off","text":"<pre><code>void off(void)\n</code></pre> <p>Release a registered event handler so that the element does not react to events. </p>"},{"location":"apielements.html#on_4","title":"on","text":"<pre><code>void on(std::function&lt;void(AutoConnectSelect&amp;, AutoConnectAux&amp;)&gt; eventHandler)\n</code></pre> <p>Register an event handler function so that the element can respond to a change event. Parameter eventHandlerA function instance corresponding to a change event on AutoConnectSelect. It allows giving with lambda expressions.</p> <p>An eventHandler function will be called when a change event occurs with the AutoConnectSelect. Its prototype declaration is follows:</p> <pre><code>void eventHandler(AutoConnectSelect&amp; me, AutoConnectAux&amp; aux)\n</code></pre> Parameter meA reference to the instance of the AutoConnectSelect that fired the change event. auxReference to the AutoConnectAux instance to which the AutoConnectSelect that generated the change event belongs."},{"location":"apielements.html#operator_1","title":"operator [\u00a0]","text":"<pre><code>const String&amp; operator[] (const std::size_t n)\n</code></pre> <p>Returns an option string of the index specified by n. Parameter nIndex of options array to return. Its base number is 0. Return value A reference of a option string indexed by the specified the n.</p>"},{"location":"apielements.html#select","title":"select","text":"<pre><code>void  select(const String&amp; value);\n</code></pre> <p>Selects an option with the value. Parameter valueString value that option should be selected in an option array.</p>"},{"location":"apielements.html#size_2","title":"size","text":"<pre><code>size_t size(void)\n</code></pre> <p>Returns number of options which contained. Return value Number of options which contained.</p>"},{"location":"apielements.html#typeof_7","title":"typeOf","text":"<pre><code>ACElement_t typeOf(void)\n</code></pre> <p>Returns type of AutoConnectSelect. Return value AC_Select</p>"},{"location":"apielements.html#value_7","title":"value","text":"<pre><code>const String&amp; value(void) const;\n</code></pre> <p>Returns current selected option of the select list. Return value A String of an option current selected. If there is no select option, a null string returned.</p>"},{"location":"apielements.html#autoconnectstyle","title":"AutoConnectStyle","text":""},{"location":"apielements.html#constructor_8","title":"Constructor","text":"<pre><code>AutoConnectStyle(const char* name = \"\", const char* value = \"\")\n</code></pre> Parameters nameThe element name. valueRaw CSS code to insert into a style block in a custom web page to generate."},{"location":"apielements.html#public-member-variables_8","title":"Public member variables","text":""},{"location":"apielements.html#enable_8","title":"enable","text":"<p>Enable HTML tag generation for the element. Type boolAutoConnect will generate the element into HTML only if the enable attribute is true.</p>"},{"location":"apielements.html#name_8","title":"name","text":"<p>The element name. Type String</p>"},{"location":"apielements.html#value_8","title":"value","text":"<p>Raw CSS code to insert into a style block in a custom web page to generate. Type String</p>"},{"location":"apielements.html#public-member-functions_8","title":"Public member functions","text":""},{"location":"apielements.html#typeof_8","title":"typeOf","text":"<pre><code>ACElement_t typeOf(void)\n</code></pre> <p>Returns type of AutoConnectStyle. Return value AC_Style</p>"},{"location":"apielements.html#autoconnectsubmit","title":"AutoConnectSubmit","text":""},{"location":"apielements.html#constructor_9","title":"Constructor","text":"<pre><code>AutoConnectSubmit(const char* name = \"\", const char* value =\"\", char* uri = \"\", const ACPosterior_t post = AC_Tag_None)\n</code></pre> Parameters nameThe element name. valueThe name of the submit button as an HTML `#!html ` tag, it will also be the label of the button. uriDestination URI. postSpecifies the tag to be output afterward the element."},{"location":"apielements.html#public-member-variables_9","title":"Public member variables","text":""},{"location":"apielements.html#enable_9","title":"enable","text":"<p>Enable HTML tag generation for the element. Type boolAutoConnect will generate the element into HTML only if the enable attribute is true.</p>"},{"location":"apielements.html#global_8","title":"global","text":"<p>The global attribute copies input values between elements of the same name on different custom Web pages. Type boolAn entered value will be copied to elements of the same name in other AutoConnectAuxes during page transition.However, it will be copied only when the destination element has the true for a global attribute.</p>"},{"location":"apielements.html#name_9","title":"name","text":"<p>The element name. Type String</p>"},{"location":"apielements.html#post_8","title":"post","text":"<p>Specifies a tag to add behind the HTML code generated from the element. Type ACPosterior_t <ul> <li><code>AC_Tag_None</code> : No generate additional tags.</li> <li><code>AC_Tag_BR</code> : Add a <code>&lt;br&gt;</code> tag to the end of the element.</li> <li><code>AC_Tag_P</code> : Include the element in the <code>&lt;p&gt; ~ &lt;/p&gt;</code> tag.</li> <li><code>AC_Tag_DIV</code> : Include the element in the <code>&lt;div&gt; ~ &lt;/div&gt;</code> tag. </li> </ul>"},{"location":"apielements.html#uri","title":"uri","text":"<p>Destination URI. Type String</p>"},{"location":"apielements.html#value_9","title":"value","text":"<p>The name of the submit button. It will also be the label of the button. Type String</p>"},{"location":"apielements.html#public-member-functions_9","title":"Public member functions","text":""},{"location":"apielements.html#typeof_9","title":"typeOf","text":"<pre><code>ACElement_t typeOf(void)\n</code></pre> <p>Returns type of AutoConnectSubmit. Return value AC_Submit</p>"},{"location":"apielements.html#autoconnecttext","title":"AutoConnectText","text":""},{"location":"apielements.html#constructor_10","title":"Constructor","text":"<pre><code>AutoConnectText(const char* name = \"\", const char* value = \"\", const char* style = \"\", const char* format = \"\", const ACPosterior_t post = AC_Tag_None)\n</code></pre> Parameters nameThe element name. valueString of content for the text element. styleA style code with CSS format that qualifiers the text. formatA pointer to a null-terminated multibyte string specifying how to interpret the value. It specifies the conversion format when outputting values. The format string conforms to C-style printf library functions postSpecifies the tag to be output afterward the element."},{"location":"apielements.html#public-member-variables_10","title":"Public member variables","text":""},{"location":"apielements.html#enable_10","title":"enable","text":"<p>Enable HTML tag generation for the element. Type boolAutoConnect will generate the element into HTML only if the enable attribute is true.</p>"},{"location":"apielements.html#format","title":"format","text":"<p>The conversion format when outputting values. The format string conforms to C-style printf library functions. Type String</p>"},{"location":"apielements.html#global_9","title":"global","text":"<p>The global attribute copies input values between elements of the same name on different custom Web pages. Type boolAn entered value will be copied to elements of the same name in other AutoConnectAuxes during page transition.However, it will be copied only when the destination element has the true for a global attribute.</p>"},{"location":"apielements.html#name_10","title":"name","text":"<p>The element name. Type String</p>"},{"location":"apielements.html#post_9","title":"post","text":"<p>Specifies a tag to add behind the HTML code generated from the element. Type ACPosterior_t <ul> <li><code>AC_Tag_None</code> : No generate additional tags.</li> <li><code>AC_Tag_BR</code> : Add a <code>&lt;br&gt;</code> tag to the end of the element.</li> <li><code>AC_Tag_P</code> : Include the element in the <code>&lt;p&gt; ~ &lt;/p&gt;</code> tag.</li> <li><code>AC_Tag_DIV</code> : Include the element in the <code>&lt;div&gt; ~ &lt;/div&gt;</code> tag. </li> </ul>"},{"location":"apielements.html#style_1","title":"style","text":"<p>A style code with CSS format that qualifiers the text. Type String</p>"},{"location":"apielements.html#value_10","title":"value","text":"<p>A content string of the text element. Type String</p>"},{"location":"apielements.html#public-member-functions_10","title":"Public member functions","text":""},{"location":"apielements.html#response_3","title":"response","text":"<pre><code>void response(const char* value)\n</code></pre> <pre><code>void response(const char* attribute, const char* value)\n</code></pre> <p>Reply the value or attribute of an element to the client. The <code>response</code> is usually used for sending a reply to the client with the element's value or attribute that has been updated in an event handler function.</p> <p>The <code>response</code> function itself does not perform communication. It only temporarily accumulates updated values. The stored content constitutes the response data to the HTTP POST request sent from the client browser caused by the AutoConnectElements event.</p> <p>The <code>response</code> function has two overloads with different numbers of arguments. A <code>response</code> function suitable for just one argument will only update the DOM text (i.e., the <code>innerHTML</code> attribute dependent on the <code>div</code> or <code>span</code> node) of the AutoConnectText. Also, a <code>response</code> function suitable for two arguments allows updating all attributes of the HTML <code>div</code> or <code>span</code> node derived from AutoConnectText. Parameter valueSuitable for one argument format: A changing value of AutoConnectText::value as response. It also will update the <code>innerHTML</code> attribute of the <code>div</code> or <code>span</code> node derived from AutoConnectText.Suitable for two argument format: Specifies a value of the HTML <code>div</code> or <code>span</code> node to be modified as specified in the <code>attribute</code> argument. attributeAn attribute name of an HTML <code>div</code> or <code>span</code> node to be changed.</p>"},{"location":"apielements.html#typeof_10","title":"typeOf","text":"<pre><code>ACElement_t typeOf(void)\n</code></pre> <p>Returns type of AutoConnectText. Return value AC_Text</p> <ol> <li> <p>ACInput_t does not mind what kind of display effects on the browser. For example, input type=\"number\" has a spin button in Chrome, but has no display effects in iOS Safari. You will see the numeric keypad at inputting the number field with giving the pattern as <code>\\d*</code>.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"apiextra.html","title":"Something extra","text":""},{"location":"apiextra.html#icons","title":"Icons","text":"<p>The library presents two PNG icons which can be used to embed a hyperlink to the AutoConnect menu.</p> <ul> <li>Bar type </li> <li>Cog type </li> </ul> <p>To reference the icon, use the AUTOCONNECT_LINK macro in the Sketch. It expands into the string literal as an HTML <code>&lt;a&gt;&lt;/a&gt;</code> tag with PNG embedded of the AutoConnect menu hyperlinks. Icon type is specified by the parameter of the macro.</p> BAR_24Bars icon, 24x24. BAR_32Bars icon, 32x32. BAR_48Bars icon, 48x48. COG_16Cog icon, 16x16. COG_24Cog icon, 24x24. COG_32Cog icon, 32x32. <p>Usage</p> <pre><code>String html = \"&lt;html&gt;\";\nhtml += AUTOCONNECT_LINK(BAR_32);\nhtml += \"&lt;/html&gt;\";\nserver.send(200, \"text/html\", html);\n</code></pre>"},{"location":"apiextra.html#captive-portal-availability-identification","title":"Captive Portal Availability Identification","text":"<p>A check mark icon can be displayed adjacent to the AutoConnect menu title to indicate that a captive portal is available. This check mark indicates that the ESP module is not connected to any access point, SoftAP is enabled, and DNS lookup spoofing is working through the AutoConnect-initiated DNS server.</p> <p> </p> <p>This setting is enabled by turning on the AC_SHOW_PORTALIDENTIFIER macro defined in AutoConnectDefs.h header file.</p> <pre><code>#define AC_SHOW_PORTALIDENTIFIER\n</code></pre> <p>Using the PlatformIO as a build environment, you can enable it in the <code>build_flags</code> setting without modifying the library's AutoConnectDefs.h source file.</p> <pre><code>platform = espressif32\nframework = arduino\nbuild_flags = -DAC_SHOW_PORTALIDENTIFIER\n</code></pre>"},{"location":"apiupdate.html","title":"AutoConnectUpdate API","text":"<p>Only for AutoConnect</p> <p>The following AutoConnectUpdate API are valid only for AutoConnect; they are not available for AutoConnectCore.</p>"},{"location":"apiupdate.html#constructor","title":"Constructor","text":""},{"location":"apiupdate.html#autoconnectupdate","title":"AutoConnectUpdate","text":"<pre><code>AutoConnectUpdate(const String&amp; host, const uint16_t port, const String&amp; uri, const int timeout, const uint8_t ledOn)\n</code></pre> Parameters hostUpdate server address. Specifies IP address or FQDN. portSpecifies HTTP port for the updating process. The default assumes <code>AUTOCONNECT_UPDATE_PORT</code> defined in the <code>AutoConnectDefs.h</code> header file. uriSpecifies a URI on the update server that has deployed available binary sketch files. timeoutSpecifies the maximum response time for the update server. The default assumes <code>AUTOCONNECT_UPDATE_TIMEOUT</code> in the <code>AutoConnectDefs.h</code> header file. ledOnActive signal to light the LED ticker during the update. Specifies HIGH or LOW <p>The AutoConnectUpdate class inherits from the ESP8266HTTPUpdate (HTTPUpdate for ESP32) class.</p>"},{"location":"apiupdate.html#public-member-functions","title":"Public member functions","text":""},{"location":"apiupdate.html#attach","title":"attach","text":"<pre><code>void AutoConnectUpdate::attach(AutoConnect&amp; portal)\n</code></pre> <p>Attaches the AutoConnectUpdate to the AutoConnect which constitutes the bedrock of the update process. This function creates a dialog page for the update operation as an instance of AutoConnectAux and participates in the AutoConnect menu. Parameter portalSpecifies a reference to the AutoConnect instance to attach. </p>"},{"location":"apiupdate.html#disable","title":"disable","text":"<pre><code>void AutoConnectUpdate::disable(const bool activate)\n</code></pre> <p>Disable the Update item in AutoConnect menu. The AutoConnect::disable function only hides the Update item from the menu, and the AutoConnectUpdate class is still active with the parameter condition. You can use the AutoConnectUpdate::enable function to appear it again in the menu. Parameter activateIf specified the true then the Update item will be displayed on the AutoConnect menu and OTA update will be available during the WiFi status is WL_CONNECTED. For the false, the OTA update feature is disabled. </p>"},{"location":"apiupdate.html#enable","title":"enable","text":"<pre><code>void AutoConnectUpdate::enable(void)\n</code></pre> <p>Makes AutoConnectUpdate class available by incorporating the OTA update function into the AutoConnect menu. In ordinarily, the AutoConnectUpdate class becomes available by just calling the AutoConnectUpdate::attach function.</p>"},{"location":"apiupdate.html#handleupdate","title":"handleUpdate","text":"<pre><code>void AutoConnectUpdate::handleUpdate(void)\n</code></pre> <p>Performs the update process. This function is called by AutoConnect::handleClient when AutoConnectUpdate is enabled. In many cases, sketches do not need to call this function on purpose.</p>"},{"location":"apiupdate.html#isenabled","title":"isEnabled","text":"<pre><code>bool AutoConnectUpdate::isEnabled(void)\n</code></pre> <p>Returns whether AutoConnectUpdate is enabled.</p>"},{"location":"apiupdate.html#rebootonupdate","title":"rebootOnUpdate","text":"<pre><code>void AutoConnectUpdate::rebootOnUpdate(bool reboot)\n</code></pre> <p>Specifies whether or not to automatically restart the module as a result of the successful completion of the update process. Parameter rebootIf specified the true then the ESP module will reboot after the updating successfully completed. For the false, The module does not reboot automatically. The uploaded new firmware remains in the updating stage of the flash on the ESP module.     The boot process during the next start turn of the module by reset will copy the updated firmware to the actual program area and a new sketch program will start. The default value is true. </p> <p>This function inherits from the ESP8266HTTPUpdate (HTTPUpdate for ESP32) class.</p>"},{"location":"apiupdate.html#onend","title":"onEnd","text":"<p><pre><code>void AutoConnectUpdate::onEnd(HTTPUpdateEndCB fn)\n</code></pre> Register the on-end exit routine that is called only once when the update is finished. For the ESP32 platform, this function is only available in ESP32 Arduino core 2.0.0 or later. Parameter fnA function called when the update has been finished. </p> <p>This function inherits from the ESP8266HTTPUpdate (HTTPUpdate for ESP32) class.</p> <p>An fn specifies the function called when the update has been finished. Its prototype declaration is defined as HTTPUpdateEndCB.</p> <pre><code>using HTTPUpdateEndCB = std::function&lt;void()&gt;;\n</code></pre>"},{"location":"apiupdate.html#onerror","title":"onError","text":"<pre><code>void AutoConnectUpdate::onError(HTTPUpdateErrorCB fn)\n</code></pre> <p>Register the exit routine that is called when some error occurred. For the ESP32 platform, this function is only available in ESP32 Arduino core 2.0.0 or later. Parameter fnA function called when some updating error occurs. </p> <p>This function inherits from the ESP8266HTTPUpdate (HTTPUpdate for ESP32) class.</p> <p>An fn specifies the function called when the some error occurred. Its prototype declaration is defined as HTTPUpdateErrorCB.</p> <pre><code>using HTTPUpdateErrorCB = std::function&lt;void(int error)&gt;;\n</code></pre> Parameter errorError code of the Update. It is defined in the ESP8266HTTPClient class, ESP8266HTTPUpdate class or the HTTPUpdate class of the Arduino core for each platform."},{"location":"apiupdate.html#onprogress","title":"onProgress","text":"<pre><code>void AutoConnectUpdate::onProgress(HTTPUpdateProgressCB fn)\n</code></pre> <p>Register the exit routine that is called during the update progress. For the ESP32 platform, this function is only available in ESP32 Arduino core 2.0.0 or later. Parameter fnA function called during the updating progress.</p> <p>This function inherits from the ESP8266HTTPUpdate (HTTPUpdate for ESP32) class.</p> <p>An fn specifies the function called during the updating progress. Its prototype declaration is defined as HTTPUpdateProgressCB.</p> <p>Updating Progress bar will not available</p> <p>AutoConnectUpdate uses the onProgress exit to update the progress bar on a web page during updating. If the user sketch registers its own exit routine with the onProgress function, AutoConnectUpdate's progress bar on the web page will not be updated.</p> <pre><code>using HTTPUpdateProgressCB = std::function&lt;void(int amount, int size)&gt;;\n</code></pre> Parameters amountTotal amount of bytes received. sizeBlock size of current send."},{"location":"apiupdate.html#onstart","title":"onStart","text":"<pre><code>void AutoConnectUpdate::onStart(HTTPUpdateStartCB fn)\n</code></pre> <p>Register the on-start exit routine that is called only once when the update has been started. For the ESP32 platform, this function is only available in ESP32 Arduino core 2.0.0 or later. Parameter fnA function called at the update start.</p> <p>This function inherits from the ESP8266HTTPUpdate (HTTPUpdate for ESP32) class.</p> <p>An fn specifies the function called when the OTA starts. Its prototype declaration is defined as HTTPUpdateStartCB.</p> <pre><code>using HTTPUpdateStartCB = std::function&lt;void()&gt;;\n</code></pre>"},{"location":"apiupdate.html#setledpin","title":"setLedPin","text":"<pre><code>void AutoConnectUpdate::setLedPin(int ledPin, uint8_t ledOn)\n</code></pre> <p>Sets the port and the ON signal level of the externally connected LED that should act as a ticker during the update process. Parameter ledPinSpecifies the PIN connected external LED for the ticker. The default assumes <code>AUTOCONNECT_TICKER_PORT</code> defined in the <code>AutoConnectDefs.h</code> header file and it is derived from the board-specific LED_BUILTIN. By default, the AutoConnectUpdate class does not use the ticker for boards without the LED_BUILTIN definition. If you connect the ticker LED externally, you need to specify the PIN using the setLedPin function. ledOnSpecifies the the ON signal level of the LED PIN port. It is HIGH or LOW. </p> <p>This function inherits from the ESP8266HTTPUpdate (HTTPUpdate for ESP32) class.</p>"},{"location":"apiupdate.html#status","title":"status","text":"<pre><code>AC_UPDATESTATUS_t AutoConnectUpdate::status(void)\n</code></pre> <p>Returns the update process status transition indicator as an enumerated value of the AC_UPDATESTATUS_t type that indicates the process status of the AutoConnectUpdate class. Return value One of the enumerated values indicating the status of the Update class as follows: <ul> <li>UPDATE_RESET : Update process ended, need to reset.</li> <li>UPDATE_IDLE : Update process has not started.</li> <li>UPDATE_START : Update process has been started.</li> <li>UPDATE_PROGRESS : Update process has been started.</li> <li>UPDATE_SUCCESS : Update successfully completed.</li> <li>UPDATE_NOAVAIL : No available update.</li> <li>UPDATE_FAIL : Update failed. </li> </ul>"},{"location":"apiupdate.html#public-member-variables","title":"Public member variables","text":""},{"location":"apiupdate.html#host","title":"host","text":"<p>Update server address. Specifies IP address or FQDN. Type String </p>"},{"location":"apiupdate.html#port","title":"port","text":"<p>HTTP port for the updating process. Type StringThe default assumes <code>AUTOCONNECT_UPDATE_PORT</code> defined in the <code>AutoConnectDefs.h</code> header file. </p>"},{"location":"apiupdate.html#uri","title":"uri","text":"<p>URI on the update server that has deployed available binary sketch files. Type String </p>"},{"location":"basicusage.html","title":"Basic usage","text":""},{"location":"basicusage.html#simple-usage","title":"Simple usage","text":""},{"location":"basicusage.html#embed-to-the-sketches","title":"Embed to the Sketches","text":"<p>How embed the AutoConnect to the Sketches you have. Most simple approach to applying AutoConnect for the existing Sketches, follow the below steps. The below Sketch is for ESP8266. For ESP32, replace <code>ESP8266WebServer</code> with <code>WebServer</code> and <code>ESP8266WiFi.h</code> with <code>WiFi.h</code> respectively.</p> <p></p> <p> Insert <code>#include &lt;AutoConnect.h&gt;</code> to behind of <code>#include &lt;ESP8266WebServer.h&gt;</code>.</p> <p> Insert <code>AutoConnect PORTAL(WEBSERVER);</code> to behind of <code>ESP8266WebServer WEBSERVER;</code> declaration.1</p> <p> Remove <code>WiFi.begin(SSID,PSK)</code> and the subsequent logic for the connection status check.</p> <p> Replace <code>WEBSERVER.begin()</code> to <code>PORTAL.begin()</code>.2</p> <p> Replace <code>WEBSERVER.handleClient()</code> to <code>PORTAL.handleClient()</code>.3</p> <p> If the connection checks logic is needed, you can check the return value according to <code>PORTAL.begin()</code> with <code>true</code> or <code>false</code>.</p>"},{"location":"basicusage.html#basic-usage","title":"Basic usage","text":""},{"location":"basicusage.html#basic-logic-sequence-for-the-user-sketches","title":"Basic logic sequence for the user Sketches","text":""},{"location":"basicusage.html#1-a-typical-logic-sequence","title":"1. A typical logic sequence","text":"<ol> <li>Include headers, <code>ESP8266WebServer.h</code>/<code>WebServer.h</code> and <code>AutoConnect.h</code> </li> <li>Declare an ESP8266WebServer variable for ESP8266 or a WebServer variable for ESP32. </li> <li>Declare an AutoConnect variable. </li> <li>Implement the URL handlers provided for the <code>on</code> method of ESP8266WebServer/WebServer with the function(). </li> <li>setup()    5.1 Sets URL handler the function() to ESP8266WebServer/WebServer by<code>ESP8266WebServer::on</code>/<code>WebServer::on</code>.    5.2 Starts <code>AutoConnect::begin()</code>.    5.3 Check WiFi connection status. </li> <li>loop()    6.1 Do the process for actual Sketch.    6.2 Invokes <code>AutoConnect::handleClient()</code>, or invokes <code>ESP8266WebServer::handleClient()</code>/<code>WebServer::handleClient</code> then <code>AutoConnect::handleRequest()</code>. </li> </ol>"},{"location":"basicusage.html#2-declare-autoconnect-object","title":"2. Declare AutoConnect object","text":"<p>Two options are available for AutoConnect constructor.</p> <p><pre><code>AutoConnect VARIABLE(&amp;ESP8266WebServer);  // For ESP8266\nAutoConnect VARIABLE(&amp;WebServer);         // For ESP32\n</code></pre> or</p> <pre><code>AutoConnect VARIABLE;\n</code></pre> <ul> <li> <p>The parameter with an ESP8266WebServer/WebServer variable: An ESP8266WebServer/WebServer object variable must be declared. AutoConnect uses its variable to handles the AutoConnect menu.</p> </li> <li> <p>With no parameter: the Sketch does not declare ESP8266WebServer/WebServer object. In this case, AutoConnect allocates an instance of the ESP8266WebServer/WebServer internally. The logic sequence of the Sketch is somewhat different as the above. To register a URL handler function by ESP8266WebServer::on or WebServer::on should be performed after AutoConnect::begin.</p> </li> </ul>"},{"location":"basicusage.html#3-no-need-wifibegin","title":"3. No need WiFI.begin(...)","text":"<p>AutoConnect internally performs WiFi.begin to establish a WiFi connection. There is no need for a general process to establish a connection using WiFi.begin with a Sketch code.</p>"},{"location":"basicusage.html#4-alternate-esp8266webserverbegin-and-webserverbegin","title":"4. Alternate ESP8266WebServer::begin() and WebServer::begin()","text":"<p>AutoConnect::begin executes ESP8266WebServer::begin/WebServer::begin internally too and it starts the DNS server to behave as a Captive portal. So it is not needed to call ESP8266WebServer::begin/WebServer::begin in the Sketch.</p> <p>Why DNS Server starts</p> <p>AutoConnect traps the detection of the captive portal and achieves a connection with the WLAN interactively by the AutoConnect menu. It responds SoftAP address to all DNS queries temporarily to trap. Once a WiFi connection establishes, the DNS server contributed by AutoConnect stops.</p>"},{"location":"basicusage.html#5-autoconnectbegin-with-ssid-and-password","title":"5. AutoConnect::begin with SSID and Password","text":"<p>SSID and Password can also specify by AutoConnect::begin. ESP8266/ESP32 uses provided SSID and Password explicitly. If the connection false with specified SSID with Password then a captive portal is activated. SSID and Password are not present, ESP8266 SDK will attempt to connect using the still effectual SSID and password. Usually, it succeeds.</p>"},{"location":"basicusage.html#6-use-esp8266webserveron-and-webserveron-to-handle-url","title":"6. Use ESP8266WebServer::on and WebServer::on to handle URL","text":"<p>AutoConnect is designed to coexist with the process for handling the web pages by user Sketches. The page processing function which will send an HTML to the client invoked by the \"on::ESP8266WebServer\" or the \"on::WebServer\" function is the same as when using ESP8266WebServer/WebServer natively.</p>"},{"location":"basicusage.html#7-use-either-esp8266webserverhandleclientwebserverhandleclient-or-autoconnecthandleclient","title":"7. Use either ESP8266WebServer::handleClient()/WebServer::handleClient() or AutoConnect::handleClient()","text":"<p>Both classes member function name is the same: handleClient, but the behavior is different. Using the AutoConnect embedded along with ESP8266WebServer::handleClient/WebServer::handleClient has limitations. Refer to the below section for details. </p>"},{"location":"basicusage.html#esp8266webserverwebserver-hosted-or-parasitic","title":"ESP8266WebServer/WebServer hosted or parasitic","text":"<p>The interoperable process with an ESP8266WebServer/WebServer depends on the parameters of the AutoConnect constructor.</p> Declaration parameter for the constructor Use ESP8266WebServer::handleClient or WebServer::handleClient only Use AutoConnect::handleClient None AutoConnect menu not available.To use AutoConnect menu, need AutoConnect::handleRequest().also to use ESP8266WebServer/WebServer natively, need AutoConnect::host(). AutoConnect menu available.To use ESP8266WebServer/WebServer natively, need AutoConnect::host(). Reference to ESP8266WebServer/WebServer AutoConnect menu not available.To use AutoConnect menu, need AutoConnect::handleRequest(). AutoConnect menu available. <ul> <li> <p>By declaration for the AutoConnect variable with no parameter: The ESP8266WebServer/WebServer instance is hosted by AutoConnect automatically then the Sketches use AutoConnect::host as API to get it after AutoConnect::begin performed.</p> </li> <li> <p>By declaration for the AutoConnect variable with the reference of ESP8266WebServer/WebServer: AutoConnect will use it. the Sketch can use it is too.</p> </li> <li> <p>In use ESP8266WebServer::handleClient()/WebServer::handleClient(): AutoConnect menu can be dispatched but not works normally. It is necessary to call AutoConnect::handleRequest after ESP8255WebServer::handleClient/WebServer::handleClient invoking.</p> </li> <li> <p>In use AutoConnect::handleClient(): The handleClient() process and the AutoConnect menu is available without calling ESP8266WebServer::handleClient.</p> </li> </ul> <p>Why AutoConnect::handleRequest is needed when using ESP8266WebServer::handleClient/WebServer::handleClient</p> <p>The AutoConnect menu function may affect WiFi connection state. It follows that the menu process must execute outside ESP8266WebServer::handleClient and WebServer::handleClient. AutoConnect::handleClient is equivalent ESP8266WebServer::handleClient and WEbServer::handleClient included AutoConnect::handleRequest.</p>"},{"location":"basicusage.html#reducing-binary-size","title":"Reducing Binary Size","text":"<p>Typically, AutoConnect components include AutoConnectAux for handling Custom Web pages; AutoConnectAux plays a central role in responding to requests for Custom Web pages. It also incorporates several AutoConnectElements used in the sketch, which may exceed 1 MB in binary size after the build. To reduce the binary size, you can deactivate the component to handle these custom web pages, depending on the use case. If your sketch does not use Custom web pages, allows you to exclude the AutoConnectAux component to reduce the built binary size.</p> <p><code>AutoConnect.h</code> header file enables all AutoConnect components. In a normal sketch, including this header enables all AutoConnect functionality. On the other hand, for sketches that don't use custom web pages, you can apply the <code>AutoConnectCore.h</code> header file.</p> <p><code>AutoConnectCore.h</code> provides an AutoConnect class that excludes AutoConnectAux and AutoConnectElements from AutoConnect. Therefore, it does not implement the APIs required for custom web page processing. Also, AutoConnectOTA and AutoConnectUpdate cannot be used. (i.e., to use AutoConnect's equipped OTA Update feature, you must include the full AutoConnect component in your sketch) Instead, the binary size of the AutoConnectCore component is reduced by about 170 KB (1.3 KB for RAM) compared to the ESP32 AutoConnect full component. (60KB for ESP8266)</p> <p>To switch between AutoConnect and AutoConnectCore, simply change the corresponding header file with <code>#include</code> header.</p>"},{"location":"basicusage.html#using-autoconnect-full-component","title":"Using AutoConnect Full component","text":"<pre><code>#include &lt;WiFi.h&gt;\n#include &lt;WebServer.h&gt;\n#include &lt;AutoConnect.h&gt;\nstatic const char PAGE_HELLO[] = R\"(\n{\n  \"uri\": \"/\",\n  \"title\": \"Hello\",\n  \"menu\": false,\n  \"element\": [\n    {\n      \"name\": \"caption\",\n      \"type\": \"ACText\",\n      \"value\": \"Hello, World\"\n    },\n  ]\n}\n)\";\n\nWebServer Server;\nAutoConnect Portal(Server);\nAutoConnectConfig Config;\n\nvoid setup() {\n  delay(1000);\n  Serial.begin(115200);\n  Serial.println();\n\n  Config.ota = AC_OTA_BUILTIN;\n  Portal.config(Config);\n\n  portal.load(PAGE_HELLO);\n  Portal.begin();\n  Serial.println(\"Web Server started:\" + WiFi.localIP().toString());\n}\n\nvoid loop() {\n  Portal.handleClient();\n}\n</code></pre>"},{"location":"basicusage.html#using-autoconnectcore-without-custom-web-pages-and-ota-update-facilities","title":"Using AutoConnectCore without Custom Web pages and OTA Update facilities","text":"<p>Even in the sketch with <code>AutoConnectCore.h</code> applied, the class name remains <code>AutoConnect</code>.</p> <pre><code>#include &lt;WiFi.h&gt;\n#include &lt;WebServer.h&gt;\n#include &lt;AutoConnectCore.h&gt;\nWebServer Server;\nAutoConnect Portal(Server);\nvoid rootPage() {\nchar content[] = \"Hello, World\";\n  Server.send(200, \"text/plain\", content);\n}\n\nvoid setup() {\n  delay(1000);\n  Serial.begin(115200);\n  Serial.println();\n\n  Server.on(\"/\", rootPage);\n  Portal.begin();\n  Serial.println(\"Web Server started:\" + WiFi.localIP().toString());\n}\n\nvoid loop() {\n  Portal.handleClient();\n}\n</code></pre> <p>Either <code>AutoConnect.h</code> or <code>AutoConnectCore.h</code></p> <p>A sketch can include either <code>AutoConnect.h</code> or <code>AutoConnectCore.h</code>. These two header files are mutually exclusive and cannot be included together at the same time. Also, If the sketch includes <code>AutoConnectCore.h</code>, some members involved in the custom web page facility are excluded from AutoConnectConfig class.</p> <ol> <li> <p>Each VARIABLE conforms to the actual declaration in the Sketches.\u00a0\u21a9</p> </li> <li> <p>WiFi SSID and Password can be specified AutoConnect::begin() too.\u00a0\u21a9</p> </li> <li> <p>Replacement the handleClient method is not indispensable. AutoConnect can still connect with the captive portal as it is ESP8266WebServer::handleClient. But it can not valid AutoConnect menu.\u00a0\u21a9</p> </li> </ol>"},{"location":"changelabel.html","title":"Change label text","text":""},{"location":"changelabel.html#change-the-items-label-text","title":"Change the item's label text","text":"<p>You can change the text of AutoConnect menu items. The easiest way is to rewrite the header file directly in the library that defines the menu label. Advanced Usage section describes the detailed how to change the label text directly.</p> <p>However, this way is less preferred as it modifies the library code and further affects the entire Arduino project you compile. So, here's how to change the label text for each Arduino project without directly modifying the library code. Using this method, you can also display the label text and fixed text on AutoConnect pages in your national language.</p> <p>(e.g. in Japanese) </p>"},{"location":"changelabel.html#preparation","title":"Preparation","text":"<p>AutoConnect needs a definition file as c++ header (.h) to change the label text. It is used when your Arduino project is compiled, and there is no additional memory consumption due to changing the label text. This header file describes each fixed text of AutoConnect with the <code>#define</code> preprocessor directive.</p> <p>The next thing you need is PlatformIO. PlatformIO is a very powerful environment for embedded development with multi-platform and multi-architecture build systems. And you can easily set up a PlatformIO for the Arduino development system as follows on your host machine.</p> <ul> <li>Microsoft Visual Studio Code</li> <li>PlatformIO IDE (included PlatformIO core)</li> </ul> <p>Install PlatformIO and VSCode</p> <p>Please refer to the official documentation for PlatformIO and VSCode installation.</p> <p>The rest of this section assumes that you have a PlatformIO environment with VSCode as the front end that has installed on your host machine.</p>"},{"location":"changelabel.html#how-to-change-the-label-text","title":"How to change the label text","text":""},{"location":"changelabel.html#label-text-replacement-header-file","title":"Label text replacement header file","text":"<p>AutoConnect label texts are pre-assigned with a fixed string so that it can be determined at compile time. Their default definitions are in the <code>AutoConnectLabels.h</code> file that has all the replaceable label text defined by the <code>#define</code> directive.</p> Label placedPre-defined textID (#define macro) Menu itemConfigure new APAUTOCONNECT_MENULABEL_CONFIGNEW Open SSIDsAUTOCONNECT_MENULABEL_OPENSSIDS DisconnectAUTOCONNECT_MENULABEL_DISCONNECT Reset...AUTOCONNECT_MENULABEL_RESET HOMEAUTOCONNECT_MENULABEL_HOME UpdateAUTOCONNECT_MENULABEL_UPDATE Device infoAUTOCONNECT_MENULABEL_DEVINFO Button labelRESETAUTOCONNECT_BUTTONLABEL_RESET UPDATEAUTOCONNECT_BUTTONLABEL_UPDATE Page titlePage not foundAUTOCONNECT_PAGETITLE_NOTFOUND AutoConnect configAUTOCONNECT_PAGETITLE_CONFIG AutoConnect connectingAUTOCONNECT_PAGETITLE_CONNECTING AutoConnect connection failedAUTOCONNECT_PAGETITLE_CONNECTIONFAILED AutoConnect credentialsAUTOCONNECT_PAGETITLE_CREDENTIALS AutoConnect disconnectedAUTOCONNECT_PAGETITLE_DISCONNECTED AutoConnect resettingAUTOCONNECT_PAGETITLE_RESETTING AutoConnect statisticsAUTOCONNECT_PAGETITLE_STATISTICS Page:[statistics] rowEstablished connectionAUTOCONNECT_PAGESTATS_ESTABLISHEDCONNECTION ModeAUTOCONNECT_PAGESTATS_MODE IPAUTOCONNECT_PAGESTATS_IP GWAUTOCONNECT_PAGESTATS_GATEWAY Subnet maskAUTOCONNECT_PAGESTATS_SUBNETMASK SoftAP IPAUTOCONNECT_PAGESTATS_SOFTAPIP AP MACAUTOCONNECT_PAGESTATS_APMAC STA MACAUTOCONNECT_PAGESTATS_STAMAC ChannelAUTOCONNECT_PAGESTATS_CHANNEL dBmAUTOCONNECT_PAGESTATS_DBM Chip IDAUTOCONNECT_PAGESTATS_CHIPID CPU Freq.AUTOCONNECT_PAGESTATS_CPUFREQ Flash sizeAUTOCONNECT_PAGESTATS_FLASHSIZE Free memoryAUTOCONNECT_PAGESTATS_FREEMEM Page:[config] textTotal:AUTOCONNECT_PAGECONFIG_TOTAL Hidden:AUTOCONNECT_PAGECONFIG_HIDDEN SSIDAUTOCONNECT_PAGECONFIG_SSID PassphraseAUTOCONNECT_PAGECONFIG_PASSPHRASE Enable DHCPAUTOCONNECT_PAGECONFIG_ENABLEDHCP ApplyAUTOCONNECT_PAGECONFIG_APPLY Page:[open SSIDs] textDelete a credential?AUTOCONNECT_TEXT_DELETECREDENTIAL could not deletedAUTOCONNECT_TEXT_COULDNOTDELETED Page:[update] textUpdating firmwareAUTOCONNECT_TEXT_UPDATINGFIRMWARE Select firmware:AUTOCONNECT_TEXT_SELECTFIRMWARE Successfully updated, rebooting...AUTOCONNECT_TEXT_OTASUCCESS Failed to update:AUTOCONNECT_TEXT_OTAFAILURE Page:[connection failed]Connection FailedAUTOCONNECT_PAGECONNECTIONFAILED_CONNECTIONFAILED TextNo saved credentials.AUTOCONNECT_TEXT_NOSAVEDCREDENTIALS Menu TextConnectingAUTOCONNECT_MENUTEXT_CONNECTING DisconnectAUTOCONNECT_MENUTEXT_DISCONNECT FailedAUTOCONNECT_MENUTEXT_FAILED <p>The definition of label text must conform to a certain coding pattern. Undefine with <code>#undef</code> the <code>#define</code> directive corresponding to the above IDs, and then redefine the ID with the replacement text. And surround it with <code>#ifdef</code> ~ <code>#endif</code>.</p> <pre><code>#ifdef AUTOCONNECT_MENULABEL_CONFIGNEW\n#undef AUTOCONNECT_MENULABEL_CONFIGNEW\n#define AUTOCONNECT_MENULABEL_CONFIGNEW   \"NEW_STRING_YOU_WISH\"\n#endif\n</code></pre> <p>You may not need to rewrite all definitions. It depends on your wishes and is sufficient that the above the include file contains only the labels you need.</p>"},{"location":"changelabel.html#configuration-of-platformioini","title":"Configuration of platformio.ini","text":"<p>You prepare its header file and place it in the <code>src</code> folder of the project folder. You can name the file whatever you like, but for the sake of explanation, let's say <code>mylabels.h</code>.</p> <p>When you store <code>mylabels.h</code> containing the new label text definition in the <code>src</code> folder, your Arduino project folder structure should look like this:</p> <pre><code>&lt;Project folder&gt;\n|-- &lt;pio&gt;\n|-- &lt;.vscode&gt;\n|-- &lt;include&gt;\n|-- &lt;lib&gt;\n|-- &lt;src&gt;\n|   |-- main.cpp\n|   |-- mylabels.h  &lt;-- Depends on the project\n|-- &lt;test&gt;\n|-- .gitignore\n|-- .travis.yml\n|-- platformio.ini\n</code></pre> <p>Then, open <code>platformio.ini</code> file and add new <code>build_flags</code> for including <code>mylabels.h</code> to override the label text.</p> <pre><code>build_flags = -DAC_LABELS='\"${PROJECT_SRC_DIR}/mylabels.h\"'\n</code></pre> <p>Just change the <code>mylabels.h</code></p> <p>Keep <code>-DAC_LABELS='\"${PROJECT_SRC_DIR}/YOUR_FILE_NAME\"'</code> when changing the above <code>build_flags</code> item to match your labels header file name.</p> <p>After placing the <code>mylabels.h</code> file and add the <code>build_flags</code>, build the project with the replaced label text. You will see the AutoConnect screen with the new text replaced by <code>mylabels.h</code>.</p> <p>Need clean-up before re-build with updated <code>mylabels.h</code></p> <p>When you have updated <code>mylabels.h</code>, you need deleting compiled library object files before build. Use <code>Clean</code> of a PlatformIO task on VSCode status bar. <p></p> <p></p></p>"},{"location":"changelog.html","title":"Change log","text":""},{"location":"changelog.html#142-jan-31-2023","title":"[1.4.2] Jan. 31, 2023","text":""},{"location":"changelog.html#enhancements","title":"Enhancements","text":"<ul> <li>Supports whileConnecting exit called while waiting for WiFi connection.</li> <li>Added AutoConnect::portalStatus function.</li> </ul>"},{"location":"changelog.html#fix","title":"Fix","text":"<ul> <li>Fixed compilation error with ESP8266 Arduino Core 3.1.0 or later. </li> </ul>"},{"location":"changelog.html#141-jan-5-2023","title":"[1.4.1] Jan. 5, 2023","text":""},{"location":"changelog.html#enhancements_1","title":"Enhancements","text":"<ul> <li>Supports asynchronous communication of custom web pages using the Fetch API. This allows interaction with the user without page transitions. See the chapter Interact between Sketch and AutoConnectElements for details.</li> <li>Added the FetchLED example.</li> <li>Added an AutoConnect::locate function.</li> </ul>"},{"location":"changelog.html#fix_1","title":"Fix","text":"<ul> <li>Fixed AutoConnectConfigBase constructor missing to AutoConnectConfigExt.</li> </ul>"},{"location":"changelog.html#140-nov-20-2022","title":"[1.4.0] Nov. 20, 2022","text":""},{"location":"changelog.html#enhancements_2","title":"Enhancements","text":"<ul> <li>Custom web page related features were decoupled to allow for two different configurations, AutoConnectCore and AutoConnect. AutoConnectCore reduces memory consumption by focusing only on WiFi connectivity utilities. See Reducing Binary Size chapter in the AutoConnect documentation for more information.</li> <li>Supports credentials backup and restoration.</li> <li>Added an AutoConnect::getCurrentCredential function.</li> <li>Added an AutoConnectAux::referer function.</li> <li>Added an AutoConnectConfig::preserveIP setting.</li> <li>Added the WebSocketServer example.</li> <li>Allow navigate to a custom URL once a WiFi connection is established.</li> <li>Revised mqttRSSI examples program structure.</li> </ul>"},{"location":"changelog.html#fix_2","title":"Fix","text":"<ul> <li>Fixed updateserver.py script security vulnerability.</li> </ul>"},{"location":"changelog.html#137-aug-20-2022","title":"[1.3.7] Aug. 20, 2022","text":""},{"location":"changelog.html#fix_3","title":"Fix","text":"<ul> <li>Fixed an authentication failure in Captive Portal state.</li> <li>Fixed loss of current SSID.</li> </ul>"},{"location":"changelog.html#136-jul-26-2022","title":"[1.3.6] Jul. 26, 2022","text":""},{"location":"changelog.html#fix_4","title":"Fix","text":"<ul> <li>Fixed OTA being incomplete.</li> </ul>"},{"location":"changelog.html#135-jun-03-2022","title":"[1.3.5] Jun. 03, 2022","text":""},{"location":"changelog.html#fix_5","title":"Fix","text":"<ul> <li>Fixed Fixed OTA exit not being called.</li> <li>Fixed an ambiguous type call with IPAddress.</li> <li>Fixed loss of response due to OTA session reset occurrence.</li> <li>Made fit the mqttRSSI examples to ThingSpeak's updated channel authentication.</li> </ul> <p>For ESP-IDF 4.4 with Arduino ESP32 Core</p> <p>AutoConnect 1.3.5 is the version compatible with both ESP-IDF 4.4 and ESP-IDF 3.3. It is recommended to use Arduino esp32 core 1.0.6 for ESP-IDF 3.3 based and Arduino esp32 core 2.0.3 or later for ESP-IDF 4.4 based. If you are using PlatformIO as your development platform, you can select any of these two versions by specifying them in platformio.ini file.</p> <ul> <li>For ESP-IDF 4.4 with Arduino ESP32 Core 2.0.3</li> </ul> <pre><code>framework = arduino\nplatform = espressif32@4.4.0\n</code></pre> <ul> <li>For ESO-IDF 3.3 with Arduino ESP32 Core 1.0.6</li> </ul> <pre><code>framework = arduino\nplatform = espressif32@3.5.0\n</code></pre>"},{"location":"changelog.html#134-mar-02-2022","title":"[1.3.4] Mar. 02, 2022","text":""},{"location":"changelog.html#enhancements_3","title":"Enhancements","text":"<ul> <li>Supports LittleFS_esp32 legacy library with ESP32 Arduino core 1.0.6 or less.</li> <li>Added enablement of credentials removal function with Open SSIDs menu.</li> <li>Migrate the CI platform to GitHub actions.</li> </ul>"},{"location":"changelog.html#fix_6","title":"Fix","text":"<ul> <li>Fixed AutoConnectOTA crashing if there is no OTA partition.</li> <li>Fixed AutoConnectUpdate crashing if there is no OTA partition.</li> </ul>"},{"location":"changelog.html#133-jan-25-2022","title":"[1.3.3] Jan. 25, 2022","text":""},{"location":"changelog.html#fix_7","title":"Fix","text":"<ul> <li>Fixed the missing initialization of MQTT parameter settings of mqttRSSI.ino example sketch.</li> <li>Reverted the MQTT API endpoint of Thingspeak.com in the mqttRSSI example sketches.</li> <li>Changed ESP32Cam XCLK to be attenuated to avoid interference with WiFi signals.</li> </ul>"},{"location":"changelog.html#132-jan-1-2022","title":"[1.3.2] Jan. 1, 2022","text":""},{"location":"changelog.html#enhancements_4","title":"Enhancements","text":"<ul> <li>Supports an AutoConnectRange as a new AutoConnectElement.</li> <li>Adds the <code>responsive</code> parameter with AutoConnectAux.</li> <li>Adds an <code>AutoConnectAux::redirect</code> function.</li> <li>Adds an example for using AutoConnect with the ESP32 camera driver as WebCamServer.</li> </ul>"},{"location":"changelog.html#fix_8","title":"Fix","text":"<ul> <li>Fixed an issue where a password is lost when SoftAP is stopped.</li> </ul>"},{"location":"changelog.html#131-oct-09-2021","title":"[1.3.1] Oct. 09, 2021","text":""},{"location":"changelog.html#fixes","title":"Fixes","text":"<ul> <li>Fixed an issue that was incompatible with ArduinoJson version 5.</li> <li>Fixed LittleFS mount check not working with ESP32.</li> <li>Fixed autoReconnect not being able to restore a static IP setting.</li> <li>Fixed that static IP settings were not cleared when loading credential.</li> </ul>"},{"location":"changelog.html#130-sep-25-2021","title":"[1.3.0] Sep. 25, 2021","text":""},{"location":"changelog.html#enhancements_5","title":"Enhancements","text":"<ul> <li>Supports ESP8266 3.0.0 Arduino core.</li> <li>Supports ESP32 Arduino core 2.0.0.</li> <li>Supports LittleFS with ESP32.</li> <li>Supports AutoConnectOTA status notifications.</li> <li>Supports AutoConnectConfigAux. (Preview)</li> <li>Supports to save credentials always.</li> <li>Adds a <code>style</code> attribute with AutoConnectInput.</li> <li>Adds the <code>div</code> tag generation with the AutoConnectElement.</li> <li>Adds <code>[]</code> operator with const char for AutoConnectAux.</li> <li>Adds <code>[]</code> operator with <code>__FlashStringHelper</code> for AutoConnectAux.</li> <li>Adds <code>AutoConnectAux::content</code> function to get a number of AutoConnectElements.</li> <li>Adds <code>AutoConnect::getConfig</code> function to get an actual instance of AutoConnectConfig.</li> </ul>"},{"location":"changelog.html#fixes_1","title":"Fixes","text":"<ul> <li>Fixed CSS attribute missing of AutoConnectInput with the number type.</li> <li>Fixed garbage being mixed in a loaded credential.</li> <li>Fixed the output place of Posterior attribute for AutoConnectRadio.</li> <li>Improved the the calculation for the size of ArduinoJson document.</li> <li>Fixed Incomplete deletion with AutoConnectCredential.</li> <li>Fixed credentials not erased correctly.</li> <li>Fixed AutoConnectText posterior being unavailable.</li> </ul>"},{"location":"changelog.html#123-jan-3-2021","title":"[1.2.3] Jan. 3, 2021","text":""},{"location":"changelog.html#enhancements_6","title":"Enhancements","text":"<ul> <li>Improved memory management.</li> </ul> <p>PageBuilder v1.5.0 is required</p> <p>Since AutoConnect v1.2.3, PageBuilder v1.5.0 or later is required. Please update PageBuilder to latest version.</p>"},{"location":"changelog.html#122-dec-13-2020","title":"[1.2.2] Dec. 13, 2020","text":""},{"location":"changelog.html#fix_9","title":"Fix","text":"<ul> <li>Fixed an issue where OTA updates would crash on the ESP32 platform. (issue #284)   With this fix, <code>AUTOCONNECT_UPLOAD_ASFIRMWARE_USE_REGEXP</code> must be enabled for regular expressions to be enabled in <code>AUTOCONNECT_UPLOAD_ASFIRMWARE</code>.</li> </ul>"},{"location":"changelog.html#121-dec-5-2020","title":"[1.2.1] Dec. 5, 2020","text":""},{"location":"changelog.html#fix_10","title":"Fix","text":"<ul> <li>Fixed that not declared error with <code>AUTOCONNECT_NOUSE_JSON</code>. (issue #282)</li> </ul>"},{"location":"changelog.html#120-dec-3-2020","title":"[1.2.0] Dec. 3, 2020","text":""},{"location":"changelog.html#new-features","title":"New features","text":"<ul> <li>Supports a whileCaptivePortal exit. (issue #149, issue #244)</li> <li>Supports an onConnect exit.</li> <li>Supports HTTP authentication. (issue #171)</li> </ul>"},{"location":"changelog.html#enhancements_7","title":"Enhancements","text":"<ul> <li>Added <code>AUTOCONNECT_APKEY_SSID</code> definition to seek access points by SSID. (issue #251)</li> <li>Added AutoConnect::append and AutoConnect::detach function that can be dynamically AutoConnectAux attaching and detaching. (issue #230)</li> <li>Added AutoConnect::getEEPROMUsedSize that notifies the occupied size of the credential storage area. (issue #209)</li> <li>Added AutoConnectConfig::beginTimeout setting. (issue #247)</li> <li>Added AutoConnectConfig::preserveAPMode setting. (issue #210)</li> <li>Enable support for the LittleFS as filesystem with ESP8266 platform.</li> <li>Enhanced AutoConnectInput to allow accepts password and number type. (issue #237, issue #255)</li> <li>Enhanced handleClient to dynamically launch the captive portal when losing WiFi connection.</li> <li>Enhanced the ability to upload a regular file with AutoConnectOTA. (issue #236)</li> <li>Enhanced ticker to work even in handleClient loop.</li> <li>Improved autoReconnect to work even in handleClient loop. (issue #234, issue #251)</li> </ul>"},{"location":"changelog.html#fixes_2","title":"Fixes","text":"<ul> <li>Avoids an empty-body warning when <code>AC_DEBUG</code> is disabled. (issue #218)</li> <li>Fixed a core panic in the regex with ESP32.</li> <li>Fixed an exception in the AutoConnect::end function.</li> <li>Fixed an invalid SPIFFS compile error with ESP32.</li> <li>Fixed deficiently forward references with HandleClient.ino example. (PR #275)</li> <li>Fixed incorrect connection wait time. (issue #216)</li> <li>Fixed not being able to specify channel ID with a mqttRSSI.ino example. (issue #262)</li> <li>Fixed posterior being disabled in AutoConnectElement.</li> </ul>"},{"location":"changelog.html#117-apr-19-2020","title":"[1.1.7] Apr. 19, 2020","text":""},{"location":"changelog.html#fixes_3","title":"Fixes","text":"<ul> <li>Fixed Apply button not work.</li> </ul>"},{"location":"changelog.html#116-apr-17-2020","title":"[1.1.6] Apr. 17, 2020","text":""},{"location":"changelog.html#fixes_4","title":"Fixes","text":"<ul> <li>Fixed OTA page translation not work.</li> </ul>"},{"location":"changelog.html#115-apr-15-2020","title":"[1.1.5] Apr. 15, 2020","text":""},{"location":"changelog.html#new-features_1","title":"New features","text":"<ul> <li>Supports AutoConnect menu configuration.</li> <li>Supports the built-in OTA feature as AutoConnectOTA.</li> </ul>"},{"location":"changelog.html#enhancements_8","title":"Enhancements","text":"<ul> <li>Enhanced allows the AutoConnect::begin to connect to the access point in order of signal strength. This option can specify the order of connection attempting according to the WiFi signal strength indicated with RSSI.</li> <li>Changed the bootUri behavior to be an automatic pop-up at the captive portal.</li> </ul>"},{"location":"changelog.html#114-feb-14-2020","title":"[1.1.4] Feb. 14, 2020","text":""},{"location":"changelog.html#new-features_2","title":"New features","text":"<ul> <li>Supports for overriding text of the menu items with user-defined labels.</li> </ul>"},{"location":"changelog.html#fixes_5","title":"Fixes","text":"<ul> <li>Fixed the compiler warning with experimental WiFi mode of ESP8266.</li> </ul>"},{"location":"changelog.html#113-jan-1-2020","title":"[1.1.3] Jan. 1, 2020","text":""},{"location":"changelog.html#enhancements_9","title":"Enhancements","text":"<ul> <li>Improved Config New button behavior.</li> <li>Added <code>AUTOCONNECT_NOUSE_JSON</code> directive</li> </ul>"},{"location":"changelog.html#fixes_6","title":"Fixes","text":"<ul> <li>Fixed relocate Config New menu URI inability.</li> <li>Removed compiler warning of unused.</li> </ul>"},{"location":"changelog.html#112-oct-22-2019","title":"[1.1.2] Oct. 22, 2019","text":""},{"location":"changelog.html#fixes_7","title":"Fixes","text":"<ul> <li>Fixed a crash when no SSID found.</li> <li>Fixed memory leak on destruction.</li> </ul>"},{"location":"changelog.html#111-oct-17-2019","title":"[1.1.1] Oct. 17, 2019","text":""},{"location":"changelog.html#fixes_8","title":"Fixes","text":"<ul> <li>Fixed crash with unique_ptr deleting reference content.</li> <li>Fixed disconnection request initialization missing.</li> </ul>"},{"location":"changelog.html#110-oct-15-2019","title":"[1.1.0] Oct. 15, 2019","text":""},{"location":"changelog.html#enhancements_10","title":"Enhancements","text":"<ul> <li>Enhanced to be able to specify static IP in the Configure new AP menu.</li> </ul>"},{"location":"changelog.html#fixes_9","title":"Fixes","text":"<ul> <li>Fixed compilation error that no member named 'printTo' with ArduinoJson version 5.</li> </ul>"},{"location":"changelog.html#103-sept-30-2019","title":"[1.0.3] Sept. 30, 2019","text":""},{"location":"changelog.html#fixes_10","title":"Fixes","text":"<ul> <li>Fixed a return of AutoConnectCredential::entries().</li> </ul>"},{"location":"changelog.html#102-sept-19-2019","title":"[1.0.2] Sept. 19, 2019","text":""},{"location":"changelog.html#fixes_11","title":"Fixes","text":"<ul> <li>Fixed compilation error that no member named 'success' with ArduinoJson version 5.</li> <li>Fixed SSID non termination.</li> <li>Fixed compilation error that getBytesLength missing with ESP32.</li> <li>Added #include directive restriction for EEPROM and ESP8266httpUpdate to FAQ.</li> </ul>"},{"location":"changelog.html#101-sept-13-2019","title":"[1.0.1] Sept. 13, 2019","text":""},{"location":"changelog.html#enhancements_11","title":"Enhancements","text":"<ul> <li>Added an example sketch for ESP32 boards that migrates credentials stored in EEPROM partition to the Preferences.</li> </ul>"},{"location":"changelog.html#100-sept-7-2019","title":"[1.0.0] Sept. 7, 2019","text":""},{"location":"changelog.html#new-features_3","title":"New features","text":"<ul> <li>Supports AutoConnectUpdate for the OTA update.</li> </ul>"},{"location":"changelog.html#enhancements_12","title":"Enhancements","text":"<ul> <li>Supported Arduino core for ESP32 1.0.3.</li> <li>Added AutoConnectAux::isValid function.</li> <li>Added the <code>global</code> attribute with all AutoConnectElements.</li> <li>Changed the credential storage area to Preferences with ESP32 core 1.0.3 and later. In ESP32, the credentials stored past in EEPROM will lose.</li> </ul>"},{"location":"changelog.html#0912-aug-18-2019","title":"[0.9.12] Aug. 18, 2019","text":""},{"location":"changelog.html#fixes_12","title":"Fixes","text":"<ul> <li>Fixed missing captive portal notifications on the newer mobile OS client. As a result of this fix, the SoftAP default IP address and gateway have been changed to <code>172.217.28.1</code>.</li> </ul>"},{"location":"changelog.html#0911-july-13-2019","title":"[0.9.11] July 13, 2019","text":""},{"location":"changelog.html#new-features_4","title":"New features","text":"<ul> <li>Supports new element as AutoConnectSytle that can insert the custom CSS into AutoConnectAux page.</li> </ul>"},{"location":"changelog.html#enhancements_13","title":"Enhancements","text":"<ul> <li>Supports that <code>&lt;br&gt;</code> tags can now be added to each element.</li> <li>Supports that able to place the checkbox label forward or backward.</li> <li>Supports flicker signal output according to the status of WiFi_mode.</li> <li>Supports AutoConnectAux::fetchElement function to retrieve inputted element values via a custom Web page.</li> </ul>"},{"location":"changelog.html#fixes_13","title":"Fixes","text":"<ul> <li>Fixed bug in AutoConnectCredential when offset is &gt;256.</li> </ul>"},{"location":"changelog.html#0910-june-12-2019","title":"[0.9.10] June 12, 2019","text":""},{"location":"changelog.html#fixes_14","title":"Fixes","text":"<ul> <li>Fixed the unable to get AutoConnectElemets values in the sketch with ESP8266 arduino core 2.5.2.</li> </ul>"},{"location":"changelog.html#099-may-25-2019","title":"[0.9.9] May 25, 2019","text":""},{"location":"changelog.html#enhancements_14","title":"Enhancements","text":"<ul> <li>Supports ESP8266 Arduino core 2.5.2.</li> <li>Menu text/background color can be statically customized.</li> <li>Added the enable  attribute to the AutoConnectElements. This attribute gives dynamically change to the element activation during the sketch executing.</li> <li>Added ID attribute to HTML tag generated from AutoConnectText.</li> </ul>"},{"location":"changelog.html#fixes_15","title":"Fixes","text":"<ul> <li>Fixed the input box layout collapsed.</li> <li>Fixed that the decoration of AutoConnectButton was disabled.</li> <li>Fixed that the value remains even after clearing the option with AutoConnectSelect.</li> <li>Fixed that an alignment violation exception occurred when loading AutoConnectAux described by JSON with PROGMEM attribute.</li> </ul>"},{"location":"changelog.html#098-may-3-2019","title":"[0.9.8] May 3, 2019","text":""},{"location":"changelog.html#new-features_5","title":"New features","text":"<ul> <li>Supports new element type AutoConnectFile and built-in file uploader.</li> </ul>"},{"location":"changelog.html#enhancements_15","title":"Enhancements","text":"<ul> <li>Enhanced to support ArduinoJson 6.9.1 or later.</li> <li>Enhanced to use PSRAM on ESP32 module as the buffer allocation destination of JsonDocument with ArduinoJson 6.10.0 or later.</li> <li>Added an operator<code>[]</code> as a shortcut for AutoConnectAux::getElement function.</li> <li>Added an AutoConnectElement::as&lt;T&gt; function to easily coding for conversion from an AutoConnectElement to an actual type.</li> <li>Added a format attribute with the AutoConnectText element.</li> <li>Added a selected attribute with the AutoConnectSelect element.</li> <li>Enhanced AutoConnectAux::loadElement with multiple elements loading.</li> <li>Changed menu labels placement in source files structure.</li> <li>Changed API interface of AutoConnect::where function.</li> </ul>"},{"location":"changelog.html#fixes_16","title":"Fixes","text":"<ul> <li>Fixed blank page responds with Configure new.</li> <li>Fixed loading elements value missing.</li> <li>Fixed losing elements in saveElement with ArduinoJson version 6.</li> <li>Fixed compile error with older than ESP8266 core 2.5.0.</li> </ul>"},{"location":"changelog.html#097-jan-25-2019","title":"[0.9.7] Jan. 25, 2019","text":""},{"location":"changelog.html#new-features_6","title":"New features","text":"<ul> <li>Supports AutoConnect menu extension by user sketch with AutoConnectAux.</li> <li>Supports loading and saving of user-defined parameters with JSON format.</li> </ul>"},{"location":"changelog.html#enhancements_16","title":"Enhancements","text":"<ul> <li>Improved the WiFi connection sequence at the first WiFi.begin. Even if AutoConnectConfig::autoReconnect is disabled when SSID and PSK are not specified, it will use the information of the last established access point. The autoReconnect option will achieve trying the connect after a previous connection failed.</li> <li>Added the AutoConnectConfig::immediateStart option and immediately starts the portal without first trying WiFi.begin. You can start the captive portal at any time in combination with the AutoConnectConfig::autoRise option.</li> <li>Improved boot uri after reset. AutoConnectConfig::bootUri can be specified either /_ac or HOME path as the uri to be accessed after invoking Reset from AutoConnect menu.</li> <li>Improved source code placement of predefined macros. Defined common macros have been moved to <code>AutoConnectDefs.h</code>.</li> <li>Added AutoConnectConfig::hostName. It activates <code>WiFi.hostname()</code>/<code>WiFi.setHostName()</code>.</li> <li>Added the captive portal time-out. It can be controlled by AutoConnectConfig::portalTimeout and AutoConnectConfig::retainPortal.</li> </ul>"},{"location":"changelog.html#fixes_17","title":"Fixes","text":"<ul> <li>Fixed crash in some environments. Thank you @ageurtse</li> </ul>"},{"location":"changelog.html#096-sept27-2018","title":"[0.9.6] Sept.27, 2018.","text":""},{"location":"changelog.html#enhancements_17","title":"Enhancements","text":"<ul> <li>Improvement of RSSI detection for saved SSIDs.</li> </ul>"},{"location":"changelog.html#fixes_18","title":"Fixes","text":"<ul> <li>Fixed disconnection SoftAP completely at the first connection phase of the AutoConnect::begin.</li> </ul>"},{"location":"changelog.html#095-aug27-2018","title":"[0.9.5] Aug.27, 2018.","text":""},{"location":"changelog.html#enhancements_18","title":"Enhancements","text":"<ul> <li>Supports ESP32.</li> </ul>"},{"location":"changelog.html#fixes_19","title":"Fixes","text":"<ul> <li>Fixed that crash may occur if the number of stored credentials in the EEPROM is smaller than the number of found WiFi networks.</li> </ul>"},{"location":"changelog.html#094-may-5-2018","title":"[0.9.4] May 5, 2018.","text":""},{"location":"changelog.html#new-features_7","title":"New features","text":"<ul> <li>Supports AutoConnectConfig::autoReconnect option, it will scan the WLAN when it can not connect to the default SSID, apply the applicable credentials if it is saved, and try reconnecting.</li> </ul>"},{"location":"changelog.html#enhancements_19","title":"Enhancements","text":"<ul> <li>Automatically focus Passphrase after selecting SSID with Configure New AP.</li> </ul>"},{"location":"changelog.html#093-march-23-2018","title":"[0.9.3] March 23, 2018.","text":""},{"location":"changelog.html#enhancements_20","title":"Enhancements","text":"<ul> <li>Supports a static IP address assignment.</li> </ul>"},{"location":"changelog.html#092-march-19-2018","title":"[0.9.2] March 19, 2018.","text":""},{"location":"changelog.html#enhancements_21","title":"Enhancements","text":"<ul> <li>Improvement of string literal declaration with the examples, no library change.</li> </ul>"},{"location":"changelog.html#091-march-13-2018","title":"[0.9.1] March 13, 2018.","text":"<ul> <li>A release of the stable.</li> </ul>"},{"location":"colorized.html","title":"Custom colorized","text":""},{"location":"colorized.html#autoconnect-menu-colorizing","title":"AutoConnect menu colorizing","text":"<p>You can easily change the color of the AutoConnect menu. Menu colors can be changed statically by the AutoConnect menu color definition determined at compile time. You cannot change the color while the Sketch is running.</p> <p>The menu color scheme has been separated to <code>AutoConnectLabels.h</code> placed the AutoConnect library folder.1 You can change the color scheme of the menu with the following three color codes. The color code also accepts CSS standard color names.2</p> <p>In <code>AutoConnectLabels.h</code> you can find three definition macros for menu colors:</p> <ul> <li> <p>#define AUTOCONNECT_MENUCOLOR_TEXT Defines the menu text color.</p> </li> <li> <p>#define AUTOCONNECT_MENUCOLOR_BACKGROUND Defines the menu background color.</p> </li> <li> <p>#define AUTOCONNECT_MENUCOLOR_ACTIVE Defines the active menu item background color.</p> </li> </ul>"},{"location":"colorized.html#typical-color-schemes","title":"Typical color schemes","text":"<p>Here are some color schemes picked up.</p>"},{"location":"colorized.html#indigo","title":"Indigo","text":"<pre><code>#define AUTOCONNECT_MENUCOLOR_TEXT        \"#ffa500\"\n#define AUTOCONNECT_MENUCOLOR_BACKGROUND  \"#1a237e\"\n#define AUTOCONNECT_MENUCOLOR_ACTIVE      \"#283593\"\n</code></pre>"},{"location":"colorized.html#dim-gray","title":"Dim-gray","text":"<pre><code>#define AUTOCONNECT_MENUCOLOR_TEXT        \"#fffacd\"\n#define AUTOCONNECT_MENUCOLOR_BACKGROUND  \"#696969\"\n#define AUTOCONNECT_MENUCOLOR_ACTIVE      \"#808080\"\n</code></pre>"},{"location":"colorized.html#brown","title":"Brown","text":"<pre><code>#define AUTOCONNECT_MENUCOLOR_TEXT        \"#e6e6fa\"\n#define AUTOCONNECT_MENUCOLOR_BACKGROUND  \"#3e2723\"\n#define AUTOCONNECT_MENUCOLOR_ACTIVE      \"#4e342e\"\n</code></pre> <ol> <li> <p>Usually, it will locate to the Arduino/libraries/AutoConnect/src folder of user documents.\u00a0\u21a9</p> </li> <li> <p>The W3C HTML and CSS standards have listed only 16 valid color names: aqua, black, blue, fuchsia, gray, green, lime, maroon, navy, olive, purple, red, silver, teal, white, and yellow. Major browsers can accept more color names, but they are not web safe in typically.\u00a0\u21a9</p> </li> </ol>"},{"location":"credit.html","title":"Saved credentials access","text":""},{"location":"credit.html#saved-credentials-in-the-flash","title":"Saved credentials in the flash","text":"<p>AutoConnect stores the credentials of the established WiFi connection in the flash memory of the ESP8266/ESP32 module and equips the class to access the credentials from the sketch. You can read, write, or erase the credentials using this class individually. It's the AutoConnectCredential, which provides the way of access to the credentials stored in flash.1</p>"},{"location":"credit.html#credentials-storage-location","title":"Credentials storage location","text":"<p>The location where AutoConnect saves credentials depends on the module type and the AutoConnect library version, also arduino-esp32 core version. In either case, the location is flash memory, but EEPROM and Preferences (in the nvs2) are used depending on the library versions.</p> AutoConnect Arduino corefor ESP8266 Arduino core for ESP32 1.0.2 earlier 1.0.3 later v0.9.12 earlier EEPROM EEPROM (partition) Not supported v1.0.0 later Preferences (nvs)<p>(Can be used EEPROM with turning off AUTOCONNECT_USE_PREFERENCES macro)</p> Preferences (nvs) <p>However, sketches do not need to know where to store credentials using the commonly accessible AutoConnectCredential API.</p> <p>If you are using an Arduino core for ESP32 1.0.2 earlier and need to use credentials in EEPROM for backward compatibility, turns off the <code>AUTOCONNECT_USE_PREFERENCES</code>3 macro definition in <code>AutoConnectCredentials.h</code> file. AutoConnect behaves assuming that credentials are stored in EEPROM if <code>AUTOCONNECT_USE_PREFERENCES</code> is not defined.</p>"},{"location":"credit.html#autoconnectcredential","title":"AutoConnectCredential","text":""},{"location":"credit.html#include-header","title":"Include header","text":"<pre><code>#include &lt;AutoConnectCredential.h&gt;\n</code></pre>"},{"location":"credit.html#constructors","title":"Constructors","text":"<pre><code>AutoConnectCredential();\n</code></pre> <p>AutoConnectCredential default constructor. The default offset value is 0. In ESP8266 or ESP32 with arduino core 1.0.2 earlier, if the offset value is 0, the credential area starts from the top of the EEPROM. If you use this area in a user sketch, AutoConnect may overwrite that data.</p> <pre><code>AutoConnectCredential(uint16_t offset);\n</code></pre> Parameter offsetSpecies offset from the top of the EEPROM for the credential area together. The offset value is from 0 to the flash sector size. This parameter is ignored for AutoConnect v1.0.0 or later with arduino-esp32 core 1.0.3 or later."},{"location":"credit.html#public-member-functions","title":"Public member functions","text":""},{"location":"credit.html#backup","title":"backup","text":"<pre><code>bool backup(Stream&amp; out)\n</code></pre> <p>Outputs all credentials currently stored by AutoConnect to the stream. Parameter outOutput destination stream. Return value trueAll credentials were successfully output. falseFailed to output.</p>"},{"location":"credit.html#del","title":"del","text":"<pre><code>bool del(const char* ssid)\n</code></pre> <p>Delete a credential the specified SSID. Parameter ssidSSID to be deleted. Return value trueSuccessfully deleted. falseFailed to delete.</p> <p>Clear saved credentials</p> <p>There is no particular API for batch clearing of all credential data stored by AutoConnect. It is necessary to prepare a sketch function that combines several AutoConnectCredential APIs  to erase all saved credentials. The following function is an implementation example, and you can use it to achieve batch clearing.</p> <pre><code>void deleteAllCredentials(void) {\n  AutoConnectCredential credential;\n  station_config_t config;\nuint8_t ent = credential.entries();\n\nwhile (ent--) {\n    credential.load(0, &amp;config);\n    credential.del((const char*)&amp;config.ssid[0]);\n  }\n}\n</code></pre>"},{"location":"credit.html#entries","title":"entries","text":"<pre><code>uint8_t entries(void)\n</code></pre> <p>Returns number of entries as contained credentials. Return value Number of entries as contained credentials.</p>"},{"location":"credit.html#load","title":"load","text":"<pre><code>int8_t load(const char* ssid, station_config_t* config)\n</code></pre> <p>Load a credential entry and store to config. Parameters ssidSSID to be loaded. configstation_config_t Return value Save the specified SSID's credential entry to <code>station_config_t</code> pointed to by the parameter as config. -1 is returned if the SSID is not saved.</p>"},{"location":"credit.html#load_1","title":"load","text":"<pre><code>bool load(int8_t entry, station_config_t* config)\n</code></pre> <p>Load a credential entry and store to config. Parameters entrySpecifies the index number based 0 to be loaded. configstation_config_t Return value Save the specified credential entry to <code>station_config_t</code> pointed to by the parameter as config. -1 is returned if specified number is not saved.</p>"},{"location":"credit.html#restore","title":"restore","text":"<pre><code>bool restore(Stream&amp; in)\n</code></pre> <p>The credentials data saved by the backup function is input from Storm and saved as AutoConnect credentials. Parameter inAn input stream of a file containing credential data saved with the backup function. Return value trueCredentials successfully restored. falseFailed to restore.</p>"},{"location":"credit.html#save","title":"save","text":"<pre><code>bool save(const station_config_t* config)\n</code></pre> <p>Save a credential entry. Parameter configstation_config_t to be saved. Return value trueSuccessfully saved. falseFailed to save.</p>"},{"location":"credit.html#the-data-structures","title":"The data structures","text":""},{"location":"credit.html#station_config_t","title":"station_config_t","text":"<p>The saved credential structure is defined as <code>station_config_t</code> in the AcutoConnectCredential header file.</p> <pre><code>typedef struct {\nuint8_t ssid[32];\nuint8_t password[64];\nuint8_t bssid[6];\nuint8_t dhcp;   /**&lt; 0:DHCP, 1:Static IP */\nunion _config {\nuint32_t  addr[5];\nstruct _sta {\nuint32_t ip;\nuint32_t gateway;\nuint32_t netmask;\nuint32_t dns1;\nuint32_t dns2;\n    } sta;\n  } config;\n} station_config_t;\n</code></pre> <p>The byte size of <code>station_config_t</code> in program memory and stored credentials is different</p> <p>There is a gap byte for boundary alignment between the <code>dhcp</code> member and the static IP members of the above <code>station_config_t</code>. Its gap byte will be removed with saved credentials on the flash.</p>"},{"location":"credit.html#the-credential-entry","title":"The credential entry","text":"<p>A data structure of the credential saving area in EEPROM as the below. 4</p> byte offset Length Value 0 8 AC_CREDT 8 1 Number of contained entries (uint8_t) 9 2 Container size, excluding size of AC_CREDT and size of the number of entries(width for uint16_t type). 11 variable SSID terminated by 0x00. Max length is 32 bytes. variable variable Password plain text terminated by 0x00. Max length is 64 bytes. variable 6 BSSID variable 1 Flag for DHCP or Static IP (0:DHCP, 1:Static IP) The following IP address entries are stored only for static IPs. variable(1) 4 Station IP address (uint32_t) variable(5) 4 Gateway address (uint32_t) variable(9) 4 Netmask (uint32_t) variable(13) 4 Primary DNS address (uint32_t) variable(17) 4 Secondary DNS address (uint32_t) variable variable Contained the next entries. (Continuation SSID+Password+BSSID+DHCP flag+Static IPs(if exists)) variable 1 0x00. End of container. <p>AutoConnectCredential has changed</p> <p>It was lost AutoConnectCredential backward compatibility. Credentials saved by AutoConnect v1.0.3 (or earlier) will not work properly with AutoConnect v1.1.0. You need to erase the flash of the ESP module using the esptool before the sketch uploading. <pre><code>esptool -c esp8266 (or esp32) -p [COM_PORT] erase_flash\n</code></pre></p> <ol> <li> <p>An example using AutoConnectCredential is provided as an example of a library sketch to delete saved credentials.\u00a0\u21a9</p> </li> <li> <p>The namespace for Preferences used by AutoConnect is AC_CREDT.\u00a0\u21a9</p> </li> <li> <p>Available only for AutoConnect v1.0.0 and later.\u00a0\u21a9</p> </li> <li> <p>There may be 0xff as an invalid data in the credential saving area. The 0xff area would be reused.\u00a0\u21a9</p> </li> </ol>"},{"location":"datatips.html","title":"Tips for data conversion","text":""},{"location":"datatips.html#convert-autoconnectelements-value-to-actual-data-type","title":"Convert AutoConnectElements value to actual data type","text":"<p>The values in the AutoConnectElements field of the custom Web page are all typed as String. A sketch needs to be converted to an actual data type if the data type required for sketch processing is not a String type.</p> <p>The AutoConnect library does not provide the data conversion utility, and its function depends on Arduino language functions or functions of the type class. However, commonly used data conversion methods are generally similar.</p> <p>Here, represent examples the typical method for the data type conversion for the AutoConnectElements value of custom Web pages.</p>"},{"location":"datatips.html#integer","title":"Integer","text":"<p>Use int() or toInt() of String.</p> <p><pre><code>AutoConnectInput&amp; input = aux.getElement&lt;AutoConnectInput&gt;(\"INPUT\");\nint value = input.value.toInt();\n</code></pre> You can shorten it and write as like: <pre><code>int value = aux[\"INPUT\"].value.toInt();\n</code></pre></p>"},{"location":"datatips.html#float","title":"Float","text":"<p>Use float() or toFloat() of String.</p> <p><pre><code>AutoConnectInput&amp; input = aux.getElement&lt;AutoConnectInput&gt;(\"INPUT\");\nfloat value = input.value.toFloat();\n</code></pre> You can shorten it and write as like: <pre><code>float value = aux[\"INPUT\"].value.toFloat();\n</code></pre></p>"},{"location":"datatips.html#date-time","title":"Date &amp; Time","text":"<p>The easiest way is to use the Arduino Time Library. Sketches must accommodate differences in date and time formats depending on the time zone. You can absorb the difference in DateTime format by using <code>sscanf</code> function.1</p> <pre><code>#include &lt;TimeLib.h&gt;\n\ntime_t tm;\nint Year, Month, Day, Hour, Minute, Second;\n\nAutoConnectInput&amp; input = aux.[\"INPUT\"].as&lt;AutoConnectInput&gt;();\nsscanf(input.value.c_str(), \"%d-%d-%d %d:%d:%d\", &amp;Year, &amp;Month, &amp;Day, &amp;Hour, &amp;Minute, &amp;Second);\ntm.Year = CalendarYrToTm(Year);\ntm.Month = Month;\ntm.Day = Day;\ntm.Hour = Hour;\ntm.Minute = Minute;\ntm.Second = Second;\n</code></pre>"},{"location":"datatips.html#ip-address","title":"IP address","text":"<p>To convert a String to an IP address, use IPAddress::fromString. To stringize an instance of an IP address, use IPAddress::toString.</p> <pre><code>IPAddress ip;\nAutoConnectInput&amp; input aux[\"INPUT\"].as&lt;AutoConnectInput&gt;();\nip.fromString(input.value);\ninput.value = ip.toString();\n</code></pre>"},{"location":"datatips.html#validation-for-the-value","title":"Validation for the value","text":"<p>To convert input data correctly from the string, it must match its format. The validation implementation with sketches depends on various perspectives. Usually, the tiny devices have no enough power for the lexical analysis completely. But you can reduce the burden for data verification using the pattern of AutoConnectInput.</p> <p>By giving a pattern to AutoConnectInput, you can find errors in data format while typing in custom Web pages. Specifying the input data rule as a regular expression will validate the type match during input. If there is an error in the format during input, the background color of the field will change to pink. Refer to section Handling the custom Web pages.</p> <p>However, input data will be transmitted even if the value does not match the pattern. Sketches require the validation of the received data. You can use the AutoConnectInput::isValid function to validate it. The isValid function validates whether the value member variable matches a pattern and returns true or false.</p> <pre><code>#include &lt;ESP8266WiFi.h&gt;\n#include &lt;ESP8266WebServer.h&gt;\n#include &lt;AutoConnect.h&gt;\n\nstatic const char input_page[] PROGMEM = R\"raw(\n[\n  {\n    \"title\": \"IP Address\",\n    \"uri\": \"/\",\n    \"menu\": true,\n    \"element\": [\n      {\n        \"name\": \"ipaddress\",\n        \"type\": \"ACInput\",\n        \"label\": \"IP Address\",\n        \"pattern\": \"^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$\"\n      },\n      {\n        \"name\": \"send\",\n        \"type\": \"ACSubmit\",\n        \"value\": \"SEND\",\n        \"uri\": \"/check\"\n      }\n    ]\n  },\n  {\n    \"title\": \"IP Address\",\n    \"uri\": \"/check\",\n    \"menu\": false,\n    \"element\": [\n      {\n        \"name\": \"result\",\n        \"type\": \"ACText\"\n      }\n    ]\n  }\n]\n)raw\";\n\nAutoConnect portal;\n\nString checkIPAddress(AutoConnectAux&amp; aux, PageArgument&amp; args) {\n  AutoConnectAux&amp;   input_page = *portal.aux(\"/\");\n  AutoConnectInput&amp; ipaddress = input_page[\"ipaddress\"].as&lt;AutoConnectInput&gt;();\n  AutoConnectText&amp;  result = aux[\"result\"].as&lt;AutoConnectText&gt;();\n\nif (ipaddress.isValid()) {\n    result.value = \"IP Address \" + ipaddress.value + \" is OK.\";\n    result.style = \"\";\n  }\nelse {\n    result.value = \"IP Address \" + ipaddress.value + \" error.\";\n    result.style = \"color:red;\";\n  }\nreturn String(\"\");\n}\n\nvoid setup() {\n  portal.load(input_page);\n  portal.on(\"/check\", checkIPAddress);\n  portal.begin();\n}\n\nvoid loop() {\n  portal.handleClient();\n}\n</code></pre> <p>Regular Expressions for JavaScript</p> <p>Regular expressions specified in the AutoConnectInput pattern conforms to the JavaScript specification.</p> <p>Here, represent examples the typical regular expression for the input validation.</p>"},{"location":"datatips.html#url","title":"URL","text":"<pre><code>^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$\n</code></pre>"},{"location":"datatips.html#dns-hostname","title":"DNS hostname","text":"<pre><code>^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$\n</code></pre>"},{"location":"datatips.html#email-address-2","title":"email address 2","text":"<pre><code>^[a-zA-Z0-9.!#$%&amp;'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*$\n</code></pre>"},{"location":"datatips.html#ip-address_1","title":"IP Address","text":"<pre><code>^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$\n</code></pre>"},{"location":"datatips.html#date-as-mmddyyyy-3","title":"Date as MM/DD/YYYY 3","text":"<pre><code>^(0[1-9]|1[012])[- \\/.](0[1-9]|[12][0-9]|3[01])[- \\/.](19|20)\\d\\d$\n</code></pre> <p>Contain with backquote</p> <p>If that regular expression contains a backquote it must be escaped by backquote duplication.</p> <ol> <li> <p>The ssanf library function cannot be used with the old Arduino core.\u00a0\u21a9</p> </li> <li> <p>This regular expression does not fully support the format of the e-mail address requested in RFC5322.\u00a0\u21a9</p> </li> <li> <p>This regular expression does not consider semantic constraints. It is not possible to detect errors that do not exist as actual dates.\u00a0\u21a9</p> </li> </ol>"},{"location":"esp32cam.html","title":"Works with ESP32-CAM","text":""},{"location":"esp32cam.html#what-this-example-presents","title":"What this example presents","text":"<p>ESP-IDF is offering ESP32 Camera Driver as an interface to small image sensors that can work with ESP32. This driver supports a variety of popular image sensors, such as the OV2640, which has low power consumption and mega-pixel sensing capability. By reading through this chapter you will know how to make the sketch featuring a UI that looks like the followings. Of course, it has the convenience of AutoConnect as well. This example shows how to sketch the Web Camera Application that involves using AutoConnect together with the ESP32 Camera Driver.</p> <p> </p>"},{"location":"esp32cam.html#why-we-can-not-use-app_httpdcpp-together-with-autoconnect","title":"Why we can not use app_httpd.cpp together with AutoConnect","text":"<p>The ESP32 library of the ESP32 Arduino core features a <code>CameraWebServer.ino</code> that includes an interface to drive the Camera Driver. The core process of the server-side of that sketch application is <code>app_httpd.cpp</code>, which consists of initializing and configuring the image sensor, configuring and capturing image frames, and sending the image frames through an internally started HTTP server.</p> <p>While Web UI provided by <code>CameraWebServer.ino</code> is sophisticated, the role of <code>app_httpd.cpp</code> is focused on responding to the Fetch required by the Web UI (which is actually an HTML page specific to each sensor model that is extracted from the gzipped <code>camera_index.h</code>). It is a set of primitive functions that are integrated with the Web UI. Also, <code>app_httpd.cpp</code> has hardcoded the TCP port of the internally invoking HTTP server as fixed at 80, which conflicts with the HTTP port used by a typical captive portal. Therefore, It is impossible to apply <code>app_httpd.cpp</code> which has fixed 80 TCP port depending on the WebUI of <code>CameraWebServer.ino</code> to sketches using AutoConnect as it is.</p> <p>CameraWebServer.ino extended version available on GitHub</p> <p>An extended version of app_httpd.cpp is available on the GitHub repository to make it a bit more flexible for different usage scenarios. It also can handling the captive portal itself.</p>"},{"location":"esp32cam.html#strategy","title":"Strategy","text":"<p>As mentioned earlier, <code>app_httpd.cpp</code> is integrated with <code>CameraWebServer.ino</code>'s Web UI. However, its functionality can be separated into two parts: an interface for driving the image sensor correctly and sending the captured images on the HTTP stream as requested by the client. It also has the ability to configure the sensor settings over the network remotely, but this can be omitted at the expense of interactivity. (We can implement that feature after the initial purpose is achieved)</p> <p>So, I have prepared two separate classes with these functions. ESP32WebCam and ESP32Cam are independent classes inspired by app-httpd.cpp, and they can interface with the ESP32 Camera Driver individually, or send out motion JPEGs via an HTTP server task running inside the class.</p> <p>These two classes are completely independent of the AutoConnect library and can be incorporated into your various other sketches on their own. the source code for the ESP32WebCam and ESP32Cam classes can be found in the AutoConnect library examples and are distributed together. The API specifications for these two classes are described later in this chapter.</p>"},{"location":"esp32cam.html#implementing-a-streaming-server-with-esp32-cam-using-autoconnect","title":"Implementing a Streaming Server with ESP32-CAM using AutoConnect","text":"<p>A minimal sketch that involves the ESP32WebCam and ESP32Cam classes and incorporates them together with AutoConnect is shown below. This sketch will work with Ai-Thinker ESP32-CAM, which is one of the most popular ESP32 modules with OmniVision OV2640 image sensor.</p> <p>In order to experience this sketch, copy the five files <code>ESP32WebCam.h</code>, <code>ESP32WebCam.cpp</code>, <code>ESP32Cam.h</code>, <code>ESP32Cam.cpp</code>, and <code>ESP32Cam_pins.h</code> from the WebCamServer folder located AutoConnect library examples to the same folder as the sketchbook folder where you placed this sketch. Connect the ESP32-CAM module to your PC and launch the Arduino IDE. Then select the correct board you using from the Tool menu of Arduino IDE and compile it. (Don't forget to open the serial monitor)</p> <pre><code>#include &lt;Arduino.h&gt;\n#include &lt;WiFi.h&gt;\n#include &lt;WebServer.h&gt;\n#include &lt;AutoConnect.h&gt;\n#include \"ESP32WebCam.h\"\n\nconst char  CAMERA_VIEWER[] = R\"*(\n{\n  \"title\": \"Camera\",\n  \"uri\": \"/\",\n  \"menu\": false,\n  \"element\": [\n    {\n      \"name\": \"viewport\",\n      \"type\": \"ACText\",\n      \"format\": \"&lt;img src='http://%s'&gt;\",\n      \"posterior\": \"none\"\n    },\n    {\n      \"name\": \"discon\",\n      \"type\": \"ACElement\",\n      \"value\": \"&lt;script&gt;window.addEventListener('pagehide',function(){window.stop();});&lt;/script&gt;\"\n    }\n  ]\n}\n)*\";\n\n// Declare ESP32-CAM handling interface. It contains ESP-IDF Web Server.\nESP32WebCam webcam(ESP32Cam::CAMERA_MODEL_AI_THINKER);\n\n// AutoConnect portal. It contains the WebServer from ESP32 Arduino Core.\nAutoConnect portal;\nAutoConnectConfig config;\n\n// AutoConnectAux page handler, it starts streaming by adding the ESP32WebCam\n// streaming endpoint to the src attribute of the img tag on the AutoConnectAux page.\nString viewer(AutoConnectAux&amp; aux, PageArgument &amp;args) {\n  AutoConnectAux&amp; viewer = *portal.aux(\"/\");\n// Set the Streaming server host, port, and endpoint\n  viewer[\"viewport\"].value = WiFi.localIP().toString() + \":\" + String(webcam.getServerPort())\n+ String(webcam.getStreamPath());\nreturn String();\n}\n\nvoid setup() {\n  delay(1000);\n  Serial.begin(115200);\n  Serial.println();\n\n// Start Image sensor\nif (webcam.sensorInit() != ESP_OK) {\n    Serial.println(\"Camera initialize failed\");\n  }\n\n// Allow automatic re-connection as long as the WiFi connection is established.\n  config.autoReconnect = true;\n  config.reconnectInterval = 1;\n  portal.config(config);\n\n// Start the portal, it will launch the WebServer for the portal from inside of AutoConnect.\nif (portal.begin()) {\n    portal.load(CAMERA_VIEWER);\n    portal.on(\"/\", viewer);\n// Start ESP32 Camera Web Server\nif (webcam.startCameraServer() == ESP_OK) {\n      Serial.printf(\"ESP32WebCam server %s port %u ready\\n\", WiFi.localIP().toString().c_str(),\n        webcam.getServerPort());\n    }\nelse {\n      Serial.println(\"ESP32WebCam server start failed\");\n    }\n  }\n}\n\nvoid loop() {\n  portal.handleClient();\n}\n</code></pre> <p>If your ESP32-CAM module still has no connection with any access point, a captive portal will open. Use your cellphone to connect the ESP32-CAM to the access point. When ESP32-CAM successfully connects to the access point, you will see the IP address on the serial monitor. You visit the IP address from your browser, you can see the image captured by the ESP32-CAM.</p> <p></p> <p>Streaming stops caused by ERR_CONNECTION_RESET</p> <p>Sometimes the browser will throw the above error and the streaming will stop. In the simple sketch above, which does not include the transmission error recovery process, the TCP packet transmission is incomplete due to a weak WiFi signal or other reasons, and the browser will stop loading the image. Send errors can be recovered by incorporating an event handler into the img tag, and an example of its implementation is shown later in this chapter.</p>"},{"location":"esp32cam.html#program-structure","title":"Program structure","text":"<p>The sketch of AutoConnect using ESP32WebCam and ESP32Cam classes is divided into several components, which will take a similar form in any sketch application. Their logical components are as follows:</p> <ol> <li> <p>Include ESP32WebCam.h header file. <pre><code>#include \"ESP32WebCam.h\"\n</code></pre></p> </li> <li> <p>AutoConnectAux defines a custom web page in JSON description. It includes an <code>img</code> tag that displays the captured image. The <code>src</code> attribute of the <code>img</code> tag is not hard-coded and can be dynamically set in a custom web page handler to make the sketch more applicable to various situations. <pre><code>{\n\"name\": \"viewport\",\n\"type\": \"ACText\",\n\"format\": \"&lt;img src='http://%s'&gt;\",\n\"posterior\": \"none\"\n}\n</code></pre></p> </li> <li> <p>Insert AutoConnectElement in the JSON description of your custom web page with JavaScript enclosed in <code>&lt;script&gt;~&lt;/script&gt;</code> in HTML to stop streaming on page transition. <pre><code>window.addEventListener('pagehide', function () {\n  window.stop();\n});\n</code></pre></p> <p>Why window.stop() is needed</p> <p>That's because image streaming is achieved by continuous loading of Motion JPEG using HTTP multipart/x-mixed-replace keep-alive stream. With this type of MIME content, the server will continue to push the content unless the client explicitly notifies the server of the end of the session. The method of notifying the end of the session varies depending on the client browser, and by issuing <code>window.stop()</code>, the difference in the behavior of each browser is absorbed.</p> </li> <li> <p>Declare ESP32WebCam instance. It accompanies the parameters with the appropriate model specifiers. <pre><code>ESP32WebCam webcam(ESP32Cam::CAMERA_MODEL_AI_THINKER);\n</code></pre>     For details on identifiers that can be specified as image sensor models, please refer to the APIs described below.</p> </li> <li> <p>Declare AutoConnect instance. If your sketch requires a native web page that is not an AutoConnectAux, you can declare a WebServer instance at the same place to make it easier to call from functions in your sketch. <pre><code>AutoConnect portal;\n</code></pre></p> </li> <li> <p>Declare AutoConnectConfig to control WiFi connection behavior if necessary. <pre><code>AutoConnectConfig config;\n</code></pre></p> </li> <li> <p>Prepare an AutoConnectAux custom page handler for the declared above AutoConnectAux JSON. Typically, this handler is responsible for handling the ESP32Cam class via the endpoint interface provided by the ESP32Cam class. In the above sketch, we have only given the endpoint (i.e. <code>http://{WiFi.localIP}:3000/_stream</code>) for streaming by the ESP32WebCam class as the <code>src</code> attribute of the <code>img</code> tag identified <code>id=viewport</code>, since we are focusing on the minimum necessary processing. ESP32WebCam class will deliver the captured image with just this operation. <pre><code>AutoConnectAux&amp; viewer = *portal.aux(\"/\");\nviewer[\"viewport\"].value = WiFi.localIP().toString() + \":\" + String(webcam.getServerPort())\n+ String(webcam.getStreamPath());\n</code></pre>     For more information about ESP32Cam capability and ESP32WebCam endpoints, please refer to the Endpoint interfaces described below.</p> <p>Using AutoConnectText with format string</p> <p>In the sketch above, the format attribute of AutoConnectText is used to set the <code>src</code> attribute of the <code>img</code> tag. The AutoConnectText format attribute produces the same output as a C-style <code>printf(format, value)</code>, depending on the string that can be derived from the value. <pre><code>printf(\"&lt;img src='http://%s'&gt;\", \"localhost:3000/_stream\");\n</code></pre></p> </li> <li> <p>Start the sketch and initialize the camera using ESP32WebCam::sensorInit. <code>ESP_OK</code> will returned on success to initialize the image sensor. <pre><code>ESP32WebCam webcam(ESP32Cam::CAMERA_MODEL_AI_THINKER);\n\nif (webcam.sensorInit() != ESP_OK) {\n  Serial.println(\"Camera initialize failed\");\n}\n</code></pre></p> </li> <li> <p>Configure WiFi state control to maintain connection. Usually, AutoConnectConfig::autoReconnect will keep WiFi connection stateful. <pre><code>config.autoReconnect = true;\nconfig.reconnectInterval = 1;\nportal.config(config);\n</code></pre></p> </li> <li> <p>Start the portal, and load the view page. <pre><code>portal.begin();\nportal.load(CAMERA_VIEWER);\n</code></pre></p> </li> <li> <p>Register the view page handler and start the streaming server using ESP32WebCam::startCameraServer. <code>ESP_OK</code> will returned on start the streaming server successfully. <pre><code>portal.on(\"/\", viewer);\nif (webcam.startCameraServer() == ESP_OK) {\n  Serial.printf(\"ESP32WebCam server ready: %s\\n\", WiFi.localIP().toString().c_str());\n}\nelse {\n  Serial.println(\"ESP32WebCam server start failed\");\n}\n</code></pre></p> </li> <li> <p>Loop for portal.handleClient().</p> </li> </ol> <p>The <code>app_httpd.cpp</code>, which is the core of <code>CameraWebServer.ino</code>'s functionality, has a mixture of an interface with the ESP32 Camera Driver and remote control over the network via an HTTP server. While it is highly functional, but it will cause a decline in versatility. ESP32WebCam and ESP32Cam separate the mixed functionality of <code>app_httpd.cpp</code> into two classes, each with a single role. This makes them versatile and simple to use. And they can coexist with AutoConnect.</p> <p>If you only need to stream from the image sensor, you can simplify the sketch structure as in the example above. The simplicity of the sketch is mainly due to the usefulness of the ESP32WebCam and ESP32Cam classes. In driving the ESP32 Camera Driver on the ESP32-CAM module, the sketch interfaces with the ESP32WebCam class and processes the ESP32Cam class through the ESP32WebCam endpoint interface.</p> <p></p>"},{"location":"esp32cam.html#esp32webcam-class-and-esp32cam-class","title":"ESP32WebCam Class and ESP32Cam Class","text":"<p>The ESP32WebCam class has an endpoint interface to allow the sketch to manipulate the image sensor over the network. The sketch can use HTTP GET method to capture images, stream the captured images, and save them to SD card. It also starts its own HTTP server task internally, and this HTTP server runs as a separate task from the WebServer hosted by AutoConnect.</p> <p>The ESP32Cam class is a wrapper that governs the native interface with the ESP32 Camera Driver which is a component of ESP-IDF. It can initialize the sensor, set the sensor characteristics, save and load the settings, and save the captured images to the SD card.</p> <p>In the case of accessing image sensors located across a network, the sketch will usually have a UI to remotely control the ESP32-CAM. If the UI is intended to be a web interface, the sketch will use a request handler that is compatible with the ESP32 WebServer hosted by AutoConnect to serve the manipulation web page. That page can be an AutoConnectAux-based custom web page, or it can be the RequestHanlder callback that can respond to the ESP32 WebServer class. In any case, those UI pages can remotely access the image sensor of the ESP32-CAM module through the HTTP endpoint interface deployed at a specific URL of the HTTP server launched by the ESP32WebCam class, and do the required processing.</p>"},{"location":"esp32cam.html#esp32webcam-features","title":"ESP32WebCam features:","text":"<ul> <li>Run the HTTP server as a background task.</li> <li>Stream Motion JPEG via HTTP multipart/x-mixed-replace MIME.</li> <li>Serves a captured image via HTTP.</li> <li>Instruct the ESP32Cam to save the captured image to the SD card via HTTP.</li> </ul> <p>Of these processing requests, the ESP32Cam class is responsible for the ones that actually need to interface with the camera driver. (However, reading from the frame buffer is excluded. ESP32WebCam reads image data directly from the frame buffer of the image sensor without ESP32Cam.) The ESP32Cam class manipulates sensor characteristics, including setting image frame properties, image format settings, and exposure, gain, white balance, and band filter settings. It also saves the captured image to an SD card wired to the ESP32-CAM.</p>"},{"location":"esp32cam.html#esp32cam-features","title":"ESP32Cam features:","text":"<ul> <li>Directs and acquires sensor settings.</li> <li>Save and load the sensor settings to the flash memory on the ESP32 module.</li> <li>Save the captured image to the SD card which is wired to ESP32 module.</li> <li>Save captured images to SD card periodically using an ESP32 built-in hardware timer.</li> </ul>"},{"location":"esp32cam.html#esp32webcam-class-apis","title":"ESP32WebCam Class APIs","text":""},{"location":"esp32cam.html#constructor","title":"Constructor","text":"<pre><code>ESP32WebCam(const uint16_t port = ESP32CAM_DEFAULT_HTTPPORT)\n</code></pre> <pre><code>ESP32WebCam(const ESP32Cam::CameraId model, const uint16_t port = ESP32CAM_DEFAULT_HTTPPORT)\n</code></pre> <p>Instantiate ESP32WebCam. The constructor also instantiates ESP32Cam, so there is no need to explicitly declare the ESP32Cam class in the sketch. At the time of declaring the constructor, the camera is not initialized and the HTTP server is not started. Each of them requires a separate dedicated function to be called. Parameters portPort number of the HTTP server that ESP32WebCam starts. Default port number defined by <code>ESP32CAM_DEFAULT_HTTPPORT</code> macro directive in <code>ESP32WebCam.h</code> modelSpecifies the model of the onboard image sensor. The image sensor models that can be specified are as follows: <ul> <li>ESP32Cam::CAMERA_MODEL_WROVER_KIT</li> <li>ESP32Cam::CAMERA_MODEL_ESP_EYE</li> <li>ESP32Cam::CAMERA_MODEL_M5STACK_NO_PSRAM</li> <li>ESP32Cam::CAMERA_MODEL_M5STACK_PSRAM</li> <li>ESP32Cam::CAMERA_MODEL_M5STACK_V2_PSRAM</li> <li>ESP32Cam::CAMERA_MODEL_M5STACK_WIDE</li> <li>ESP32Cam::CAMERA_MODEL_M5STACK_ESP32CAM</li> <li>ESP32Cam::CAMERA_MODEL_M5STACK_UNITCAM</li> <li>ESP32Cam::CAMERA_MODEL_AI_THINKER</li> <li>ESP32Cam::CAMERA_MODEL_TTGO_T_JOURNAL      </li> </ul>"},{"location":"esp32cam.html#getcapturepath","title":"getCapturePath","text":"<pre><code>const char* getCapturePath(void)\n</code></pre> <p>Get a path containing the first '<code>/</code>' of the currently valid endpoint URL to capture. Return valueA path of capturing URL. Default path defined by <code>ESP32CAM_DEFAULT_PATH_CAPTURE</code> macro directive in <code>ESP32WebCam.h</code>. </p>"},{"location":"esp32cam.html#getpromptpath","title":"getPromptPath","text":"<pre><code>const char* getPromptPath(void)\n</code></pre> <p>Get a path containing the first '<code>/</code>' of the currently valid endpoint URL to prompt. Return valueA path of prompting URL. Default path defined by <code>ESP32CAM_DEFAULT_PATH_PROMPT</code> macro directive in <code>ESP32WebCam.h</code>. </p>"},{"location":"esp32cam.html#getserverhandle","title":"getServerHandle","text":"<pre><code>httpd_handle_t getServerHandle(void)\n</code></pre> <p>Returns the handle of the HTTP server started by ESP32WebCam. Return valueReturns the httpd_handle_t value of an HTTP server started by ESP32WebCam. If the HTTP server task is not running, <code>nullptr</code> is returned. </p>"},{"location":"esp32cam.html#getserverport","title":"getServerPort","text":"<pre><code>uint16_t getServerPort(void)\n</code></pre> <p>Returns the port number that the HTTP server on listens to. Return valueReturns a port number of an HTTP server started by ESP32WebCam. Default port number defined by <code>ESP32CAM_DEFAULT_HTTPPORT</code> macro directive in <code>ESP32WebCam.h</code> </p>"},{"location":"esp32cam.html#getstreampath","title":"getStreamPath","text":"<pre><code>const char* getStreamPath(void)\n</code></pre> <p>Get a path containing the first '<code>/</code>' of the currently valid endpoint URL to streaming. Return valueA path of streaming URL. Default path defined by <code>ESP32CAM_DEFAULT_PATH_STREAM</code> macro directive in <code>ESP32WebCam.h</code>. </p>"},{"location":"esp32cam.html#isserverstarted","title":"isServerStarted","text":"<pre><code>bool isServerStarted(void)\n</code></pre> <p>Returns a boolean value indicating whether the HTTP server task is running or not. Return value trueThe HTTP Server tasks is running. falseThe HTTP server task has not been started. </p>"},{"location":"esp32cam.html#sensor","title":"sensor","text":"<pre><code>ESP32Cam&amp; sensor(void)\n</code></pre> <p>Returns a reference to ESP32Cam, which is instantiated internally by ESP32WebCam constructor. Return valueA reference to ESP32Cam instance. The image sensor is not initialized just by calling the ESP32WebCam constructor. To initialize the sensor, you need to call the <code>sensorInit()</code> function.<p> <pre><code>ESP32WebCam webcam();\nwebcam.sensorInit();\n</code></pre> </p>"},{"location":"esp32cam.html#sensorinit","title":"sensorInit","text":"<pre><code>esp_err_t sensorInit(void)\n</code></pre> <pre><code>esp_err_t sensorInit(const ESP32Cam::CameraId model)\n</code></pre> <p>Initialize the image sensor via the ESP32Cam class. The sketch needs to initialize the sensor with the sensorInit function prior to all processing of the image sensor. Parameters modelSpecifies the model of the onboard image sensor. The image sensor models that can be specified are same as the constructor parameter. Return value ESP_OKAn image sensor successfully initialized. ESP_ERR_CAMERA_NOT_SUPPORTEDSpecified model is not supported. ESP_ERR_CAMERA_NOT_DETECTEDAn image sensor not detected. ESP_ERR_CAMERA_FAILED_TO_SET_FRAME_SIZEFrame identifier is invalid. ESP_ERR_CAMERA_FAILED_TO_SET_OUT_FORMATOutput image format is invalid. ESP_FAILOther error occurred. </p>"},{"location":"esp32cam.html#setcapturepath","title":"setCapturePath","text":"<pre><code>void setCapturePath(const char* path)\n</code></pre> <p>Reconfigure the already defined path of the endpoint for capture. Parameters pathSpecifies the path of the capture endpoint to be set newly, as a string starting with '<code>/</code>'. If this path is not specified, the default path defined by <code>ESP32CAM_DEFAULT_PATH_CAPTURE</code> macro directive will be assumed. </p>"},{"location":"esp32cam.html#setpromptpath","title":"setPromptPath","text":"<pre><code>void setPromptPath(const char* path)\n</code></pre> <p>Reconfigure the already defined path of the endpoint for prompt. Parameters pathSpecifies the path of the prompt endpoint to be set newly, as a string starting with '<code>/</code>'. If this path is not specified, the default path defined by <code>ESP32CAM_DEFAULT_PATH_PROMPT</code> macro directive will be assumed. </p>"},{"location":"esp32cam.html#setserverport","title":"setServerPort","text":"<pre><code>void setServerPort(const uint16_t port)\n</code></pre> <p>Reconfigure the already defined port number of an HTTP server. Parameters portSpecifies port number of an HTTP Server. Default port number defined by <code>ESP32CAM_DEFAULT_HTTPPORT</code> macro directive will be assumed. </p>"},{"location":"esp32cam.html#setstreampath","title":"setStreamPath","text":"<pre><code>void setStreamPath(const char* path)\n</code></pre> <p>Reconfigure the already defined path of the endpoint for stream. Parameters pathSpecifies the path of the stream endpoint to be set newly, as a string starting with '<code>/</code>'. If this path is not specified, the default path defined by <code>ESP32CAM_DEFAULT_PATH_STREAM</code> macro directive will be assumed. </p>"},{"location":"esp32cam.html#startcameraserver","title":"startCameraServer","text":"<pre><code>esp_err_t startCameraServer(const char* streamPath)\n</code></pre> <pre><code>esp_err_t startCameraServer(const char* streamPath, const char* capturePath, const char* promptPath)\n</code></pre> <pre><code>esp_err_t startCameraServer(const char* streamPath, const char* capturePath, const char* promptPath, const uint16_t port)\n</code></pre> <pre><code>esp_err_t startCameraServer(const char* streamPath, const uint16_t port)\n</code></pre> <pre><code>esp_err_t startCameraServer(const uint16_t port)\n</code></pre> <pre><code>esp_err_t startCameraServer(void)\n</code></pre> <p>Begins the HTTP server task, and start the endpoint service. By starting the HTTP server task, the endpoint interface provided by ESP32WebCam will be available. Parameters streamPathSpecifies the path of the stream endpoint. Default stream path is defined by <code>ESP32CAM_DEFAULT_PATH_STREAM</code> macro directive in <code>ESP32WebCam.h</code> header file. capturePathSpecifies the path of the capture endpoint. Default capture path is defined by <code>ESP32CAM_DEFAULT_PATH_CAPTURE</code> macro directive in <code>ESP32WebCam.h</code> header file. promptPathSpecifies the path of the prompt endpoint. Default prompt path is defined by <code>ESP32CAM_DEFAULT_PATH_PROMPT</code> macro directive in <code>ESP32WebCam.h</code> header file. portSpecifies port number on which the HTTP server listens. Default port number is 3000 which defined by <code>ESP32CAM_DEFAULT_HTTPPORT</code> macro directive in <code>ESP32WebCam.h</code> header file. Return value ESP_OKAn HTTP server task successfully started. ESP_ERR_HTTPD_HANDLERS_FULLAll slots for registering URI handlers have been consumed. ESP_ERR_HTTPD_ALLOC_MEMFailed to dynamically allocate memory for resource. ESP_ERR_HTTPD_TASKFailed to launch server task/thread. ESP_FAILOther error occurred. </p> <p>HTTP server task stack size</p> <p>ESP32WebCam allocates 8KB of stack when it starts the HTTP server task. This stack size is larger than the size allocated by the default <code>HTTPD_DEFAULT_CONFIG</code> in ESP-IDF. This is to include the stack consumed by the file system of the SD card triggered by the timer shot. This stack size can be changed as needed, and the default value is defined in the <code>ESP32Cam.h</code> header file as <code>ESP32CAM_TIMERTASK_STACKSIZE</code>.</p>"},{"location":"esp32cam.html#stopcameraserver","title":"stopCameraServer","text":"<pre><code>void stopCameraServer(void)\n</code></pre> <p>Stop an HTTP server task and free resources.</p>"},{"location":"esp32cam.html#esp32webcam-endpoint-interfaces","title":"ESP32WebCam Endpoint Interfaces","text":"<p>ESP32WebCam has endpoint interfaces for simple manipulation of image sensors over the network via an internally launched HTTP server, which follows the traditional HTTP request and response, not WebAPI or REST. It supports the HTTP GET1 method and will be available after the HTTP server is started by the ESP32WebCam::startCameraServer function.</p> <p>If you are using Visual Studio Code as your build system for Arduino sketch, you can easily experiment with the ESP32WebCam endpoint interface using the VSCode extension. REST Client is an excellent VSCode extension that allows you to send HTTP requests directly from within the editor. The following screenshot shows the result of sending an HTTP request directly to the capture endpoint of ESP32WebCam using the REST Client on a VSCode with the PlatformIO build system.</p> <p></p> <p>The top left editor pane is the sketch code described above, and the bottom pane is the serial monitor output of the sketch. The pane between the top and bottom panes is the REST Client. Run the sketch, and when the serial monitor shows a message that ESP32Cam has started the HTTP server, use the REST client to send an HTTP GET request as <code>GET http://{HOST}:{PORT}/_capture</code> (In the screenshot above, the request is sent to <code>http://192.168.1.19:3000/_capture</code>) to the capture endpoint.2 You will see the response of the image captured by ESP32-CAM in the right pane.</p>"},{"location":"esp32cam.html#the-default-settings-for-the-endpoint-interface-provided-by-esp32webcam-are-as-follows","title":"The default settings for the endpoint interface provided by ESP32WebCam are as follows:","text":"Endpoint Default path Function Default value defined in <code>ESP32WebCam.h</code> Capture <code>/_capture</code> Responds as a captured image <code>ESP32CAM_DEFAULT_PATH_CAPTURE</code> Prompt <code>/_prompt</code> Save and load the captured image, Save the sensor settings <code>ESP32CAM_DEFAULT_PATH_PROMPT</code> Stream <code>/_stream</code> Stream image <code>ESP32CAM_DEFAULT_PATH_STREAM</code>"},{"location":"esp32cam.html#capture","title":"Capture","text":"<pre><code>GET http://{HOST}:{PORT}{PATH}\n</code></pre> <p>The capture endpoint responds captured image with the image/jpeg mime format. Parameters HOSTHost address of ESP32-CAM. PORTPort number of HTTP server listening on. Default port number is 3000 which defined by <code>ESP32CAM_DEFAULT_HTTPPORT</code> macro directive in <code>ESP32WebCam.h</code> header file. PATHA path for the capture endpoint. Response code 200Content body contains captured image data. </p>"},{"location":"esp32cam.html#prompt","title":"Prompt","text":"<pre><code>GET http://{HOST}:{PORT}{PATH}?{QUERY}\n</code></pre> <p>You can use the prompt endpoint to save the captured image to the SD card at that moment or in a timer cycle, save the sensor settings, and load them into the flash memory built into the ESP32 module. The instructions for the prompt action performed by ESP32WebCam are specified as the query string with \"key=value\" form for the parameters of the GET request.Parameters HOSTHost address of ESP32-CAM. PORTPort number of HTTP server listening on. Default port number is 3000 which defined by <code>ESP32CAM_DEFAULT_HTTPPORT</code> macro directive in <code>ESP32WebCam.h</code> header file. PATHA path for the capture endpoint. QUERYThe QUERY that Prompt can accept are different for each feature. The query formats that can be specified and the corresponding functions are shown below. Response code 202Request accepted. 400Query string has syntax error, or Fatal error occurred. Content body has detailed error code. </p>"},{"location":"esp32cam.html#the-following-features-are-currently-supported-by-the-prompt-endpoint","title":"The following features are currently supported by the prompt endpoint:","text":"Specifying by query string Function Behavior <code>mf=oneshot[&amp;fs={sd|mmc}][&amp;filename=&lt;FILENAME&gt;]</code> One-shot Take a one-shot image and save it to the SD card. <code>mf=timershot[&amp;fs={sd|mmc}][&amp;filename=&lt;FILENAME&gt;][&amp;period=&lt;INTERVAL&gt;]</code> Timer-shot Repeatedly takes a one-shot image at specified an INTERVAL of seconds and saves it to the SD card. <code>mf=distimer</code> Disable timer Suspend timer for Timer-shot <code>mf=entimer</code> Enable timer Resume timer for Timer-shot <code>mf=load</code> Load settings Load the image sensor settings from the NVS <code>mf=save</code> Save settings Save the image sensor settings to the NVS <p>The query formats that can be specified and their corresponding functions are described below.Functions: Specifies with the <code>mf=</code> query. <code>oneshot</code>Capture an image at the requested timing and save them to the SD card. Species either <code>sd</code> or <code>mmc</code> for the <code>fs</code> argument. If the <code>fs</code> argument does not exist, <code>mmc</code> is assumed.Saves the captured image with the file name specified by the <code>filename</code> argument; if the <code>filename</code> argument does not exist, it assumes a file name consisting of a prefix and a timestamp. In that case, the fixed string defined by the <code>ESP32CAM_GLOBAL_IDENTIFIER</code> macro directive in <code>ESP32Cam.h</code> is used as the prefix. <code>timershot</code>Repeatedly takes a one-shot image at specified an <code>INTERVAL</code> of seconds with <code>period</code> argument and saves it to the SD card. Species either <code>sd</code> or <code>mmc</code> for the <code>fs</code> argument. If the <code>fs</code> argument does not exist, <code>mmc</code> is assumed.Saves the captured image to a file whose name consists of the prefix and timestamp suffix specified by the <code>filename</code> argument. If the <code>filename</code> argument does not exist, the prefix will be assumed a fixed string defined by the <code>ESP32CAM_GLOBAL_IDENTIFIER</code> macro directive in <code>ESP32Cam.h</code> header file. <code>distimer</code>Temporarily stops the timer for the <code>timershot</code>. This can be resumed with <code>entimer</code>. <code>entimer</code>Resumes a timer-shot that was temporarily stopped by <code>distimer</code>. <code>load</code>Load the image sensor settings from NVS. <code>save</code>Save the image sensor settings to NVS. </p> <p>Whether it is SD or MMC depends on the hardware</p> <p>The ESP32 Arduino SD library supports two types of SD cards with different interfaces. Which type of SD card is used depends on the ESP32 module and needs to be chosen appropriately. In the case of the Ai-Thinker ESP32-CAM 3, the ESP32 is wired to the SD slot with each HS2 signal. Hence, We can see from the schematic that it is using MMC.</p>"},{"location":"esp32cam.html#stream","title":"Stream","text":"<pre><code>GET http://{HOST}:{PORT}{PATH}\n</code></pre> <p>The stream endpoint responds captured image with the image/jpeg mime format with <code>multipart/x-mixed-replace</code> HTTP header. Parameters HOSTHost address of ESP32-CAM. PORTPort number of HTTP server listening on. Default port number is 3000 which defined by <code>ESP32CAM_DEFAULT_HTTPPORT</code> macro directive in <code>ESP32WebCam.h</code> header file. PATHA path for the stream endpoint. Response code 200Content body contains captured image data with multipart boundary. </p>"},{"location":"esp32cam.html#esp32cam-class-apis","title":"ESP32Cam Class APIs","text":""},{"location":"esp32cam.html#constructor_1","title":"Constructor","text":"<pre><code>ESP32Cam()\n</code></pre> <pre><code>ESP32Cam(const CameraId model)\n</code></pre> <p>Instantiate ESP32Cam. The image sensor is not initialized just by calling the constructor. To initialize the sensor, you need to call the init function. Parameters modelSpecifies the model of the onboard image sensor. The image sensor models that can be specified are as follows: <ul> <li>ESP32Cam::CAMERA_MODEL_WROVER_KIT</li> <li>ESP32Cam::CAMERA_MODEL_ESP_EYE</li> <li>ESP32Cam::CAMERA_MODEL_M5STACK_NO_PSRAM</li> <li>ESP32Cam::CAMERA_MODEL_M5STACK_PSRAM</li> <li>ESP32Cam::CAMERA_MODEL_M5STACK_V2_PSRAM</li> <li>ESP32Cam::CAMERA_MODEL_M5STACK_WIDE</li> <li>ESP32Cam::CAMERA_MODEL_M5STACK_ESP32CAM</li> <li>ESP32Cam::CAMERA_MODEL_M5STACK_UNITCAM</li> <li>ESP32Cam::CAMERA_MODEL_AI_THINKER</li> <li>ESP32Cam::CAMERA_MODEL_TTGO_T_JOURNAL      </li> </ul>"},{"location":"esp32cam.html#getstatus","title":"getStatus","text":"<pre><code>esp_err_t getStatus(camera_status_t* status)\n</code></pre> <p>Get the <code>camera_status_t</code> data structure from the image sensor. Parameters statusPointer to the buffer to store the acquired <code>camera_status_t</code> structure. Return value ESP_OK<code>camera_status_t</code> is read successfully. ESP_FAILImage sensor is not initialized. </p>"},{"location":"esp32cam.html#getframesize","title":"getFramesize","text":"<pre><code>framesize_t getFramesize(void)\n</code></pre> <p>Get the current configuration of the image sensor frame size. Return value framesize_tThe <code>framesize_t</code> enumeration value. </p>"},{"location":"esp32cam.html#getframeheight","title":"getFrameHeight","text":"<pre><code>uint16_t  getFrameHeight(void)\n</code></pre> <p>Returns the height of the current image frame in pixels. Return value uint16_tHeight of the image frame. </p>"},{"location":"esp32cam.html#getframewidth","title":"getFrameWidth","text":"<pre><code>uint16_t  getFrameWidth(void)\n</code></pre> <p>Returns the width of the current image frame in pixels. Return value uint16_tWidth of the image frame. </p>"},{"location":"esp32cam.html#init","title":"init","text":"<pre><code>esp_err_t init(void)\n</code></pre> <pre><code>esp_err_t init(const CameraId model)\n</code></pre> <p>Initialize the image sensor. Parameters modelSpecifies the model of the onboard image sensor. The image sensor models that can be specified are as follows: <ul> <li>ESP32Cam::CAMERA_MODEL_WROVER_KIT</li> <li>ESP32Cam::CAMERA_MODEL_ESP_EYE</li> <li>ESP32Cam::CAMERA_MODEL_M5STACK_NO_PSRAM</li> <li>ESP32Cam::CAMERA_MODEL_M5STACK_PSRAM</li> <li>ESP32Cam::CAMERA_MODEL_M5STACK_V2_PSRAM</li> <li>ESP32Cam::CAMERA_MODEL_M5STACK_WIDE</li> <li>ESP32Cam::CAMERA_MODEL_M5STACK_ESP32CAM</li> <li>ESP32Cam::CAMERA_MODEL_M5STACK_UNITCAM</li> <li>ESP32Cam::CAMERA_MODEL_AI_THINKER</li> <li>ESP32Cam::CAMERA_MODEL_TTGO_T_JOURNAL      </li> </ul>"},{"location":"esp32cam.html#loadsettings","title":"loadSettings","text":"<pre><code>esp_err_t loadSettings(const char* key = nullptr)\n</code></pre> <p>Load the image sensor settings from NVS in the ESP32 flash. Parameters keySpecifies NVS key name. If key is nullptr or not specified, default key which defined by <code>ESP32CAM_NVS_KEYNAME</code> macro directive in <code>ESP32Cam.h</code> header file will be assumed. Return value ESP_OKThe image sensor settings has been successfully loaded. </p>"},{"location":"esp32cam.html#savesettings","title":"saveSettings","text":"<pre><code>esp_err_t saveSettings(const char* key = nullptr)\n</code></pre> <p>Save the current image sensor settings to NVS in the ESP32 flash. Parameters keySpecifies NVS key name. If key is nullptr or not specified, default key which defined by <code>ESP32CAM_NVS_KEYNAME</code> macro directive in <code>ESP32Cam.h</code> header file will be assumed. Return value ESP_OKThe image sensor settings has been successfully saved. </p>"},{"location":"esp32cam.html#setstatus","title":"setStatus","text":"<pre><code>esp_err_t setStatus(const camera_status_t&amp; status)\n</code></pre> <p>Set the content of <code>camera_status_t</code> structure to the image sensor. Parameters statusReference of the <code>camera_status_t</code> structure. Return value ESP_OK<code>camera_status_t</code> has been set successfully. ESP_FAILImage sensor is not initialized. </p>"},{"location":"esp32cam.html#setframesize","title":"setFramesize","text":"<pre><code>esp_err_t setFramesize(const framesize_t framesize)\n</code></pre> <p>Set the image sensor frame size. Parameters framesizeThe <code>framesize_t</code> enumeration value to be set. Return value ESP_OKFramesize has been set. ESP_ERR_CAMERA_FAILED_TO_SET_FRAME_SIZEImage sensor is not initialized, the framesize is invalid, or the pixel format is not JPEG. </p>"},{"location":"esp32cam.html#setimageformat","title":"setImageFormat","text":"<pre><code>esp_err_t setImageFormat(const pixformat_t format)\n</code></pre> <p>Set the image format. Parameters formatThe <code>pixformat_t</code> enumeration value to be set. Return value ESP_OKFormat has been set. ESP_ERR_CAMERA_FAILED_TO_SET_OUT_FORMATSpecified format is invalid. ESP_FAILImage sensor is not initialized. </p>"},{"location":"esp32cam.html#oneshot","title":"oneShot","text":"<pre><code>esp_err_t oneShot(fs::SDFS&amp; sd, const char* filename = nullptr)\n</code></pre> <pre><code>esp_err_t oneShot(fs::SDMMCFS&amp; mmc, const char* filename = nullptr)\n</code></pre> <p>Take a one-shot image and save it to the SD card or MMC. This function writes to a file compliant with the ESP32 Arduino SD library. Either <code>fs::SDFS</code> or <code>fs::SDMMCFS</code> can be specified for the file system that represents <code>sd</code> or <code>mmc</code>. Parameters sdSpecifies the <code>SD</code> file system when the SD card is wired with <code>SPI</code> interface. In usually, you can use a <code>SD</code> variable that is instantiated and exported globally by the ESP32 Arduino core. mmcSpecifies the <code>SD_MMC</code> file system when the SD card is wired with <code>HS2</code> interface. In usually, you can use a <code>SD_MMC</code> variable that is instantiated and exported globally by the ESP32 Arduino core. filenameSpecifies the file name when saving the captured image to the SD card. if the <code>filename</code> does not exist, it assumes a file name consisting of a prefix and a timestamp. In that case, the fixed string defined by the <code>ESP32CAM_GLOBAL_IDENTIFIER</code> macro directive in <code>ESP32Cam.h</code> is used as the prefix. Return value ESP_OKFormat has been set. ESP_ERR_NOT_FOUNDSD card is not mounted. ESP_FAILOther error occurred. </p>"},{"location":"esp32cam.html#timershot","title":"timerShot","text":"<pre><code>esp_err_t timerShot(const unsigned long period, fs::SDFS&amp; sd, const char* filePrefix = nullptr)\n</code></pre> <pre><code>esp_err_t timerShot(const unsigned long period, fs::SDMMCFS&amp; mmc, const char* filePrefix = nullptr)\n</code></pre> <p>Repeatedly takes a one-shot image at specified an interval of seconds with <code>period</code> parameter and saves it to the SD card or MMC. This function writes to a file compliant with the ESP32 Arduino SD library. Either <code>fs::SDFS</code> or <code>fs::SDMMCFS</code> can be specified for the file system that represents <code>sd</code> or <code>mmc</code>. Parameters periodSpecifies the shooting interval time in second unit. sdSpecifies the <code>SD</code> file system when the SD card is wired with <code>SPI</code> interface. In usually, you can use a <code>SD</code> variable that is instantiated and exported globally by the ESP32 Arduino core. mmcSpecifies the <code>SD_MMC</code> file system when the SD card is wired with <code>HS2</code> interface. In usually, you can use a <code>SD_MMC</code> variable that is instantiated and exported globally by the ESP32 Arduino core. filePrefixSpecifies the prefix of file name when saving the captured image to the SD card. This function saves files each time whose name consists of the prefix and timestamp suffix specified by the <code>filePrefix</code> parameter. If the <code>filePrefix</code> does not exist, it assumes a fixed string defined by the <code>ESP32CAM_GLOBAL_IDENTIFIER</code> macro directive in <code>ESP32Cam.h</code> for the prefix. Return value ESP_OKFormat has been set. ESP_ERR_NOT_FOUNDSD card is not mounted. ESP_FAILOther error occurred. </p>"},{"location":"esp32cam.html#disabletimershot","title":"disableTimerShot","text":"<pre><code>void disableTimerShot(void)\n</code></pre> <p>Temporarily stops the <code>timerShot</code>. To restart it, call <code>enableTimerShot</code>.</p>"},{"location":"esp32cam.html#enabletimershot","title":"enableTimerShot","text":"<pre><code>void enableTimerShot(void)\n</code></pre> <p>Restarts the <code>timerShot</code> that was temporarily stopped by <code>disableTimerShot</code>.</p>"},{"location":"esp32cam.html#deq","title":"deq","text":"<pre><code>void deq(void)\n</code></pre> <p>Release a semaphore.</p>"},{"location":"esp32cam.html#enq","title":"enq","text":"<pre><code>portBASE_TYPE enq(TickType_t ms)\n</code></pre> <p>Take a semaphore to prevent resource collisions with the image sensor. ESP32Cam uses a semaphore for each of <code>oneShot</code> and <code>timerShot</code> to prevent image sensor resources from colliding while performing each other's tasks. The <code>enq</code> function reserves a semaphore to wait for a subsequent <code>oneShot</code> or <code>timerShot</code> task. Parameters msSpecifies the maximum waiting time in milliseconds for a semaphore to be released. If <code>portMAX_DELAY</code> is specified, it will wait indefinitely for the semaphore to be released. Return value pdTRUESemaphore was reserved. !pdTRUESemaphore was not released within the specified <code>ms</code> time. </p>"},{"location":"esp32cam.html#webcamserver-like-as-camerawebserver","title":"WebCamServer like as CameraWebServer","text":"<p>The WebCamServer.ino sketch combines AutoConnectAux's custom web pages with native HTML pages. The image viewer is placed on the native HTML page using the <code>img</code> tag, and the slide-in navigation panel is incorporated using CSS. AutoConnect is only directly involved in the image sensor setup page, which is JSON defined in <code>CAMERA_SETUP_PAGE</code>. The <code>setSensor</code> function in the sketch is a handler for a custom web page for <code>CAMERA_SETUP_PAGE</code>, and its role is to communicate the sensor settings to the ESP32 camera driver via ESP32Cam.</p> <p> </p> <p>In the WebCamServer.ino sketch, most of the front-end is taken care of by the UI, which is a web page written in HTML. The slide-in menu allows navigation to stream images, capture still images, save a one-shot image to the SD card, and the timer-shot. Image streaming and capture are achieved by giving the URLs of the Stream endpoint and Capture endpoint in the <code>src</code> attribute of the <code>img</code> tag in the HTML using JavaScript DOM interface.</p> <pre><code>&lt;body&gt;\n  &lt;li id=\"onair\" onclick=\"stream(!isStreaming())\"&gt;Start Streaming&lt;/li&gt;\n  &lt;img id=\"img-frame\" /&gt;\n&lt;/body&gt;\n</code></pre> <pre><code>const onAir = document.getElementById('onair');\nconst imgFrame = document.getElementById('img-frame');\n\nfunction isStreaming() {\nstatus.innerText = null;\nreturn onAir.innerText.startsWith(\"Stop\");\n}\n\nfunction stream(onOff) {\nif (onOff &amp;&amp; !isStreaming()) {\n    window.stop();\nimgFrame.src = streamUrl;\nonAir.innerText = onAir.innerText.replace(\"Start\", \"Stop\");\ncontent.focus();\n  }\nelse if (!onOff &amp;&amp; isStreaming()) {\n    window.stop();\nimgFrame.src = noa;\nonAir.innerText = onAir.innerText.replace(\"Stop\", \"Start\");\n  }\n}\n</code></pre> <p>Also, One-shot and timer-shot also use JavaScript Fetch API to send a query string compliant with each function to the Prompt endpoint.</p> <pre><code>&lt;li id=\"oneshot\" onclick=\"oneshot()\"&gt;One-Shot&lt;/li&gt;\n&lt;li&gt;&lt;label for=\"period\"&gt;Period [s]&lt;/label&gt;&lt;input type=\"number\" name=\"peirod\" id=\"period\" min=\"1\" value=\"1\" pattern=\"\\d*\"/&gt;&lt;/li&gt;\n&lt;li&gt;&lt;input type=\"button\" value=\"ARM\" onclick=\"arm()\"/&gt;&lt;/li&gt;\n</code></pre> <pre><code>var promptUrl = endpoint(host, promptPath, port);\n\nfunction endpoint(host, path, port) {\nvar url = new URL(path, \"http://\" + host);\nurl.port = port;\nreturn url;\n}\n\nfunction prompt(url) {\nvar res;\nstream(false);\nfetch(url)\n    .then(response =&gt; {\nres = \"status:\" + response.status + \" \";\nif (!response.ok) {\nreturn response.text().then(text =&gt; {\nthrow new Error(text);\n        });\n      }\nelse {\nstatus.style.color = '#297acc';\nstatus.innerText = res + response.statusText;\n      }\n    })\n    .catch(err =&gt; {\nvar desc = err.message;\nif (err.message.indexOf(\"0x0103\", 1) &gt; 0) {\ndesc = \"SD not mounted\";\n      }\nif (err.message.indexOf(\"0x0105\", 1) &gt; 0) {\ndesc = \"SD open failed\";\n      }\nstatus.style.color = '#cc2929';\nstatus.innerText = res + desc;\n    });\n}\n\nfunction oneshot() {\npromptUrl.search = \"?mf=oneshot&amp;fs=mmc\";\nprompt(promptUrl);\n}\n\nfunction arm() {\npromptUrl.search = \"?mf=timershot&amp;fs=mmc&amp;period=\" + document.getElementById('period').value;\nprompt(promptUrl);\n}\n</code></pre> <p>The following diagram shows the program structure of the WebCamServer.ino sketch. Its structure is somewhat more complex than the simple sketch presented at the beginning of this chapter because of the native HTML intervening.</p> <p></p> <ol> <li> <p>ESP32WebCam endpoint interface supports only HTTP GET method, it cannot respond to other HTTP methods such as POST.\u00a0\u21a9</p> </li> <li> <p>Do not use the REST Client to send requests to the stream endpoints, the REST Client does not fully support multipart/x-mixed-replace mime.\u00a0\u21a9</p> </li> <li> <p>When using MMC on AI-Thinker ES32-CAM, the LED flash on the module blinks every time the SD is accessed, because the <code>HS2 DATA1</code> signal is wired to the driver transistor of the <code>LED FLASH</code>. I can't envision why <code>HS2 DATA1</code> signal was chosen to drive the LED.\u00a0\u21a9</p> </li> </ol>"},{"location":"faq.html","title":"FAQ","text":""},{"location":"faq.html#after-connected-autoconnect-menu-performs-but-no-happens","title":"After connected, AutoConnect menu performs but no happens.","text":"<p>If you can access the AutoConnect root path as http://ESP8266IPADDRESS/_ac from browser, probably the Sketch uses ESP8266WebServer::handleClient() without AutoConnect::handleRequest(). For AutoConnect menus to work properly, call AutoConnect::handleRequest() after ESP8266WebServer::handleClient() invoked, or use AutoConnect::handleClient(). AutoConnect::handleClient() is equivalent ESP8266WebServer::handleClient combined AutoConnect::handleRequest().</p> <p>See also the explanation here.</p>"},{"location":"faq.html#after-updating-to-autoconnect-v100-established-aps-disappear-from-open-ssids-with-esp32","title":"After updating to AutoConnect v1.0.0, established APs disappear from Open SSIDs with ESP32.","text":"<p>Since AutoConnect v1.0.0 for ESP32, the storage location in the flash of established credentials has moved from EEPROM to Preferences. After You update AutoConnect to v1.0.0, past credentials saved by v0.9.12 earlier will not be accessible from the AutoConnect menu - Open SSIDs. You need to transfer once the stored credentials from the EEPROM area to the Preferences area.</p> <p>You can migrate the past saved credentials using CreditMigrate.ino which the examples folder contains.</p> <p>Needs to Arduino core for ESP32 1.0.2 or earlier</p> <p>EEPROM area with arduino-esp32 core 1.0.3 has moved from partition to the nvs. CreditMigrate.ino requires arduino-esp32 core 1.0.2 or earlier to migrate saved credentials.</p>"},{"location":"faq.html#an-esp8266ap-as-softap-was-connected-but-captive-portal-does-not-start","title":"An esp8266ap as SoftAP was connected but Captive portal does not start.","text":"<p>Captive portal detection could not be trapped. It is necessary to disconnect and reset ESP8266 to clear memorized connection data in ESP8266. Also, It may be displayed on the smartphone if the connection information of esp8266ap is wrong. In that case, delete the connection information of esp8266ap memorized by the smartphone once.</p>"},{"location":"faq.html#autoconnect-web-pages-are-broken","title":"AutoConnect Web Pages are broken.","text":"<p>When the captive portal opens, AutoConnect's embedded web page may be broken or display an incomplete menu like the one below. This is due to AutoConnect temporarily abandoning HTML generation because the ESP module's heap memory was exhausted. This phenomenon may frequently occur, especially with ESP8266 Arduino core 3.1.0 or later.</p> <p></p> <p>ESP8266 Arduino core 3.1.0 or later has increased heap consumption due to the application of Non-OS SDK 3.0.x. This makes the ESP8266 more prone to running out of memory than previous core versions.</p> <p>To reduce RAM consumption, apply workarounds such as reducing the number of AutoConnectElements placed on the custom web pages, or enabling AutoConnectOTA only when a WiFi connection is established to an access point. For example, the code snippet for enabling OTA when a WiFi connection is established is as follows:</p> <pre><code>AutoConnect portal;\nAutoConnectConfig config;\n\nvoid wifiConnect(IPAddress&amp; ip) {\n  Serial.println(\"WiFi connected:\" + WiFi.SSID());\n  Serial.println(\"IP:\" + WiFi.localIP().toString());\n  config.ota = AC_OTA_BUILTIN;\n  portal.config(config);\n}\n\nvoid setup() {\n  delay(1000);\n  Serial.begin(115200);\n  Serial.println();\n\n  portal.onConnect(wifiConnect);\n  portal.begin();\n}\n\nvoid loop() {\n  portal.handleClient();\n}\n</code></pre>"},{"location":"faq.html#cannot-automatically-reconnect-to-a-wifi-hotspot","title":"Cannot automatically reconnect to a WiFi Hotspot","text":"<p>WiFi Hotspot ability using a cell phone has no official designation name, but it is commonly referred to as a mobile hotspot or a Personal Hotspot. Generally, this feature using data communication with your cellular to ensure the connection to the Internet. AutoConnect allows you to connect to a WiFi hotspot that has been temporarily launched as an access point and then stores a credential for establishing a connection in the same way as a regular fixed access point.</p> <p>However, there's a case where it may not be able to reconnect automatically to a known WiFi hotspot. For security reasons, some device operating systems randomly change the MAC address of the WiFi hotspot at each boot for a hotspot. (Especially iOS14) AutoConnect uses the BSSID to find the known SSID from among WiFi signals being broadcast. (it's the MAC address) This method works if the BSSID that the hotspot originates is fixed, but AutoConnect will not be able to find known SSIDs when it changes. Consider activating the AUTOCONNECT_APKEY_SSID definition if you want to reconnect automatically to a known WiFi hotspot.</p> <p>Cannot immobilize the MAC address of Personal Hotspot</p> <p>We may not be able to immobilize the MAC address of Personal Hotspot on iOS14. This specification change seems to be related to the private network connection enhancement of iOS14 devices. I found this change during the testing phase, but it is not the confirmed information. (iOS14 offers an option to immobilize the MAC address as a client device, but there is still no option to immobilize it where the device became a hotspot)</p>"},{"location":"faq.html#captive-portal-does-not-pop-up","title":"Captive portal does not pop up.","text":"<p>If the ESP module is already transparent to the Internet, the device's captive portal screen does not pop up even if AutoConnectConfig::retainPortal is enabled. The captive portal popup may also be misinterpreted as automatically activated when AutoConnect is disconnected from the Internet.</p> <p>When your device connects to an access point, it determines if it is also transparent to the Internet according to the HTTP response from a specific URL. AutoConnect traps the HTTP request issued by the device and responds with a portal screen for AutoConnect. Then the device automatically pops up the HTML in response. It means the auto-popup when opening a captive portal is a feature your device OS has. In this mechanism, AutoConnect impersonates an internally launched DNS server response to trap HTTP requests for Internet transparency determination.</p> <p>However, its DNS response disguise is very rough, redirecting all FQDNs that do not end in .local to the SoftAP IP address of the ESP module. The redirect location is <code>/_ac</code>, and the responder for <code>/_ac</code> is AutoConnect. This kind of hack is also available as an example in the Arduino ESP8266/ESP32 DNS server library.</p> <p>The reason AutoConnect shuts down the DNS server after establishing a connection with a WiFi access point and stops hacking HTTP requests for Internet transparency detection is because AutoConnect can only trap a broad range of DNS requests. After the ESP module connects to the access point, the sketch can access the Internet using the FQDN. To prevent it from interfering with that access, AutoConnect will stop the internally launched DNS. In other words, the only scene that allows automatic pop-ups to lead to the captive portal is when the ESP module is not transparent to the Internet.</p> <p>Instead, AutoConnect has options to restart the internal DNS server when the ESP module loses WiFi connectivity, allowing the device to auto-pop up a captive portal screen. If the sketch enables AutoConnectConfig::retainPotral and AutoConnectConfig::autoRise, then when the WiFi connection is lost (i.e. <code>WiFi.status() != WL_CONNECTED</code>), AutoConnect will initiate a trap by starting the SoftAP and the internal DNS server. At this time, the ESP module will transition to WIFI_AP_STA mode. The AutoConnect::handleClient function performs this restart sequence each time it is called, so the sketch can resume the captive portal automatic pop-up while the <code>loop</code> function is running.</p>"},{"location":"faq.html#compile-error-due-to-file-system-header-file-not-found","title":"Compile error due to File system header file not found","text":"<p>In PlatformIO, it may occur compilation error such as the bellows:</p> <pre><code>In file included from C:\\Users\\&lt;user&gt;\\Documents\\Arduino\\libraries\\AutoConnect\\src\\AutoConnect.h:30:0,\nfrom src/main.cpp:28:\nC:\\Users\\&lt;user&gt;\\Documents\\Arduino\\libraries\\PageBuilder\\src\\PageBuilder.h:88:27:\nfatal error: SPIFFS.h: No such file or directory\n</code></pre> <pre><code>In file included from C:\\Users\\&lt;user&gt;\\Documents\\Arduino\\libraries\\AutoConnect\\src\\AutoConnect.h:30,\nfrom src\\main.cpp:28:\nC:\\Users\\&lt;user&gt;\\Documents\\Arduino\\libraries\\PageBuilder\\src\\PageBuilder.h:93:17:\nfatal error: LittleFS.h: No such file or directory\n</code></pre> <p>This compilation error is due to PlatformIO's Library Dependency Finder not being able to detect <code>#include</code> with default mode <code>chain</code>. Chain mode does not recursively evaluate <code>.cpp</code> files. However, AutoConnect determines the default file system at compile time, depending on the platform. In order for LDF to detect it correctly, it is necessary to recursively scan <code>#include</code> of the header file, which depends on the file system used.</p> <p>To avoid compilation errors in PlatformIO, specify <code>lib_ldf_mode</code> in <code>platformio.ini</code> as follows:</p> <pre><code>[env]\nlib_ldf_mode = deep+\n</code></pre> <p>You should specify <code>deep+</code> with <code>lib_ldf_mode</code>.</p> <p>Another option is to explicitly specify the file system to be applied to AutoConnect at build time. The compiler determines the file system to be applied to AutoConnect by preprocessor macro definitions defined in AutoConnectDefs.h. The directives defined as <code>AC_USE_SPIFFS</code> and <code>AC_USE_LITTLEFS</code> specify that the respective file systems apply. The chapter Using Filesystem details how to explicitly specify a file system for AutoConnect in PlatformIO.</p>"},{"location":"faq.html#compile-error-occurs-due-to-the-text-section-exceeds","title":"Compile error occurs due to the text section exceeds","text":"<p>When building the sketch, you may receive a compilation error message similar that the text section exceeds the available space on the board. This error occurs with ESP32 arduino core 2.0.0 or later. Since ESP32 arduino core 2.0.0, the object size of the library tends to be oversized, and the AutoConnect object size is also bloated. And also for some example sketches such as mqttRSSI, the BIN size after linkage does not fit in the default partition scheme.</p> <p>I'm aware of this issue1 and trying to reduce the size of the AutoConnect object, but for now, changing the partition table at build is the most effective workaround. See How much memory does AutoConnect consume? for information on how to change the partition table.</p>"},{"location":"faq.html#compile-error-that-eeprom-was-not-declared-in-this-scope","title":"Compile error that 'EEPROM' was not declared in this scope","text":"<p>If the user sketch includes the header file as <code>EEPROM.h</code>, this compilation error may occur depending on the order of the <code>#include</code> directives. <code>AutoConnectCredentials.h</code> including in succession linked from <code>AutoConnect.h</code> defines NO_GLOBAL_EEPROM internally, so if your sketch includes <code>EEPROM.h</code> after <code>AutoConnect.h</code>, the EEPROM global variable will be lost.</p> <p>If you use EEPROM with your sketch, declare <code>#include &lt;EEPROM.h&gt;</code> in front of <code>#include &lt;AutoConnect.h&gt;</code>.</p>"},{"location":"faq.html#compile-error-that-esphttpupdate-was-not-declared-in-this-scope","title":"Compile error that 'ESPhttpUpdate' was not declared in this scope","text":"<p>If the user sketch includes the header file as <code>ESP8266httpUpdate.h</code>, this compilation error may occur depending on the order of the <code>#include</code> directives. <code>AutoConnectUpdate.h</code> including in succession linked from <code>AutoConnect.h</code> defines NO_GLOBAL_HTTPUPDATE internally, so if your sketch includes <code>ESP8266httpUpdate.h</code> after <code>AutoConnect.h</code>, the ESPhttpUpdate global variable will be lost.</p> <p>You can avoid a compile error in one of two ways:</p> <ol> <li> <p>Disable an AutoConnectUpdate feature if you don't need.</p> <p>You can disable the AutoConnectUpdate feature by commenting out the AUTOCONNECT_USE_UPDATE macro in the <code>AutoConnectDefs.h</code> header file. <pre><code>#define AUTOCONNECT_USE_UPDATE\n</code></pre></p> </li> <li> <p>Change the order of <code>#include</code> directives.</p> <p>With the Sketch, <code>#include &lt;ESP8266httpUpdate.h&gt;</code> before <code>#include &lt;AutoConnect.h&gt;</code>.</p> </li> </ol>"},{"location":"faq.html#connection-lost-immediately-after-establishment-with-ap","title":"Connection lost immediately after establishment with AP","text":"<p>A captive portal is disconnected immediately after the connection establishes with the new AP. This is a known problem of ESP32, and it may occur when the following conditions are satisfied at the same time.</p> <ul> <li>SoftAP channel on ESP32 and the connecting AP channel you specified are different. (The default channel of SoftAP is 1.)</li> <li>NVS had erased by erase_flash causes the connection data lost. The NVS partition has been moved. Never connected to the AP in the past.</li> <li>There are receivable multiple WiFi signals which are the same SSID with different channels using the WiFi repeater etc. (This condition is loose, it may occur even if there is no WiFi repeater.)</li> <li>Or the using channel of the AP which established a connection is congested with the radio signal on the same band. (If the channel crowd, connections to known APs may also fail.)</li> </ul> <p>Other possibilities</p> <p>The above conditions are not absolute. It results from my investigation, and other conditions may exist.</p> <p>To avoid this problem, try changing the channel.</p> <p>ESP32 hardware equips only one RF circuitry for WiFi signal. At the AP_STA mode, ESP32 as an AP attempts connect to another AP on another channel while keeping the connection with the station then the channel switching will occur causes the station may be disconnected. But it may not be just a matter of channel switching causes ESP8266 has the same constraints too. It may be a problem with AutoConnect or the arduino core or SDK issue. This problem will persist until a specific solution.</p>"},{"location":"faq.html#data-saved-to-eeprom-is-different-from-my-sketch-wrote","title":"Data saved to EEPROM is different from my sketch wrote.","text":"<p>By default, AutoConnect saves the credentials of the established connection into EEPROM. The credential area of EEPROM used by AutoConnect will conflict with data owned by the user sketch if without measures taken. It will destroy the user sketch data and the data stored in EEPROM by AutoConnect with each other. You have the following two options to avoid this conflict:</p> <ul> <li> <p>Move the credential saving area of EEPROM.   You can protect your data from corruption by notifying AutoConnect where to save credentials. Notification of the save location for the credentials uses AutoConnectConfig::boundaryOffset option. Refer to the chapter on Move the saving area of EEPROM for the credentials for details.</p> </li> <li> <p>Suppresses the automatic save operation of credentials by AutoConnect.   You can completely stop saving the credentials by AutoConnect. However, if you select this option, you lose the past credentials which were able to connect to the AP. Therefore, the effect of the automatic reconnection feature will be lost.   If you want to stop the automatic saving of the credentials, uses AutoConnectConfig::autoSave option specifying AC_SAVECREDENTIAL_NEVER. Refer to the chapter on Advanced usage for details.</p> </li> </ul>"},{"location":"faq.html#does-not-appear-esp8266ap-in-smartphone","title":"Does not appear esp8266ap in smartphone.","text":"<p>Maybe it is successfully connected at the 1st-WiFi.begin. ESP8266 remembers the last SSID successfully connected and will use at the next. It means SoftAP will only start up when the first WiFi.begin() fails.</p> <p>The saved SSID would be cleared by  WiFi.disconnect() with WIFI_STA mode. If you do not want automatic reconnection, you can erase the memorized SSID with the following simple sketch.</p> <pre><code>#include &lt;ESP8266WiFi.h&gt;\n\nvoid setup() {\n  delay(1000);\n  Serial.begin(115200);\n  WiFi.mode(WIFI_STA);\n  delay(100);\n  WiFi.begin();\nif (WiFi.waitForConnectResult() == WL_CONNECTED) {\n    WiFi.disconnect();\nwhile (WiFi.status() == WL_CONNECTED)\n      delay(100);\n  }\n  Serial.println(\"WiFi disconnected.\");\n}\n\nvoid loop() {\n  delay(1000);\n}\n</code></pre> You can interactively check the WiFi state of ESP8266. <p>Please try ESPShaker. It is ESP8266 interactive serial command processor.</p> <p></p>"},{"location":"faq.html#does-not-response-from-_ac","title":"Does not response from /_ac.","text":"<p>Probably WiFi.begin failed with the specified SSID. Activating the debug printing will help you to track down the cause.</p>"},{"location":"faq.html#hang-up-after-reset","title":"Hang up after Reset?","text":"<p>If ESP8266 hang up after reset by AutoConnect menu, perhaps manual reset is not yet. Especially if it is not manual reset yet after uploading the Sketch, the boot mode will stay 'Uart Download'. There is some discussion about this on the Github's ESP8266 core: https://github.com/esp8266/Arduino/issues/1017 2</p> <p>If you received the following message, the boot mode is still sketch uploaded. It needs to the manual reset once.</p> <pre><code>ets Jan  8 2013,rst cause:2, boot mode:(1,6) or (1,7)\nets Jan  8 2013,rst cause:4, boot mode:(1,6) or (1,7)\nwdt reset\n</code></pre> <p>The correct boot mode for starting the Sketch is (3, x).</p> <p>ESP8266 Boot Messages</p> <p>It is described by ESP8266 Non-OS SDK API Reference, section A.5.</p> Messages Description rst cause 1: power on2: external reset4: hardware watchdog reset boot mode(the first parameter) 1: ESP8266 is in UART-down mode (and downloads firmware into flash).3: ESP8266 is in Flash-boot mode (and boots up from flash)."},{"location":"faq.html#how-can-i-detect-the-captive-portal-starting","title":"How can I detect the captive portal starting?","text":"<p>You can use the AutoConnect::onDetect exit routine. For more details and an implementation example of the onDetect exit routine, refer to the chapter Captive portal start detection.</p>"},{"location":"faq.html#how-change-http-port","title":"How change HTTP port?","text":"<p>HTTP port number is defined as a macro in AutoConnectDefs.h header file. You can change it directly with several editors and must re-compile.</p> <pre><code>#define AUTOCONNECT_HTTPPORT    80\n</code></pre>"},{"location":"faq.html#how-change-ssid-or-password-in-captive-portal","title":"How change SSID or Password in Captive portal?","text":"<p>You can change both by using AutoConnectConfig::apid and AutoConnectConfig::psk. Refer to section Change SSID and Password for SoftAP in Settings and controls for network and WiFi.</p>"},{"location":"faq.html#how-do-i-detach-the-ardunojson","title":"How do I detach the ArdunoJson?","text":"<p>If you don't use ArduinoJson at all, you can detach it from the library. By detaching ArduinoJson, the binary size after compilation can be reduced. You can implement custom Web pages with your sketches without using ArduinoJson. Its method is described in Custom Web pages w/o JSON. To completely remove ArduinoJson at compile-time from the binary, you need to define a special <code>#define</code> directive for it. And if you define the directive, you will not be able to use the OTA update with the update server feature as well as AutoConnectAux described by JSON.</p> <p>To exclude ArduinoJson at compile-time, give the following <code>#define</code> directive as a compiler option such as the arduino-cli or PlatformIO.</p> <pre><code>#define AUTOCONNECT_NOUSE_JSON\n</code></pre> <p>For example, add the following description to the <code>[env]</code> section of the <code>platformio.ini</code> file with the <code>build-flags</code>.</p> <pre><code>build-flags = -DAUTOCONNECT_NOUSE_JSON\n</code></pre>"},{"location":"faq.html#how-erase-the-credentials-saved-in-eeprom","title":"How erase the credentials saved in EEPROM?","text":"<p>Make some sketches for erasing the EEPROM area, or some erasing utility is needed. You can prepare the Sketch to erase the saved credential with AutoConnectCredential. The AutoConnectCrendential class provides the access method to the saved credential in EEPROM and library source file is including it. Refer to Saved credential access for details.</p> <p>Hint</p> <p>With the ESPShaker, you can access EEPROM interactively from the serial monitor, and of course you can erase saved credentials.</p>"},{"location":"faq.html#how-locate-the-link-button-to-the-autoconnect-menu","title":"How locate the link button to the  AutoConnect menu?","text":"<p>Link button to AutoConnect menu can be embedded into Sketch's web page. The root path of the menu is /_ac by default and embed the following <code>&lt;a&gt;&lt;/a&gt;</code> tag in the generating HTML.</p> <pre><code>&lt;a style=\"background-color:SteelBlue; display:inline-block; padding:7px 13px; text-decoration:none;\" href=\"/_ac\"&gt;MENU&lt;/a&gt;\n</code></pre>"},{"location":"faq.html#how-much-memory-does-autoconnect-consume","title":"How much memory does AutoConnect consume?","text":""},{"location":"faq.html#sketch-size","title":"Sketch size","text":"<ol> <li> <p>For ESP8266    It increases about 53K bytes compared to the case without AutoConnect. A sketch size of the most simple example introduced in the Getting started is about 330K bytes. (270K byte without AutoConnect)</p> </li> <li> <p>For ESP32    The BIN size of the sketch grows to over 1M bytes. In the case of a sketch with many custom Web pages, when applying the partition table for the default scheme, the remaining flash size that can be utilized by the user application may be less than 200K bytes. Therefore, it is advisable to resize the partition to make more available space for the application. The ESP32 arduino core has various partition schemes, and you can choose it according to your Sketch feature.    You can change the partition scheme from the Tools &gt; Partition Scheme menu of Arduino IDE.</p> </li> </ol> <p></p> <p>Change the partition scheme with PlatformIO</p> <p>Use <code>board_build.partitions</code> directive with <code>platformio.ini</code>. <pre><code>[env:esp32dev]\nboard_build.partitions = min_spiffs.csv\n</code></pre> Details for the PlatformIO documentation.</p>"},{"location":"faq.html#heap-size","title":"Heap size","text":"<p>It consumes about 2K bytes in the static and about 12K bytes are consumed at the moment when menu executed.</p> <p>Reducing Binary Size</p> <p>For sketches that do not require OTA feature or Custom Web pages, the build size can be reduced. See Reducing Binary Size in Basic Usage for details.</p>"},{"location":"faq.html#how-placing-a-style-qualified-autoconnecttext-horizontally","title":"How placing a style-qualified AutoConnectText horizontally?","text":"<p>When the style parameter is specified for AutoConnectText, it is always enclosed by the <code>&lt;div&gt;</code> tag, so the element placement direction is vertical and subsequent elements cannot be horizontal. If you want to place an element after AutoConnectText with the style, you can place the AutoConnectText horizontally by specifying the <code>display</code> CSS property with <code>inline</code> or <code>inline-block</code> in the style value. </p> <pre><code>{\n\"name\": \"text1\",\n\"type\": \"ACText\",\n\"value\": \"Hello,\",\n\"style\": \"display:inline;color:#f5ad42;font-weight:bold;margin-right:3px\"\n},\n{\n\"name\": \"text2\",\n\"type\": \"ACText\",\n\"value\": \"world\",\n\"posterior\": \"br\"\n}\n</code></pre> <p>See also AutoConnectText chapter, CSS Flow Layout by MDN.</p>"},{"location":"faq.html#how-placing-html-elements-undefined-in-autoconnectelements","title":"How placing HTML elements undefined in AutoConnectElements?","text":"<p>AutoConnectElement can be applied in many cases when trying to place HTML elements that are undefined in AutoConnectElemets on custom Web pages. See Handling the custom Web Pages section.</p>"},{"location":"faq.html#i-cannot-complete-to-wifi-login-from-smartphone","title":"I cannot complete to WiFi login from smartphone.","text":"<p>Because AutoConnect does not send a login success response to the captive portal requests from the smartphone. The login success response varies iOS, Android and Windows. By analyzing the request URL of different login success inquiries for each OS, the correct behavior can be implemented, but not yet. Please resets ESP8266 from the AutoConnect menu.</p>"},{"location":"faq.html#i-cannot-see-the-custom-web-page","title":"I cannot see the custom Web page.","text":"<p>If the Sketch is correct, a JSON syntax error may have occurred. In this case, activate the AC_DEBUG and rerun. If you take the message of JSON syntax error, the Json Assistant helps syntax checking. This online tool is provided by the author of ArduinoJson and is most consistent for the AutoConnect. </p>"},{"location":"faq.html#nvs_open-failed-not_found-occurs","title":"nvs_open failed: NOT_FOUND occurs.","text":"<p>In ESP32, NVS open failure may occur during execution of AutoConnect::begin with the following message on the Serial monitor.</p> <pre><code>[E][Preferences.cpp:38] begin(): nvs_open failed: NOT_FOUND\n</code></pre> <p>This is not a malfunction and expected behavior. AutoConnect will continue to execute normally.</p> <p>AutoConnect saves the credentials of the access point to which it was able to connect to the NVS of the ESP32 module as Preferences instances. The above error occurs when the area keyed for AutoConnect credentials does not exist in NVS. Usually, this error occurs immediately after erasing the ESP32 module flash or when running the AutoConnect sketch for the first time. If the AutoConnect credentials area does not exist in NVS, AutoConnect will automatically allocate it. Therefore, this error can be ignored and will not affect the execution of the sketch.</p>"},{"location":"faq.html#request-handler-not-found-in-webserver","title":"Request handler not found in WebServer.","text":"<p>It forms the following message as the most common form.</p> <pre><code>request handler not found\n</code></pre> <p>In ESP32, the above message has a detailed issuer.</p> <pre><code>[WebServer.cpp:649] _handleRequest(): request handler not found\n</code></pre> <p>If this message appears just by opening your custom web page or AutoConnect built-in page from a browser, it is probably the browser requesting a favicon for that html page. Please instead of prematurely assuming that the detection of this message indicates an implementation flaw, identify the URL from which the request originated. You can find it in the AutoConnect trace that outputs to the serial monitor by enabling <code>AC_DEBUG</code> macro.</p> <p>You can probably find the above message in the <code>AC_DEBUG</code> trace log. And if you can find the following trace just before that message, your sketch is working fine.</p> <pre><code>[AC] Host:192.168.1.17,/favicon.ico,ignored\n</code></pre> <p>It's just the browser asking for a favicon. Of course, your sketch doesn't have a favicon. That's what the \"request handler not found\" message means.</p> <p>The <code>AC_DEBUG</code> trace will record URL requests for which no request handler exists. If you find a <code>[AC] Host: IP_ADDRESS, URL, ignored</code> style message in the <code>AC_DEBUG</code> log, the request handler for that URL has not been registered with the WebServer. Even if your sketch has a custom web page with the said URL, it is probably causing a JSON syntax error and failing to deserialize. In such cases, the ArduinoJson Assistant can be helpful. It will find syntax errors in the JSON description for your custom web page.</p>"},{"location":"faq.html#saved-credentials-are-wrong-or-lost","title":"Saved credentials are wrong or lost.","text":"<p>A structure of AutoConnect saved credentials has changed two times throughout enhancement with v1.0.3 and v1.1.0. In particular, due to enhancements in v1.1.0, AutoConnectCredential data structure has lost the backward compatibility with previous versions. You must erase the flash of the ESP module using the esptool completely to save the credentials correctly with v1.1.0. <pre><code>esptool -c esp8266 (or esp32) -p [COM_PORT] erase_flash\n</code></pre></p>"},{"location":"faq.html#some-autoconnect-page-is-cut-off","title":"Some AutoConnect page is cut off.","text":"<p>It may be two possibilities as follows:</p> <ol> <li>Packet loss during transmission due to a too weak WiFi signal.</li> <li>Heap is insufficient memory. AutoConnect entrusts HTML generation to PageBuilder that makes heavy use the String::concatenate function and causes memory fragmentation. This is a structural problem with PageBuilder, but it is difficult to solve immediately.</li> </ol> <p>If this issue produces with your sketch, Reloading the page may recover. Also, you can check the memory running out status by rebuilding the Sketch with PageBuilder's debug log option turned on.</p> <p>If the heap memory is insufficient, the following message is displayed on the serial console.</p> <pre><code>[PB] Failed building, free heap:&lt;Size of free heap&gt;\n</code></pre>"},{"location":"faq.html#submit-element-in-a-custom-web-page-does-not-react","title":"Submit element in a custom Web page does not react.","text":"<p>Is there the AutoConnectElements element named SUBMIT in the custom Web page? (case sensitive ignored) AutoConnect does not rely on the <code>input type=submit</code> element for the form submission and uses HTML form element submit function instead. So, the submit function will fail if there is an element named 'submit' in the form. You can not use SUBMIT as the element name of AutoConnectElements in a custom Web page that declares the AutoConnectSubmit element.</p>"},{"location":"faq.html#unable-to-change-any-macro-definitions-by-the-sketch","title":"Unable to change any macro definitions by the Sketch.","text":"<p>The various macro definitions that determine the configuration of AutoConnect cannot be redefined by hard-coding with Sketch. The compilation unit has a different AutoConnect library itself than the Sketch, and the configuration definitions in AutoConnectDefs.h are quoted in the compilation for AutoConnect only. For example, the following Sketch does not enable AC_DEBUG and does not change HTTP port also the menu background color:</p> <pre><code>#define AC_DEBUG                                    // No effect\n#define AUTOCONNECT_HTTPPORT    8080                // No effect\n#define AUTOCONNECT_MENUCOLOR_BACKGROUND  \"#696969\" // No effect\n#include &lt;ESP8266WiFi.h&gt;\n#include &lt;ESP8266WebServer.h&gt;\n#include &lt;AutoConnect.h&gt;\n\nAutoConnect Portal;\n\nvoid setup() {\n  Portal.begin();\n}\n\nvoid loop() {\n  Portal.handleClient();\n}\n</code></pre> <p>To enable them, edit <code>AutoConnectDefs.h</code> as the library source code directly, or supply them as the external parameters using a build system like PlatformIO with <code>platformio.ini</code>:</p> <pre><code>platform = espressif8266\nboard = nodemcuv2\nboard_build.f_cpu = 160000000L\nboard_build.f_flash = 80000000L\nboard_build.flash_mode = dio\nboard_build.filesystem = littlefs\nbuild_flags =\n-DAC_DEBUG\n-DAUTOCONNECT_HTTPPORT=8080\n-DAUTOCONNECT_MENUCOLOR_BACKGROUND='\"#696969\"'\n</code></pre>"},{"location":"faq.html#unauthorize-error-without-prompting-the-login-dialog","title":"Unauthorize error without prompting the login dialog.","text":"<p>The custom web pages that require authentication will occur unauthorized error always without prompting the login dialog under the captive portal state on some OS. This is a captive portal restriction and expected behavior. The captive portal web browser is almost a complete web browser, but while the captive portal session restricts the response to <code>WWW-authenticate</code> requests. (In intrinsically, the captive portal is a mechanism for authentication in itself)</p> <p>Once you exit from the captive portal session and connect SoftAP IP directly afresh, you can access custom web pages along with prompting a login dialog.</p>"},{"location":"faq.html#uploaded-bin-via-ota-but-the-sketch-stopped-after-reboot","title":"Uploaded BIN via OTA, but the sketch stopped after reboot.","text":"<p>Perhaps the current sketch as the uploader does not match the partition size of the BIN file to be uploaded. For example, if the current sketch (i.e. it performs OTA) is built with a partition table of <code>Default.csv</code> and the new BIN file to be updated is <code>min_spiffs.csv</code>.</p> <p>Also, the file system of the uploader sketch and the uploaded sketch must be the same. If the file system of the uploader sketch is SPIFFS while the uploaded BIN file is LITTLEFS, file system initialization will fail.</p>"},{"location":"faq.html#still-not-stable-with-my-sketch","title":"Still, not stable with my sketch.","text":"<p>If AutoConnect behavior is not stable with your sketch, you can try the following measures.</p>"},{"location":"faq.html#1-change-wifi-channel","title":"1. Change WiFi channel","text":"<p>Both ESP8266 and ESP32 can only work on one channel at any given moment. This will cause your station to lose connectivity on the channel hosting the captive portal. If the channel of the AP which you want to connect is different from the SoftAP channel, the operation of the captive portal will not respond with the screen of the AutoConnect connection attempt remains displayed. In such a case, please try to configure the channel with AutoConnectConfig to match the access point.</p> <pre><code>AutoConnect portal;\nAutoConnectConfig config;\n\nconfig.channel = 3;     // Specifies a channel number that matches the AP\nportal.config(config);  // Apply channel configuration\nportal.begin();         // Start the portal\n</code></pre> <p>Channel selection guide</p> <p>Espressif Systems has released a channel selection guide.</p>"},{"location":"faq.html#2-change-the-arduino-core-version","title":"2. Change the arduino core version","text":"<p>I recommend change installed an arduino core version to the upstream when your sketch is not stable with AutoConnect on each board.</p>"},{"location":"faq.html#with-esp8266-arduino-core","title":"with ESP8266 arduino core","text":"<p>You can select the lwIP variant to contribute for the stable behavior. The lwIP v2 Lower memory option of Arduino IDE for core version 2.4.2 is based on the lwIP-v2. On the other hand, the core version 2.5.0 upstream is based on the lwIP-2.1.2 stable release.</p> <p>You can select the option from Arduino IDE as Tool menu, if you are using ESP8266 core 2.5.0. It can be select <code>lwIP v2 Lower Memory</code> option. (not <code>lwIP v2 Lower Memory (no features)</code>) It is expected to improve response performance and stability.</p>"},{"location":"faq.html#with-esp32-arduino-core","title":"with ESP32 arduino core","text":"<p>The arduino-esp32 is still under development. It is necessary to judge whether the problem cause of the core or AutoConnect. Trace the log with the esp32 core and the AutoConnect debug option enabled for problem diagnosis and please you check the issue of arduino-esp32. The problem that your sketch possesses may already have been solved.</p>"},{"location":"faq.html#3-turn-on-the-debug-log-options","title":"3. Turn on the debug log options","text":"<p>To fully enable for the AutoConnect debug logging options, change the following two files.</p> <p> AutoConnectDefs.h</p> <pre><code>#define AC_DEBUG\n</code></pre> <p> PageBuilder.h 3</p> <pre><code>#define PB_DEBUG\n</code></pre> <p>How to enable the AC_DEBUG, PB_DEBUG</p> <p>See Debug Print section, and one similarly too.</p>"},{"location":"faq.html#4-reports-the-issue-to-autoconnect-github-repository","title":"4. Reports the issue to AutoConnect Github repository","text":"<p>If you can not solve AutoConnect problems please report to Issues. And please make your question comprehensively, not a statement. Include all relevant information to start the problem diagnostics as follows:4</p> <ul> <li> Hardware module</li> <li> Arduino core version Including the upstream commit ID if necessary</li> <li> Operating System which you use</li> <li> Your smartphone OS and version (Especially for Android)</li> <li> Your AP information (IP, channel) if related</li> <li> lwIP variant</li> <li> Problem description</li> <li> If you have a STACK DUMP decoded result with formatted by the code block tag</li> <li> the Sketch code with formatted by the code block tag (Reduce to the reproducible minimum code for the problem)</li> <li> Debug messages output (Including arduino core)</li> </ul> <p>I will make efforts to solve as quickly as possible. But I would like you to know that it is not always possible.</p> <p>Thank you.</p> <ol> <li> <p>In this case, the underlying factor is mainly the bloat of ESP-IDF. This issue is also being discussed by many contributors of the Arduino core development community and efforts are underway to make a solution. Refs: espressif/arduino-esp32/issue#5630 \u21a9</p> </li> <li> <p>This issue has been resolved in ESP8266 core 2.5.0 and later.\u00a0\u21a9</p> </li> <li> <p><code>PageBuilder.h</code> exists in the <code>libraries/PageBuilder/src</code> directory under your sketch folder.\u00a0\u21a9</p> </li> <li> <p>Without this information, the reproducibility of the problem is reduced, making diagnosis and analysis difficult.\u00a0\u21a9</p> </li> </ol>"},{"location":"filesystem.html","title":"Using Filesystem","text":""},{"location":"filesystem.html#selecting-appropriate-filesystem","title":"Selecting appropriate Filesystem","text":"<p>There are two file systems for utilizing the onboard flash on the ESP8266 or the ESP32, SPIFFS and LittleFS. The file system to be applied is determined at the time of the sketch built. AutoConnect will determine as a file system to apply either SPIFFS or LittleFS according to the macro definition in <code>AutoConnectDefs.h</code> and has the following two definitions to include the file system.</p> <pre><code>#define AC_USE_SPIFFS\n#define AC_USE_LITTLEFS\n</code></pre> <p>The <code>AC_USE_SPIFFS</code> and <code>AC_USE_LITTLEFS</code> macros declare which file system to apply. Their definitions are contradictory to each other and you cannot activate both at the same time.</p> <p>Each platform supported by AutoConnect has a default file system, which is LittleFS for ESP8266 and SPIFFS for ESP32. Neither <code>AC_USE_SPIFFS</code> nor <code>AC_USE_LITTLE_FS</code> needs to be explicitly defined as long as you use the default file system. The default file system for each platform is assumed.</p> <p>SPIFFS has deprecated for ESP8266</p> <p>SPIFFS has deprecated on EP8266 core. <code>AC_USE_SPIFFS</code> flag indicates that the migration to LittleFS has not completed for the Sketch with ESP8266. You will get a warning message when you compile a sketch using SPIFFS. Also, LittleFS support on the ESP32 is expected to be in the future beyond Arduino ESP32 core v2. If you want to use the LittleFS library on your ESP32, you must use a third-party source provided externally.</p> <p>The file system intended by the sketch must match the file system applied to AutoConnect. (i.e. it is provided by the definitions of <code>AC_USE_SPIFFS</code> and <code>AC_USE_LITTLEFS</code>) For example, if the sketch includes <code>LittleFS.h</code>, but <code>AC_USE_SPIFFS</code> is defined, the sketch will not be able to sucessfully acces the built file system.</p>"},{"location":"filesystem.html#filesystem-applied-to-pagebuilder-must-match-to-autoconnect","title":"Filesystem applied to PageBuilder must match to AutoConnect","text":"<p>Also, PageBuilder has a definition of file system choices to use, similar to AutoConnect. It is the definition of <code>PB_USE_SPIFFS</code> and <code>PB_USE_LITTLEFS</code> in <code>PageBuilder.h</code> of PageBuilder library source, and its role is the same as these of AutoConnect. </p> <pre><code>#define PB_USE_SPIFFS\n#define PB_USE_LITTLEFS\n</code></pre> <p>Note the version of each library</p> <p>Support for <code>AC_USE_SPIFFS / AC_USE_LITTLEFS</code> and <code>PB_USE_SPIFFS / PB_USE_LITLTEFS</code> is from AutoConnect 1.3.0 and PageBuilder 1.5.0 and later.</p>"},{"location":"filesystem.html#to-determine-the-file-system-to-be-used","title":"To determine the file system to be used","text":"<p>The most direct way is to edit the library source <code>AutoConnectDefs.h</code> directly and uncomment the definition of <code>#define AC_USE_SPIFFS</code> or <code>#define AC_USE_LITTLES</code>. In addition to that editing work, the definitions of <code>PB_USE_SPIFFS</code> and <code>PB_USE_LITTLEFS</code> in <code>PageBuilder.h</code> also need to be changed. Their definitions must match the <code>AC_USE_SPIFFS</code> and <code>AC_USE_LITTLEFS</code> definitions in <code>AutoConnectDefs.h</code>.  <code>PB_USE_SPIFFS</code> enabled and <code>AC_USE_LITTLEFS</code> enabled state is not allowed, and vice-versa.</p> <p>However, this way makes the AutoConnect library inconsistent and may include your unintended file system on a project-by-project basis. By using PlatformIO, you can efficiently select a file system. That way, you can choose any file system for each project without polluting the library source.</p> <p>To apply a different file system for each project without modifying the library source code, add the following <code>build_flags</code> directive to <code>platformio.ini</code> as a project configuration file of each project.</p> <pre><code>[env:esp_wroom_02]\nplatform = espressif8266\nboard = esp_wroom_02\nframework = arduino\nlib_extra_dirs = ~/Documents/Arduino/libraries\nlib_ldf_mode = deep+\nbuild_flags =\n-DAC_USE_SPIFFS\n-DPB_USE_SPIFFS\nupload_speed = 921600\nmonitor_speed = 115200\n</code></pre> <p>The <code>build_flags</code> as build options allows PlatformIO can provide preprocessor macro definitions. <code>-D name</code> for <code>build_flags</code>, which specifies a predefined content, is treated as 1 equal to the <code>#define</code> directive.</p> <p>Library dependency search with PlatformIO</p> <p>If <code>#include &lt;LITTLEFS.h&gt;</code> becomes Not Found with PlatformIO built, try specifying <code>lib_ldf_mode=deep+</code> with <code>platformio.ini</code>. Due to the deep nesting by preprocessor instructions, the include file cannot be detected by the chain mode (nested include search) of PlatformIO's Library Dependency Finder. See also FAQ.</p> <p>LittleFS for ESP8266 with PlatformIO</p> <p>The SPIFFS file system is used by default in order to keep legacy projects compatible. To choose LittleFS as the file system with ESP8266 platform, it should be explicitly specified using <code>board_build.filesystem</code> option in <code>platformio.ini</code> as follows:   <pre><code>[env:esp_wroom_02]\nplatform = espressif8266\nframework = arduino\nboard = esp_wroom_02\nboard_build.filesystem = littlefs\n...\n</code></pre></p>"},{"location":"filesystem.html#practical-situations-where-autoconnect-uses-a-file-system","title":"Practical situations where AutoConnect uses a file system","text":"<p>AutoConnect has the ability to use the file system that is:</p> <ul> <li> <p>Place the custom web page defined in the JSON document in an external file and separate it from the sketch source code. This approach allows you to change the layout design of your custom web page by simply modifying the external file without recompiling the sketch.</p> </li> <li> <p>Use the AutoConnectFile element to upload some parameters that control sketch execution to the file system on the ESP module. You can upload from the browser on the client PC via OTA.</p> </li> </ul> <p>The following is an example of a scenario that embodies the combination of these facilities. The sketch below controls LED that blinks like heartbeat by PWM (Pulse-Width Modulation) from ESP8266. Custom web page contains an AutoConnectFile element that allows you to upload a parameter file to the ESP module from the browser on the client PC. And place the custom web page as a JSON document on the LittleFS of the ESP module.</p>"},{"location":"filesystem.html#screenshot","title":"Screenshot","text":"<p>The sketch UI of this scenario provides as shown by the screenshot below:</p> <p></p> <p>It arranges in a very simple style to focus on how the sketch incorporating AutoConnect will handle the file system. This custom web page is loaded from LittleFS at the beginning of the sketch processing and has already been uploaded to LittleFS on the ESP8266.</p>"},{"location":"filesystem.html#custom-web-page-json-definition","title":"Custom Web page JSON definition","text":"<p>It has a file name as \"<code>custom_pages.json</code>\" and has two pages whose URI are \"<code>/</code>\" and \"<code>/set</code>\". An AutoConnectFile element named \"<code>param</code>\" is placed to upload a file from a client browser that contains the parameters to determine the behavior of this sketch. (ie. LED blinking cycle of the heartbeat)</p> <p>After selecting the parameter file to upload, click the AutoConnectSubmit element named \"<code>set</code>\". This will upload the selected file to LittleF on the ESP8266 module and start processing the sketch-coded \"<code>/set</code>\" page handler.</p> <pre><code>[\n  {\n\"title\": \"Heartbeat\",\n\"uri\": \"/\",\n\"menu\": true,\n\"element\": [\n      {\n\"name\": \"param\",\n\"type\": \"ACFile\",\n\"label\": \"Parameter file:\",\n\"store\": \"fs\"\n      },\n      {\n\"name\": \"set\",\n\"type\": \"ACSubmit\",\n\"value\": \"SET\",\n\"uri\": \"/set\"\n      }\n    ]\n  },\n  {\n\"title\": \"Heartbeat\",\n\"uri\": \"/set\",\n\"menu\": false,\n\"element\": [\n      {\n\"name\": \"param\",\n\"type\": \"ACText\"\n      }\n    ]\n  }\n]\n</code></pre>"},{"location":"filesystem.html#parameter-file","title":"Parameter file","text":"<p>You can make the parameters that determine the heartbeat cycle with the JSON definition using your favorite text editor as follows:</p> <pre><code>{\n\"led\": 16,\n\"freq\": 1000,\n\"range\": 511,\n\"cycle\": 2\n}\n</code></pre> <p>We use PWM to make the LED blinking gently repeat like a heartbeat. In addition, we also need the interval time to blink. We will put these values in the parameter file.</p> <ul> <li>led : Blinking LED assignment pin (Depending on your ESP8266 module)</li> <li>freq : PWM frequency [ms] (milliseconds unit)</li> <li>range : PWM range (511 ~ 1023, 511 ~ 767 is recommended for smooth blinking)</li> <li>cycle : Heartbeat cycle [s] (seconds unit. 4 seconds or less recommended)</li> </ul> <p>Save the text file with these settings as <code>param.json</code> on your PC. You can upload this file to the ESP8266 module using the AutoConnectFile element named <code>param</code> above. When executing a sketch, the settings described in this file will be read by the <code>/set</code> custom web page handler to control the analog output of the ESP8266 module.</p>"},{"location":"filesystem.html#the-sketch","title":"The sketch","text":"<p>Below is the final sketch that allows the LED to blink like a heartbeat according to the settings contained in the two external files <code>custome_pages.json</code> and <code>param.json</code> mentioned above.</p> <pre><code>#include &lt;Arduino.h&gt;\n#include &lt;ESP8266WiFi.h&gt;\n#include &lt;ESP8266WebServer.h&gt;\n#include &lt;LittleFS.h&gt;\n#include &lt;AutoConnect.h&gt;\n#include &lt;ArduinoJson.h&gt;\nAutoConnect portal;\nAutoConnectConfig config;\n\n// File names\nconst char* paramFile = \"param.json\";\nconst char* auxFile = \"custom_pages.json\";\n\n// Parameters for LED PWM control\nunsigned int  led = 0;\nunsigned long freq;\nunsigned long range;\nunsigned int  cycle;\nconst unsigned long reso = 10;\nint duty;\nint increase;\nunsigned long tmCycle;\nunsigned long tmStep;\n\nString onSet(AutoConnectAux&amp; aux, PageArgument&amp; args) {\n  StaticJsonDocument&lt;128&gt; doc;\n\n// Open uploaded parameter and parse parameters with JSON\n  File param = LittleFS.open(paramFile, \"r\");\nif (param) {\n    DeserializationError error = deserializeJson(doc, param);\nif (error) {\n      aux[\"param\"].value = \"JSON de-serialization failed: \" + String(error.c_str());\n    }\nelse {\n// Parsing the parameter JSON was successful.\n// Read the parameters as JSON document from the uploaded parameter file.\n      led = doc[\"led\"];\n      freq = doc[\"freq\"];\n      range = doc[\"range\"];\n      cycle = doc[\"cycle\"];\n\n// Set PWM conditions\n      analogWriteFreq(freq);\n      analogWriteRange(range);\n      increase = ((range / cycle) / reso) / 2;\n      duty = 0;\n      tmCycle = millis();\n      tmStep = tmCycle;\n\n// Echo back uploaded parameters to Custom web page\n      String  result;\n      serializeJson(doc, result);\n      aux[\"param\"].value = result;\n    }\n    param.close();\n  }\nelse\n    aux[\"param\"].value = String(paramFile) + String(\" open error\");\n\nreturn String();\n}\n\nvoid setup() {\n  delay(1000);\n  Serial.begin(115200);\n  Serial.println();\n\n  LittleFS.begin();\n// Load Custom web pages from LittleFS\n  File aux = LittleFS.open(auxFile, \"r\");\nif (aux) {\n// Attach Custom web page and handler\n    portal.load(aux);\n    portal.on(\"/set\", onSet);\n\n// Exclude the HOME item from the menu as the custom web page will\n// be placed in the root path.\n    config.menuItems = 0x00ff &amp; ~(AC_MENUITEM_HOME | AC_MENUITEM_DEVINFO);\n    config.ota = AC_OTA_BUILTIN;  // You can even update this sketch remotely\n    portal.config(config);\n\n// You can close the file once the custom web page has finished loading.\n    aux.close();\n  }\nelse {\n    Serial.print(auxFile);\n    Serial.println(\" open error\");\n  }\n\n  portal.begin();\n}\n\nvoid loop() {\nif (led) {  // The heartbeat begins after the led parameter will set.\nif (millis() - tmStep &gt; abs(increase)) {\n      duty += increase;\nif (duty &lt; 0)\n        duty = 0;\n      analogWrite(led, duty);\n      tmStep = millis();\n    }\nif (millis() - tmCycle &gt; (cycle * 1000) / 2) {\n      increase *= -1;\n      tmCycle = millis();\n    }\n  }\n  portal.handleClient();\n}\n</code></pre> <p>This final sketch consists of four components:</p> <ul> <li> <p>Include appropriate header files: Include the appropriate file system header files to operate the external files of the ESP8266 module by the sketch. For LitteleFS, it is <code>#include &lt;LittleFS.h&gt;</code>. Also, since we wrote the parameter setting file in JSON, we will deserialize it using        ArduinoJson. The header required for the deserialization process is <code>#include &lt;ArduinoJson.h&gt;</code>.</p> </li> <li> <p>setup: In the sketch setup phase, the procedure is similar to other sketches when using AutoConnect. In this case, the following steps are appended to apply the file system.</p> <ul> <li>Start the file system as LittleFS. Then open the custom web page definition file. Upload this file as a LittleFS file on the ESP8266 module in advance.</li> <li>Arduino can handle the opened file as a stream, so register the file stream with AutoConnect using the AutoConnect::load function. This procedure is also detailed in the documentation Loading &amp; saving AutoConnectElements with JSON.</li> </ul> </li> <li> <p>loop: In the loop, the duty is calculated and analog output is performed to the LED pin. Duty is a value for PWM. PWM is a modulation method that can adjust strength of electric power by turning the pulse train on and off at regular intervals and change the on-time width. In this sketch, the LED on-time is dynamically changed and supplied as the PWM duty to achieve the slow blinking like the heartbeat. The loop calculates this dynamic on-time change from the heartbeat cycle time (<code>cycle</code> setting of <code>param.json</code>) and executes analogWrite at the appropriate timing. The <code>freq</code> value in the parameter settings indicates the regular interval of the PWM.</p> <p>Do not use delay in a loop to create time variation for PWM</p> <p>It is a fault often found in careless sketches. An HTTP request is sent to the ESP8266 module each time you interact with the AutoConnect menu from the client browser. The request is properly answered by the AutoConnect::handleClient function. The delay function in the loop obstructs the flow of its processing. Remember that the sketching process will be suspended for the time period you specify by the delay.</p> </li> <li> <p><code>/set</code> custom web page handler: It is named <code>onSet</code> function in above sketch. The <code>onSet</code> handler retrieves PWM settings using ArduinoJson deserialization from the uploaded <code>param.json</code> file. Each fetched setting value is stored in each global variable. The loop function refers to that value to achieve PWM pulse control.</p> </li> </ul>"},{"location":"filesystem.html#adapts-the-sketch-to-the-selected-file-system-in-autoconnect","title":"Adapts the sketch to the selected file system in AutoConnect","text":"<p>AutoConnect determines the appropriate file system instance according to the AC_USE_SPIFFS or AC_USE_LITTLEFS macro definition. This determination is made by the c++ preprocessor when the sketch is built. It then exports a macro definition that identifies the determined file system. Its macro definition allows the sketch to reference a valid file system after including the <code>AutoConnect.h</code> header file.</p> <p>The following two macro definitions, which can be referenced after including the AutoConnect.h header file, help the sketch choose the appropriate file system.</p> <ul> <li>AUTOCONNECT_USE_SPIFFS: AutoConnect uses SPIFFS. The sketch should include <code>SPIFFS.h</code>. Also, the file system instance is <code>SPIFFS</code>.</li> <li>AUTOCONNECT_USE_LITTLEFS: AutoConnect uses LITTLEFS. The sketch should include <code>LittleFS.h</code>. Also, the file system instance is <code>LittleFS</code>.</li> </ul> <p>Combining the c++ preprocessor directives with the two macro definitions above, you can write a common sketch code for both SPIFFS and LittleFS, as shown in the code as follows:</p> <pre><code>#include &lt;AutoConnect.h&gt;\n\n#ifdef AUTOCONNECT_USE_LITTLEFS\n#include &lt;LittleFS.h&gt;\n#if defined(ARDUINO_ARCH_ESP8266)\nFS&amp; FlashFS = LittleFS;\n#elif defined(ARDUINO_ARCH_ESP32)\nfs::LittleFSFS&amp; FlashFS = LittleFS;\n#endif\n#else\n#include &lt;FS.h&gt;\n#include &lt;SPIFFS.h&gt;\nfs::SPIFFSFS&amp; FlashFS = SPIFFS;\n#endif\n\nvoid setup() {\n  ...\n  FlashFS.begin();\n  ...\n}\n</code></pre>"},{"location":"gettingstarted.html","title":"Getting started","text":""},{"location":"gettingstarted.html#lets-do-the-most-simple-sketch","title":"Let's do the most simple sketch","text":"<p>Open the Arduino IDE, write the following sketch and upload it. The feature of this sketch is that the SSID and Password are not coded.</p> <pre><code>#include &lt;ESP8266WiFi.h&gt;          // Replace with WiFi.h for ESP32\n#include &lt;ESP8266WebServer.h&gt;     // Replace with WebServer.h for ESP32\n#include &lt;AutoConnect.h&gt;\n\nESP8266WebServer Server;          // Replace with WebServer for ESP32\nAutoConnect      Portal(Server);\n\nvoid rootPage() {\nchar content[] = \"Hello, world\";\n  Server.send(200, \"text/plain\", content);\n}\n\nvoid setup() {\n  delay(1000);\n  Serial.begin(115200);\n  Serial.println();\n\n  Server.on(\"/\", rootPage);\nif (Portal.begin()) {\n    Serial.println(\"WiFi connected: \" + WiFi.localIP().toString());\n  }\n}\n\nvoid loop() {\n    Portal.handleClient();\n}\n</code></pre> <p>The above code can be applied to ESP8266. To apply to ESP32, replace <code>ESP8266WebServer</code> class with <code>WebServer</code> and include <code>WiFi.h</code> and <code>WebServer.h</code> of arduino-esp32 appropriately.</p>"},{"location":"gettingstarted.html#run-at-first","title":"Run at first","text":"<p>After about 30 seconds, if the ESP8266 cannot connect to nearby Wi-Fi spot, you pull out your smartphone and open Wi-Fi settings from the Settings Apps. You can see the esp8266ap 1 in the list of \"CHOOSE A NETWORK...\". Then tap the esp8266ap and enter password 12345678, a something screen pops up automatically as shown below.</p> <p></p> <p>This is the AutoConnect statistics screen. This screen displays the current status of the established connection, WiFi mode, IP address, free memory size, and etc. Also, the hamburger icon is the control menu of AutoConnect seems at the upper right. By tap the hamburger icon, the control menu appears as the below.</p>"},{"location":"gettingstarted.html#join-to-the-new-access-point","title":"Join to the new access point","text":"<p>Here, tap \"Configure new AP\" to connect the new access point then the SSID configuration screen would be shown. Enter the SSID and Passphrase and tap apply to start connecting the access point.</p> <p></p> <p>Can be configured with static IP</p> <p>Since v1.1.0, Configure new AP menu can configure for WIFI_STA with static IP.</p>"},{"location":"gettingstarted.html#connection-establishment","title":"Connection establishment","text":"<p>After connection established, the current status screen will appear. It is already connected to WLAN with WiFi mode as WIFI_AP_STA and the IP connection status is displayed there including the SSID. Then at this screen, you have two options for the next step.</p> <p>For one, continues execution of the Sketch while keeping this connection. You can access ESP8266 via browser through the established IP address after cancel to \"Log in\" by upper right on the screen. Or, \"RESET\" can be selected. The ESP8266 resets and reboots. After that, immediately before the connection will be restored automatically with WIFI_STA mode.</p> <p></p>"},{"location":"gettingstarted.html#run-for-usually","title":"Run for usually","text":"<p>The IP address of ESP8266 would be displayed on the serial monitor after connection restored. Please access its address from the browser. The \"Hello, world\" page will respond. It's the page that was handled by in the Sketch with \"on\" function of ESP8266WebServer.</p> <p></p> <ol> <li> <p>When applied to ESP32, SSID will appear as esp32ap.\u00a0\u21a9</p> </li> </ol>"},{"location":"howtoembed.html","title":"How to embed","text":""},{"location":"howtoembed.html#embed-the-autoconnect-to-the-sketch","title":"Embed the AutoConnect to the Sketch","text":"<p>Here hold two case examples. Both examples perform the same function. Only how to incorporate the AutoConnect into the Sketch differs. Also included in the sample folder, HandlePortal.ino also shows how to use the PageBuilder library for HTML assemblies.</p>"},{"location":"howtoembed.html#what-does-this-example-do","title":"What does this example do?","text":"<p>Uses the web interface to light the LED connected to the D0 (sometimes called BUILTIN_LED) port of the NodeMCU module like the following animation.</p> <p>Access to the ESP8266 module connected WiFi from the browser then the page contains the current value of the D0 port would be displayed. The page has the buttons to switch the port value. The LED will blink according to the value with clicked by the button. This example is a typical sketch of manipulating ESP8266's GPIO via WLAN.</p> <p></p> <p>Embed AutoConnect library into this sketch. There are few places to be changed. And you can use AutoConnect's captive portal function to establish a connection freely to other WiFi spots.</p>"},{"location":"howtoembed.html#embed-autoconnect","title":"Embed AutoConnect","text":""},{"location":"howtoembed.html#pattern-a","title":"Pattern A.","text":"<p>Bind to ESP8266WebServer, performs handleClient with handleRequest.</p> <p></p> <p>In what situations should the handleRequest be used.</p> <p>It is something needs to be done immediately after the handle client. It is better to call only AutoConnect::handleClient whenever possible.</p>"},{"location":"howtoembed.html#pattern-b","title":"Pattern B.","text":"<p>Declare only AutoConnect, performs handleClient.</p> <p></p>"},{"location":"howtoembed.html#used-with-mqtt-as-a-client-application","title":"Used with MQTT as a client application","text":"<p>The effect of AutoConnect is not only for ESP8266/ESP32 as the web server. It has advantages for something WiFi client as well. For example, AutoConnect is also convenient for publishing MQTT messages from various measurement points. Even if the SSID is different for each measurement point, it is not necessary to modify the Sketch.</p> <p>In this example, it is trying to publish a WiFi signal strength being received ESP8266 through the services on the cloud that can visualize the live data streams for IoT. Using the IoT platform provided by ThingSpeak\u2122, the ESP8266 publishes RSSI values to ThingSpeak MQTT broker channel via the MQTT client library.</p> <p>This example is a good indication of the usefulness of AutoConnect, as RSSI values can typically measure different intensities for each access point. By simply adding a few lines to the Sketch, you do not have to rewrite and upload the Sketch for each access point.</p> <p></p>"},{"location":"howtoembed.html#advance-procedures","title":"Advance procedures","text":"<ul> <li>Arduino Client for MQTT - It's the PubSubClient, install it to Arduino IDE. If you have the latest version already, this step does not need.</li> <li>Create a channel on ThingSpeak.</li> <li>Register the ESP module as an MQTT device to a ThingSpeak channel, allowing it to be published and subscribed to on that channel.</li> <li>Get the Channel API Keys and MQTT device credentials from ThingSpeak, and put its keys to the Sketch.</li> </ul> <p>The ThingSpeak is the open IoT platform. It is capable of sending data privately to the cloud and analyzing, visualizing its data. If you do not have an account of ThingSpeak, you need that account to proceed further. ThingSpeak has the free plan for the account which uses within the scope of this example.1 You can sign up with the ThingSpeak sign-up page.</p> <p>Whether you should do sign-up or not.</p> <p>You are entrusted with the final judgment of account creation for ThingSpeak. Create an account at your own risk.</p>"},{"location":"howtoembed.html#create-a-channel-on-thingspeak","title":"Create a channel on ThingSpeak","text":"<p>Sign in ThingSpeak. Select Channels to show the My Channels, then click New Channel.</p> <p>At the New Channel screen, enter each field as a below. And click Save Channel at the bottom of the screen to save.</p> <ul> <li>Name: <code>ESP8266 Signal Strength</code></li> <li>Description: <code>ESP8266 RSSI publish</code></li> <li>Field1: <code>RSSI</code></li> </ul> <p></p>"},{"location":"howtoembed.html#get-channel-id-and-api-keys","title":"Get Channel ID and API Keys","text":"<p>The channel successfully created, you can see the channel status screen as a below. Channel ID is displayed there.2</p> <p></p> <p>Here, switch the channel status tab to API Keys. The API key required to publish the message is the Write API Key.</p> <p></p> <p>The last key you need is the User API Key and can be confirmed it in the user profile. Pull down Account from the top menu, select My profile. Then you can see the ThingSpeak settings and the User API Key is displayed middle of this screen.</p> <p></p>"},{"location":"howtoembed.html#add-a-new-mqtt-device","title":"Add a new MQTT Device","text":"<p>Since January 2022, the ThingSpeak channel authentication scheme has changed, and the following procedures are for the new authentication. You will need to obtain the credentials of the MQTT device by registering it with the channel you created in the previous step.</p> <p>Once you have defined your ThingSpeak channel, you can define devices: select MQTT from the Devices menu that appears in ThingSpeak's channel information to begin registering devices.</p> <p></p> <p>Give the device a name on the next page that appears after you select the MQTT device. In this example, its device should be the ESP module that the ThingSpeak MQTT channel would identify. You then specify the channel and message type you want to allow for the device. (i.e., the ESP module)</p> <p>Upon successful registration of the MQTT device, Client ID, Username, and Password are issued as credentials for the device. You can retrieve the credentials and save them as JSON. After downloading the credential file, open it with a text editor and check the contents.</p> <p></p>"},{"location":"howtoembed.html#sketch-publishes-messages","title":"Sketch publishes messages","text":"<p>The mqttRSSI.ino sketch in the AutoConnect repository is the complete code for publishing RSSI to the ThingSpeak channel. The sketch comes with an AutoConnectAux custom Web page to flexibly configure channel information created as a ThingSpeak channel.</p> <p></p> <p>Parameters for the ThingSpeak MQTT channels</p> <p>Various settings of the MQTT Setting for the ThingSpeak channels via the above AutoConnectAux are following:</p> <ul> <li>Server: <code>mqtt3.thingspeak.com</code></li> <li>User API Key: Specify the User API Key that can be confirmed with ThingSpeak My Profile page.</li> <li>Channel ID: Specify the channel ID that can be confirmed with ThingSpeak My Channels page.</li> <li>Write API Key: Specify the Write API Key that can be confirmed by following navigate to \"ThingSpeak My Channels &gt; Your Channel Name &gt; API Keys Tab &gt; Write API Key\".</li> <li>Client ID: Specify the client ID from the MQTT Devices page according to the previous step.</li> <li>Username: Specify the user name from the MQTT Devices page according to the previous step.</li> <li>Password: Specify the password from the MQTT Devices page according to the previous step.</li> </ul>"},{"location":"howtoembed.html#publish-messages","title":"Publish messages","text":"<p>After uploading the mqttRSSI.ino and restarting the ESP module, Messages will begin to be issued via the connected WiFi access point. The message will carry the RSSI value of the current WiFi signal strength; changes in signal strength due to RSSI will be displayed on the ThingSpeak Channel Stats page.</p>"},{"location":"howtoembed.html#how-embed-to-your-sketches","title":"How embed to your sketches","text":"<p>For the client sketches, the code required to connect to WiFi is the following four parts only.</p> <ol> <li> <p>#include directive3</p> <p>Include <code>AutoConnect.h</code> header file behind the include of <code>ESP8266WiFi.h</code>.</p> <p></p> </li> <li> <p>Declare AutoConnect</p> <p>The declaration of the AutoConnect variable is not accompanied by ESP8266WebServer.</p> <p></p> </li> <li> <p>Invokes \"begin()\"</p> <p>Call AutoConnect::begin. If you need to assign a static IP address, executes AutoConnectConfig before that. </p> <p></p> </li> <li> <p>Performs \"handleClent()\" in \"loop()\"</p> <p>Invokes AutoConnect::handleClient() at inside <code>loop()</code> to enable the AutoConnect menu.</p> <p></p> </li> </ol> <ol> <li> <p>As of March 21, 2018.\u00a0\u21a9</p> </li> <li> <p>'454951' in the example above, but your channel ID should be different.\u00a0\u21a9</p> </li> <li> <p><code>#include &lt;ESP8266WebServer.h&gt;</code> does not necessary for uses only client.\u00a0\u21a9</p> </li> </ol>"},{"location":"license.html","title":"License","text":"<p>MIT License</p> <p>Copyright \u00a9 2018-2023 Hieromon Ikasamo</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p> <p>Acknowledgments</p> <p>Each of the following libraries used by AutoConnect is under its license:</p> <ul> <li>The Luxbar is licensed under the MIT License. https://github.com/balzss/luxbar</li> <li>ArduinoJson is licensed under the MIT License. https://arduinojson.org/</li> </ul>"},{"location":"lsbegin.html","title":"Inside AutoConnect::begin","text":""},{"location":"lsbegin.html#autoconnectbegin-logic-sequence","title":"AutoConnect::begin logic sequence","text":"<p>The following parameters of AutoConnectConfig affect the behavior and control a logic sequence of AutoConnect::begin function. These parameters are evaluated on a case-by-case basis and may not be valid in all situations. The Sketch must consider the role of these parameters and the conditions under which they will work as intended. You need to understand what happens when using these parameters in combination.</p> <ul> <li>autoReconnect : Attempts re-connect with past SSID by saved credential.</li> <li>autoRise : Controls starting the captive portal.</li> <li>immediateStart : Starts the captive portal immediately, without the 1st-WiFi.begin.</li> <li>portalTimeout : Time out limit for the portal.</li> <li>retainPortal : Keep DNS server functioning for the captive portal.</li> </ul> <p>The following chart shows the AutoConnect::begin logic sequence that contains the control flow with each parameter takes effect.</p> <p></p> <p>For example, AutoConnect::begin will not end without the portalTimeout while the connection not establishes, but WebServer will start to work. Also, the DNS server will start to make a series of the captive portal operation on the client device. The custom web pages now respond correctly by the two internally launched servers, and the Sketch looks like working. But AutoConnect::begin does not end yet. Especially when invoking AutoConnect::begin in the setup(), control flow does not pass to the loop().</p> <p>However, portalTimeout can be used effectively in various scenes in combination with immediateStart. Its combination is useful for implementing Sketches that can work in situations where WiFi is not always available. Namely, Sketch will support a running mode with both offline and online. If AutoConnect staying in the captive portal exceeds the time limit, Sketch can switch a process-mode to offline according to WiFi signal detection. Conversely, it can start a captive portal immediately with intentional control to shift the process-mode to online from offline. Especially, You can activate the process-mode shift manually by trigger via external switches.</p> <p>The retainPortal option allows continuing the captive portal operation even after exiting from AutoConnect::begin. This option allows the use of the automatic portal pop-ups on the smartphone devices etc. even after the ESP module has established a connection with some access point in STA mode. (Excepts blocking a series of portal processes via intentionally accessing a URL outside the scope of /_ac. eg., if you try to communicate with the mqtt server without connecting to the access point, its access will be redirected to /_ac caused by the trap of the captive portal detection)</p> <p>The AutoConnect::begin 3rd parameter</p> <p>Another parameter as the 3rd parameter of AutoConnect::begin related to timeout constrains the connection wait time after WiFi.begin. It is the CONNECTED judgment of the above chart that it has an effect.</p>"},{"location":"menu.html","title":"AutoConnect menu","text":"<p>Luxbar</p> <p>The AutoConnect menu is developed using the LuxBar which is licensed under the MIT License. See the License.</p>"},{"location":"menu.html#where-the-from","title":"Where the from","text":"<p>The following screen will appear as the AutoConnect menu when you access to AutoConnect root URL via <code>http://{localIP}/_ac</code>. (eg. <code>http://172.217.28.1/_ac</code>) It is a top page of AutoConnect which shows the current WiFi connection statistics. To invoke the AutoConnect menu, you can tap  at right on top.</p> <p></p> <p>AutoConnect root URL</p> <p>It is assigned \"/_ac\" located on the local IP address of ESP8266/ESP32 module by default and can be changed with the Sketch. A local IP means Local IP at connection established or SoftAP's IP.</p>"},{"location":"menu.html#right-on-top","title":"Right on top","text":"<p>Currently, AutoConnect supports six menus. Undermost menu as \"HOME\" returns to the home path of its sketch.</p> <ul> <li>Configure new AP: Configure SSID and Password for new access point.</li> <li>Open SSIDs: Opens the past SSID which has been established connection from the flash.</li> <li>Disconnect: Disconnects current connection.</li> <li>Reset...: Rest the ESP8266/ESP32 module.</li> <li>Update: OTA updates. (Optional)</li> <li>HOME: Return to user home page.</li> </ul> <p></p>"},{"location":"menu.html#configure-new-ap","title":"Configure new AP","text":"<p>It scans all available access points in the vicinity and display it further the WiFi signal strength and security indicator as  of the detected AP. Below that, the number of discovered hidden APs will be displayed.  Enter SSID and Passphrase and tap \"Apply\" to start a WiFi connection. </p> <p></p> <p>If you want to configure with static IP, uncheck \"Enable DHCP\". Once the WiFi connection is established, the entered static IP1 configuration will be stored to the credentials in the flash and restored to the station configuration via the Open SSIDs menu.</p> <p></p>"},{"location":"menu.html#open-ssids","title":"Open SSIDs","text":"<p>After WiFi connected, AutoConnect will automatically save the established SSID and password to the flash on the ESP module. Open SSIDs menu reads the saved SSID credentials and lists them as below. Listed items are clickable buttons and can initiate a connection to its access point.</p> <p></p> <p>Also, this menu allows you to interactively delete the stored credentials.  icon will appear next to each SSID in the Open SSIDs menu when the credential removal feature is enabled with AutoConnectConfig::menuItems. Clicking the  on this screen will delete the SSID. This feature is disabled by default.</p> <p></p> <p>Saved credentials data structure has changed</p> <p>A structure of AutoConnect saved credentials has changed in v1.1.0 and was lost backward compatibility. Credentials saved by AutoConnect v1.0.3 (or earlier) will not display properly with AutoConnect v1.1.0. You need to erase the flash of the ESP module using the esptool before the Sketch uploading. <pre><code>esptool -c esp8266 (or esp32) -p [COM_PORT] erase_flash\n</code></pre></p>"},{"location":"menu.html#disconnect","title":"Disconnect","text":"<p>It disconnects ESP8266/ESP32 from the current connection. Also, ESP8266/ESP32 can be automatically reset after WiFi cutting by instructing with the Sketch using the AutoConnect API.</p> <p>After tapping the Disconnect, you will not be able to reach the AutoConnect menu. Once disconnected, you will need to set the SSID again for connecting to the WLAN. </p>"},{"location":"menu.html#reset","title":"Reset...","text":"<p>Resetting the ESP8266/ESP32 module will initiate a reboot. When the module restarting, the esp8266ap or esp32ap access point will disappear from the WLAN and the ESP8266/ESP32 module will begin to reconnect a previous access point with WIFI_STA mode.</p> <p></p> <p>Not every ESP8266 module will be rebooted normally</p> <p>The Reset menu is using the ESP.reset() function for ESP8266. This is an almost hardware reset. In order to resume the Sketch normally, the state of GPIO0 is important. Since this depends on the circuit implementation for each module, not every module will be rebooted normally. See also FAQ.</p>"},{"location":"menu.html#custom-menu-items","title":"Custom menu items","text":"<p>If the Sketch has custom Web pages, the AutoConnect menu lines them up with the AutoConnect's items. Details for Custom Web pages in AutoConnect menu.</p>"},{"location":"menu.html#update","title":"Update","text":"<p>If you specify AutoConnectConfig::ota to import the OTA update feature into Sketch, an item will appear in the menu list as Update.</p> <p>The Update menu item will appear only AutoConnectOTA enabled</p> <p>The Update item is displayed automatically in the menu only when AutoConnectConfig::ota is specified with AC_OTA_BUILTIN or AutoConnectUpdate is attached.</p>"},{"location":"menu.html#home","title":"HOME","text":"<p>A HOME item at the bottom of the menu list is a link to the home path, and the default URI is <code>/</code> which is defined by <code>AUTOCONNECT_HOMEURI</code> in AutoConnectDefs.h header file.</p> <pre><code>#define AUTOCONNECT_HOMEURI     \"/\"\n</code></pre> <p>Also, you can change the HOME path using the AutoConnect API. The AutoConnect::home function sets the URI as a link of the HOME item in the AutoConnect menu.</p>"},{"location":"menu.html#applying-the-active-menu-items","title":"Applying the active menu items","text":"<p>Each of the above menu items can be configured with a Sketch. AutoConnectConfig::menuItems specifies the menu items that will be enabled at runtime. You can also adjust available menu items using AutoConnect::enableMenu and AutoConnect::disableMenu function. It is an alternative to AutoConnectConfig::menuItems and provides a shortcut to avoid using AutoConnectConfig. For example, by disabling the Configure new AP and Disconnect item, you can prevent the configuration for unknown access points.</p> <pre><code>AutoConnect portal;\nAutoConnectConfig config;\n\nvoid setup() {\n  config.menuItems = AC_MENUITEM_OPENSSIDS | AC_MENUITEM_RESET | AC_MENUITEM_HOME;\n  portal.config(config);\n}\n</code></pre> <p>The next is another way to achieve the same effect.</p> <pre><code>AutoConnect portal;\n\nvoid setup() {\n  portal.disableMenu(AC_MENUITEM_CONFIGNEW | AC_MENUITEM_DISCONNECT);\n  portal.config(config);\n}\n</code></pre> <p>The result of executing the above Sketch is as below:</p> <p></p> <p>Details for AutoConnectConfig::menuItems.</p>"},{"location":"menu.html#attaching-to-autoconnect-menu","title":"Attaching to AutoConnect menu","text":"<p>The AutoConnect menu can contain your sketch's web pages as extra items as a custom. It works for HTML pages implemented by the ESP8266WebServer::on handler or the WebServer::on handler for ESP32. That is, you can make them invoke the legacy web pages from the AutoConnect menu. The below screen-shot is the result of adding an example sketch for the ESP8266WebServer library known as FSBrowser to the AutoConnect menu item. It can add Edit and List items with little modification to the legacy sketch code.</p> <p></p> <p>AutoConnect allows capturing the extra pages handled with ESP8266WebServer or WebServer's legacy into the AutoConnect menu. See Section Advanced Usage for detailed instructions on how to add the extra pages into its menu.</p> <ol> <li> <p>AutoConnect does not check the syntax and validity of the entered IP address. If the entered static IPs are incorrect, it cannot connect to the access point.\u00a0\u21a9</p> </li> </ol>"},{"location":"menuize.html","title":"Attach the menus","text":""},{"location":"menuize.html#the-feature-of-menu-attaching-using-autoconnect","title":"The feature of menu attaching using AutoConnect","text":"<p>In this section, it presents numerous ways to customize the AutoConnect menu with your Sketch. AutoConnect dynamically materializes menu items at the Sketch run time  with joined AutoConnectAux as a sourced configuration. Typically, it has AutoConnectElements for page rendering in its composition but can configure a Web page as a menu item without having AutoConnectElements. In other words, the AutoConnect Menu component allows you to easily embed a navigation menu with WiFi connection expansion in your Sketch, which has legacy pages for ESP8266WebServer or WebServer of ESP32.</p>"},{"location":"menuize.html#the-basic-mechanism-for-menu-generation","title":"The basic mechanism for menu generation","text":"<p>Sketch can equip the AutoConnect menu by using three patterns according to the appropriate usage of the AutoConnect API.</p> Basic menu It is the most basic menu for a WiFi connection only. Sketch can automatically display it using the typical calling sequence of the AutoConnect API with AutoConnect::begin and AutoConnect::handleClient. Extra menu with custom Web pages which is consisted by AutoConnectElements It is an extended menu that appears when the Sketch consists of the custom Web pages with AutoConnectAux and AutoConnectElements. Refer to section Custom Web pages section. Extra menu which contains legacy pages It provides an item for including a legacy page in the AutoConnect menu that natively uses the page request handler attached by the ESP8266WebServer::on function. (Similarly, WebServer::on for ESP32) <p>The mechanism by which AutoConnect dynamically generates the menu is simple. The member variables title and uri of AutoConnectAux will be transferred into &lt;li&gt; HTML tag as they are. Then all &lt;li&gt; elements are included in the form that makes up the menu. Therefore, the Sketch can register the legacy web pages to the menu by simply declaring the title and URI with AutoConnectAux and binding it to AutoConnect.</p>"},{"location":"menuize.html#place-the-item-for-the-legacy-sketches-on-the-menu","title":"Place the item for the legacy sketches on the menu","text":"<p>To implement this with your sketch, use only the AutoConnectAux constructed with the title and URI of that page. AutoConnectElements is not required.</p> <p>The AutoConnect library package contains an example sketch for ESP8266WebServer known as FSBrowser. Its example is a sample implementation that supports AutoConnect without changing the structure of the original FSBrowser and has the menu item for Edit and List.</p> <p></p>"},{"location":"menuize.html#slightly-changes-to-adapt-fsbrowser-to-autoconnect-menu","title":"Slightly changes to adapt FSBrowser to AutoConnect menu","text":"<p>The changes I made to adapt the FSBrowser to the AutoConnect menu are slight as follows:</p> <ol> <li>Add AutoConnect declaration.</li> <li>Add AutoConnectConfig declaration to replace the menu title to <code>FSBRowser</code>.</li> <li>Set the menu title using AutoConnectConfig::title.</li> <li>Replace the destination of the not found handler (404 handler) from ESP8266WebServer to AutoConnect. 1IMPORTANT</li> <li>Add AutoConnectAux using AutoConnect::append and combine an item for Edit.</li> <li>Add AutoConnectAux using AutoConnect::append and combine an item for List.</li> <li>Establish a WiFi connection using AutoConnect::begin and execute AutoConnect::handleClient in the loop, as in the case of handling the basic menu.</li> </ol>"},{"location":"menuize.html#fsbrowser-with-embedded-autoconnect","title":"FSBrowser with embedded AutoConnect","text":"<p>Modification for FSBrowser as follows: (Excerpt of the sketch code)</p> <p>... and embeds a hyperlink with an icon in the bottom of the body section of index.htm contained in the data folder to jump to the AutoConnect menu.</p> <pre><code>&lt;p style=\"padding-top:15px;text-align:center\"&gt;\n  &lt;a href=\"/_ac\"&gt;&lt;img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAC2klEQVRIS61VvWsUQRSfmU2pon9BUIkQUaKFaCBKgooSb2d3NSSFKbQR/KrEIiIKBiGF2CgRxEpjQNHs7mwOUcghwUQ7g58IsbGxEBWsb2f8zR177s3t3S2cA8ftzPu993vzvoaSnMu2vRKlaqgKp74Q/tE8qjQPyHGcrUrRjwlWShmDbFMURd/a6TcQwNiYUmpFCPElUebcuQ2vz6aNATMVReHEPwzfSSntDcNwNo2rI+DcvQzhpAbA40VKyV0p1Q9snzBG1qYVcYufXV1sREraDcxpyHdXgkfpRBj6Uwm2RsC5dxxmZ9pdOY9cKTISRcHTCmGiUCh4fYyplTwG2mAUbtMTBMHXOgK9QfyXEZr+TkgQ1oUwDA40hEgfIAfj+HuQRaBzAs9eKyUZ5Htx+T3ZODKG8DzOJMANhmGomJVMXPll+hx9UUAlzZrJJ4QNCDG3VEfguu7mcpmcB/gkBOtShhQhchAlu5jlLUgc9ENgyP5gf9+y6LTv+58p5zySkgwzLNOIGc8sEoT1Lc53NMlbCQQuvMxeCME1NNPVVkmH/i3IzzXDtCSA0qQQwZWOCJDY50jsQRjJmkslEOxvTcDRO6zPxOh5xZglKkYLhWM9jMVnkIsTyMT6NBj7IbOCEjm6HxNVVTo2WXqEWJZ1T8rytB6GxizyDkPhWVpBqfiXUtbo/HywYJSpA9kMamNNPZ71R9Hcm+TMHHZNGw3EuraXEUldbfvw25UdOjqOt+JhMwJd7+jSTpZaEiIcaCDwPK83jtWnTkwnunFMtxeL/ge9r4XItt1RNNaj/0GAcV2bR3U5sG3nEh6M61US+Qrfd9Bs31GGulI2GOS/8dgcQZV1w+ApjIxB7TDwF9GcNzJzoA+rD0/8HvPnXQJCt2qFCwbBTfRI7UyXumWVt+HJ9NO4XI++bdsb0YyrqXmlh+AWOLHaLqS5CLQR5EggR3YlcVS9gKeH2hnX8r8Kmi1CAsl36QAAAABJRU5ErkJggg==\" border=\"0\" title=\"AutoConnect menu\" alt=\"AutoConnect menu\"/&gt;&lt;/a&gt;\n&lt;/p&gt;\n</code></pre> <ol> <li> <p>Missing this step, AutoConnect cannot handle the menu. Refs: 404 handler \u21a9</p> </li> </ol>"},{"location":"otabrowser.html","title":"OTA via Web Browser","text":""},{"location":"otabrowser.html#updates-with-the-web-browserupdated-wv115","title":"Updates with the Web Browser\u00a0UPDATED w/v1.1.5","text":"<p>AutoConnect features a built-in OTA function to update ESP module firmware. You can easily make the Sketch that equips OTA and able to operate with the AutoConnect menu. As the AutoConnectOTA class, which is compliant with OTA updates using a web browser as described in the ESP8266 Arduino Core documentation.</p> <p>You will be able to import the AutoConnectOTA class into your sketch just by specifying AutoConnectConfig::ota. By incorporating the AutoConnectOTA class into your Sketch, you can have an OTA updating feature which able to updating binary sketch from the AutoConnect menu.</p> <p></p> <p>The AutoConnectOTA feature is implemented based on the Updater class of the ESP8266 arduino core library. Its Updater class is also supported by the ESP32 Arduino core, so you can commonly import AutoConnectOTA into the Sketch without being aware of the differences between ESP8266 and ESP32 modules.</p> <p></p> <p>Limitation of AutoConnectOTA with authentication</p> <p>AutoConnectOTA does not support authentication in v1.1.5 yet. It is planned for inclusion in AutoConnect v1.2.0, which will support HTTP authentication.</p>"},{"location":"otabrowser.html#how-to-embed-autoconnectota-in-your-sketch","title":"How to embed AutoConnectOTA in your sketch","text":"<p>To embed the AutoConnectOTA class into your sketch, basically follow these steps:</p> <ol> <li>Include <code>ESP8266WiFi.h</code>, <code>ESP8266WebServer.h</code> and <code>AutoConnect.h</code> as usual.1</li> <li>Declare an ESP8266WebServer object. It's optional. (as WebServer for ESP32)</li> <li>Declare an AutoConnect object,  with an argument as ESP8266WebServer if separate the declarations.</li> <li>Declare an AutoConnectConfig object.</li> <li>Declare an AutoConnectAux object for your sketch own if needed.</li> <li>Perform the following procedure steps in the <code>setup()</code> function:<ol> <li>Set AutoConnectConfig::ota to AC_OTA_BUILTIN and configure AutoConnect.</li> <li>Load the AutoConnectAux pages declared in step #4 for your application.</li> <li>Join these pages to AutoConnect.</li> <li>Invokes AutoConnect::begin function.</li> </ol> </li> <li>Invokes AutoConnect::handleClient function in the <code>loop()</code>.</li> </ol> <pre><code>#include &lt;ESP8266WiFi.h&gt;            // Step #1\n#include &lt;ESP8266WebServer.h&gt;       // Step #1\n#include &lt;AutoConnect.h&gt;            // Step #1\n\nESP8266WebServer  server;           // Step #2\nAutoConnect       portal(server);   // Step #3\nAutoConnectConfig config;           // Step #4\nAutoConnectAux    hello;            // Step #5\n\nstatic const char HELLO_PAGE[] PROGMEM = R\"(\n{ \"title\": \"Hello world\", \"uri\": \"/\", \"menu\": true, \"element\": [\n    { \"name\": \"caption\", \"type\": \"ACText\", \"value\": \"&lt;h2&gt;Hello, world&lt;/h2&gt;\",  \"style\": \"text-align:center;color:#2f4f4f;padding:10px;\" },\n    { \"name\": \"content\", \"type\": \"ACText\", \"value\": \"In this page, place the custom web page handled by the Sketch application.\" } ]\n}\n)\";                                 // Step #5\n\nvoid setup() {\n  config.ota = AC_OTA_BUILTIN;      // Step #6.a\n  portal.config(config);            // Step #6.a\n  hello.load(HELLO_PAGE);           // Step #6.b\n  portal.join({ hello });           // Step #6.c\n  portal.begin();                   // Step #6.d\n}\n\nvoid loop() {\n  portal.handleClient();            // Step #7\n}\n</code></pre> <p>How LED ticking during updates</p> <p>AutoConnectOTA applies LED ticking during updates automatically. The destination LED port and ticker drive depends on AutoConnectConfig::tickerPort and AutoConnectConfig::tickerOn specifying.</p> <p>IMPORTANT The AutoConnectOTA activates the ticker constantly regardless of the AutoConnectConfig::ticker value. If you want to stop the ticker output to GPIO during updates, give <code>0xff</code> to AutoConnectConfig::tickerPort.</p>"},{"location":"otabrowser.html#autoconnectota-allocation-uri","title":"AutoConnectOTA allocation URI","text":"<p>AutoConnectOTA has implemented using AutoConnectAUX. So it occupies two URIs by default. An update operation page is assigned to AUTOCONNECT_URI_UPDATE and the binary file uploader for the update is assigned to AUTOCONNECT_URI_UPDATE_ACT. These symbols are defined in the <code>AutoConnectDefs.h</code> header file as follows:</p> <pre><code>#define AUTOCONNECT_URI             \"/_ac\"\n#define AUTOCONNECT_URI_UPDATE      AUTOCONNECT_URI \"/update\"\n#define AUTOCONNECT_URI_UPDATE_ACT  AUTOCONNECT_URI \"/update_act\"\n</code></pre> <p>Therefore, the normal Sketch that imports AutoConnectOTA while keeping the default, you cannot use the two URIs <code>/_ac/update</code> and <code>/_ac/update_act</code> for your specific. If you want to use the URIs for any purpose other than AutoConnectOTA, you need to override the <code>AutoConnectDefs.h</code> definition at compile time. It can be overwritten by giving the build flags for platformio.ini as follows with the PlatformIO environment for example.</p> <pre><code>build_flags = -DAUTOCONNECT_URI_UPDATE='\"/YOURURI\"'\n-DAUTOCONNECT_URI_UPDATE_ACT='\"/YOURURIACT\"'\n</code></pre>"},{"location":"otabrowser.html#timing-of-autoconnectota-instantiation","title":"Timing of AutoConnectOTA instantiation","text":"<p>It will be born during AutoConnect::handleClient process. AutoConnect will evaluate the enabled state of AutoConnectConfig::ota each time the handleClient is executed, and if OTA is enabled then it creates an AutoConnectAux internally and assigns it to the update page. At this time, AutoConnectOTA is also instantiated together. The generated AUX page containing AutoConnectOTA is bound to AutoConnect inside the AutoConnect::handleClient process.</p> <p>If you want to attach AutoConnectOTA dynamically with an external trigger, you can sketch like this: This sketch imports the OTA update feature with an external switch assigned to the GPIO pin. While the trigger not occurs, AutoConnectOTA will not be imported into Sketch and will not appear on the menu list.</p> <pre><code>#include &lt;ESP8266WiFi.h&gt;\n#include &lt;ESP8266WebServer.h&gt;\n#include &lt;AutoConnect.h&gt;\n\n#define TRIGGER 4   // pin assigned to external trigger switch\n\nAutoConnect portal;\nAutoConnectConfig config;\n\nvoid setup() {\n  pinMode(TRIGGER, INPUT);\n  portal.begin();\n}\n\nvoid loop() {\nif (digitalRead(TRIGGER) == HIGH) {\n    config.ota = AC_OTA_BUILTIN;\n    portal.config(config);\n  }\n  portal.handleClient();\n}\n</code></pre> <p>AutoConnectOTA cannot detach dynamically</p> <p>Once imported, AutoConnectOTA cannot be removed from the Sketch. It can be only excluded from the menu by overriding AutoConnectConfig::menuItems. In this case, the AutoConnectOTA instance remains as a residue.</p>"},{"location":"otabrowser.html#authentication-with-autoconnectota","title":"Authentication with AutoConnectOTA","text":"<p>HTTP authentication of AutoConnect is also effective for OTA. Since the implementation of AutoConnectOTA is based on AutoConnectAux, the AutoConnectConfig::auth setting is valid for AutoConnectOTA as well. Also, it allows you to make authentication only on the OTA page while various custom Web pages coexist.</p> <p>The <code>AC_AUTH_BASIC</code> or <code>AC_AUTH_DIGEST</code> setting to the <code>AutoConnectConfig::auth</code> enables HTTP authentication. If it is in combination with AC_AUTHSCOPE_PARTIAL specified <code>AutoConnectConfig::authScope</code> setting, only an OTA page will be authenticated, excluding other custom Web pages that co-exist.</p> <pre><code>AutoConnect portal;\nAutoConnectConfig config;\nAutoConnectAux aux(\"/aux\", \"AUX\");\n\nvoid setup() {\n// Join some custom web page\n  portal.join(aux);\n\n// Add OTA into the Sketch\n  config.ota = AC_OTA_BUILTIN;\n// Enable authentication on OTA page only\n  config.auth = AC_AUTH_DIGEST;\n  config.authScope = AC_AUTHSCOPE_PARTIAL;\n// Configure other settings\n  ...\n\n// Apply configuration settings\n  portal.config(config);\n  portal.begin();\n}\n</code></pre>"},{"location":"otabrowser.html#how-to-make-the-binary-sketch","title":"How to make the binary sketch","text":"<p>Binary sketch files for updating can be retrieved using the Arduino IDE. Open the Sketch menu and select the Export compiled Binary, then starts compilation.</p> <p></p> <p>When the compilation is complete, a binary sketch will save with the extension <code>.bin</code> in the same folder as the Sketch.</p>"},{"location":"otabrowser.html#select-a-partition-scheme-to-enable-ota-wesp32","title":"Select a partition scheme to enable OTA w/ESP32","text":"<p>To enable OTA on the ESP32, you need to build a sketch with a partition scheme that has reserved a binary sketch space for OTA. The ESP32 Arduino core comes with a variety of pre-configured partition schemes that can be selected from the Tools menu in the Arduino IDE.</p> <p></p> <p>In most cases, this is simply a matter of selecting a built-in partition scheme with a reserved OTA area from the Tools menu in the Arduino IDE. However, Of the various ESP32-based modules, only a few have many partition schemes pre-configured. If you cannot find a partition scheme with reserved OTA space for your ESP32 module, you will need to modify <code>boards.txt</code> as the board configuration file included in the ESP32Arduino core distribution. The WebCamServer.ino example in the AutoConnect library shows the changes to boards.txt for esp32cam. But this modification is not recommended as it can inadvertently destroy the board configuration and will be overwritten and restored by the Arduino core version upstreams.</p> <p>Another way to choose a partition scheme is to use PlatformIO for your build system. You can easily select the reserved partition scheme for the OTA area using PlatformIO. When using PlatformIO, you can select a partition scheme with OTA reserved space by simply writing the following line in the <code>platformio.ini</code> file.</p> <pre><code>board_build.partitions = min_spiffs.csv\n</code></pre>"},{"location":"otabrowser.html#ota-updates-wbrowser-without-using-autoconnectota","title":"OTA updates w/browser without using AutoConnectOTA","text":"<p>The legacy OTA method based on ESP8266HTTPUpdateServer without AutoConnectOTA is still valid. To embed the ESP8266HTTPUpdateServer class with AutoConnect into your sketch, basically follow these steps:</p> <ol> <li>Include <code>ESP8266HTTPUpdateServer.h</code>, also <code>WiFiClient.h</code>, in addition to the usual directives as <code>ESP8266WebServer.h</code> and <code>AutoConnect.h</code>.2</li> <li>Declare an ESP8266WebServer object. (In ESP32, as WebServer)</li> <li>Declare an ESP8266HTTPUpdateServer object.</li> <li>Declare an AutoConnect object with an ESP8266WebServer object as an argument.</li> <li>Declare an AutoConnectAux object for the update operation page.</li> <li>Assign <code>/update</code> to the URI of the update dialog page.</li> <li>Assign any title as the AutoConnect menu for the update dialog page.</li> <li>Declare additional AutoConnectAux pages for your application intention if needed.</li> <li>Perform the following procedure steps in the <code>setup()</code> function:<ol> <li>Invokes <code>ESP8288HTTPUpdateServer::setup</code> function, specifies the USERNAME and the PASSWORD as needed.</li> <li>Load the AutoConnectAux pages declared in step #8 for your application. (Except the update dialog page)</li> <li>Join these pages to AutoConnect along with the update dialog page declared in step #5.</li> <li>Invokes AutoConnect::begin function.</li> </ol> </li> <li>Invokes AutoConnect::handleClient function in the <code>loop()</code>. </li> </ol> <pre><code>#include &lt;ESP8266WiFi.h&gt;\n#include &lt;ESP8266WebServer.h&gt;\n#include &lt;ESP8266HTTPUpdateServer.h&gt;    // Step #1\n#include &lt;WiFiClient.h&gt;                 // Step #1\n#include &lt;AutoConnect.h&gt;\n\nstatic const char HELLO_PAGE[] PROGMEM = R\"(\n{ \"title\": \"Hello world\", \"uri\": \"/\", \"menu\": true, \"element\": [\n    { \"name\": \"caption\", \"type\": \"ACText\", \"value\": \"&lt;h2&gt;Hello, world&lt;/h2&gt;\",  \"style\": \"text-align:center;color:#2f4f4f;padding:10px;\" },\n    { \"name\": \"content\", \"type\": \"ACText\", \"value\": \"In this page, place the custom web page handled by the Sketch application.\" } ]\n}\n)\";\n\nESP8266WebServer httpServer;                // Step #2\nESP8266HTTPUpdateServer httpUpdate;         // Step #3\nAutoConnect portal(httpServer);             // Step #4\nAutoConnectAux update(\"/update\", \"UPDATE\"); // Step #5, #6, #7\nAutoConnectAux hello;                       // Step #8\n\nvoid setup() {\n  httpUpdate.setup(&amp;httpServer, \"USERNAME\", \"PASSWORD\"); // Step #9.a\n  hello.load(HELLO_PAGE);                   // Step #9.b\n  portal.join({ hello, update });           // Step #9.c\n  portal.begin();                           // Step #9.d\n}\n\nvoid loop() {\n  portal.handleClient();                    // Step #10\n}\n</code></pre>"},{"location":"otabrowser.html#regular-file-uploading-using-autoconnectotaenhanced-wv120","title":"Regular file uploading using AutoConnectOTA\u00a0ENHANCED w/v1.2.0","text":"<p>The built-in OTA update feature can update the firmware as well as upload regular files placed in the file system on the ESP module. It allows a regular file is uploaded via OTA using the Update of AutoConnect menu without adding a particular custom Web page that contains AutoConnectFile. This utilization is useful for the operation of transferring the JSON document of the custom web page definition, the external parameter file of your sketch, and so on into the target ESP module via OTA.</p> <p>The built-in OTA update feature determines where to save the uploaded file according to the filename pattern. By default, a filename with ends a <code>.bin</code> extension is subject to firmware updates. A file that has another extensions will be saved as a regular to LittleFS (or SPIFFS) in the flash.</p> <p>The filename extension that should be treated as the firmware is defined as the <code>AUTOCONNECT_UPLOAD_ASFIRMWARE</code> macro in AutoConnectDefs.h header file of the library source code. When dealing with another extensions for the updating file as firmware change this macro definition.</p> <pre><code>#define AUTOCONNECT_UPLOAD_ASFIRMWARE \".bin\"\n</code></pre> <p>Specify with the PlatformIO</p> <p><code>AUTOCONNECT_UPLOAD_ASFIRMWARE</code> pattern will be embedded into the binary sketch is determined at compile time. The PlatformIO build system allows you to change the pattern of the file extension for each project without modifying the library source code.</p> <pre><code>build_flags=-DAUTOCONNECT_UPLOAD_ASFIRMWARE='\".bin\"'\n</code></pre> <p>Use a regular expression to specify the file extension</p> <p>By default, you can specify only one file extension to be treated as firmware in OTA updates. However, you can specify the file extension as a regular expression, but it consumes a lot of memory.</p> <p>If the file extension pattern contains a regular expression, you need to enable the flag of <code>AUTOCONNECT_UPLOAD_ASFIRMWARE_USE_REGEXP</code> in <code>AutoConnectDefs.h</code>. Also, the <code>AUTOCONNECT_UPLOAD_ASFIRMWARE</code> definition as a regular expression is treated as a replacement string for the #define directive for C++ preprocessor, so the backslash must be escaped.</p>"},{"location":"otabrowser.html#display-an-extra-string-on-the-update-screenenhanced-wv130","title":"Display an extra string on the update screen\u00a0ENHANCED w/v1.3.0","text":"<p>You can add an extra string to the OTA update screen by the sketch. If an extra string is specified, it will be displayed on the right side of \"Updating firmware\" caption. </p> <p></p> <p>The screenshot above shows an example of adding the current version of the sketch to the OTA caption.</p> <p>To display in the add an extra caption to the OTA update screen, sets the AutoConnectConfig::otaExtraCaption by your sketch. A type of the extra caption type to set in AutoConnectConfig::otaExtraCaption is the <code>const char pointer</code>. So, its string must remain in the memory area for the duration of OTA. (This string is not copied to the AutoConnectOTA class and expiration must be guaranteed by your sketch)</p> <pre><code>#define FIRMWARE_VERSION  \"1.1.12-dev\"\n...\n#include &lt;AutoConnect.h&gt;\n...\nconst char* fw_ver = FIRMWARE_VERSION;\nAutoConnect portal;\nAutoConnectConfig config;\n\nvoid setup() {\n  config.ota = AC_OTA_BUILTIN;\n  config.otaExtraCaption = fw_ver;\n  portal.config(config);\n  portal.begin();\n}\n\nvoid loop() {\n  portal.handleClient();\n}\n</code></pre> <p>Common mistakes about variable expiration</p> <p>Local variables are valid only within the function. The following code seems to work at first glance. But practically, <code>*fw_ver</code> is released at the end of the function. AutoConnectConfig::otaExtraCaption holds only a pointer to the extra caption string.</p> <pre><code>#define FIRMWARE_VERSION  \"1.1.12-dev\"\n...\n#include &lt;AutoConnect.h&gt;\n...\nAutoConnect portal;\nAutoConnectConfig config;\n\nvoid setupConfig() {\nconst char* fw_ver = FIRMWARE_VERSION;\n  config.ota = AC_OTA_BUILTIN;\n  config.otaExtraCaption = fw_ver;  // This code doesn't work as intended.\n  portal.config(config);\n}\n\nvoid setup() {\n  setupConfig();\n  portal.begin();\n}\n\nvoid loop() {\n  portal.handleClient();\n}\n</code></pre>"},{"location":"otabrowser.html#receive-the-autoconnectota-status-changeenhanced-wv130","title":"Receive the AutoConnectOTA status change\u00a0ENHANCED w/v1.3.0","text":"<p>You can capture the change in the state of the OTA by registering the exit routine to AutoConnect. The exit routine for notifying the state change of AutoConnectOTA can execute the user's sketch function during specific stages of OTA or on an error. Also, these exit routines have the same interface as the similar exit functions included in the Arduino core.</p> <p>The following functions register the function in your sketch with AutoConnect to notify OTA state changes.</p> <ul> <li>AutoConnect::onOTAStart : Register the on-start exit routine that is called only once when the OTA has been started.</li> <li>AutoConnect::onOTAProgress : Register the exit routine that is called during the OTA progress.</li> <li>AutoConnect::onOTAEnd : Register the on-end exit routine that is called only once when the OTA is finished.</li> <li>AutoConnect::onOTAError : Register the exit routine that is called when some error occurred.</li> </ul> <pre><code>#include &lt;ESP8266WiFi.h&gt;\n#include &lt;ESP8266WebServer.h&gt;\n#include &lt;AutoConnect.h&gt;\n\nAutoConnect portal;\nAutoConnectConfig config;\n\nvoid OTAStart() {\n  Serial.println(\"Start OTA updating\");\n}\n\nvoid OTAEnd() {\n  Serial.println(\"\\nEnd\");\n}\nvoid OTAProgress(unsigned int amount, unsigned int size) {\n  Serial.printf(\"Progress: %u(%u)\\r\", amount, size);\n}\n\nvoid OTAError(uint8_t error) {\n  Serial.printf(\"Error[%u]: \", error);\n}\n\nvoid setup() {\n  delay(1000);\n  Serial.begin(115200);\n  Serial.println();\n\n  config.ota = AC_OTA_BUILTIN;\n  portal.config(config);\n  portal.onOTAStart(OTAStart);\n  portal.onOTAEnd(OTAEnd);\n  portal.onOTAProgress(OTAProgress);\n  portal.onOTAError(OTAError);\n  portal.begin();\n}\n\nvoid loop() {\n  portal.handleClient();\n}\n</code></pre> <ol> <li> <p>For ESP32, change the following items:</p> <ul> <li>Change the include directives appropriately for the ESP32 environment.</li> <li>Change ESP8266WebServer to WebServer.</li> </ul> <p>\u21a9</p> </li> <li> <p>The AutoConnect library provides an implementation of the HTTPUpdateServer class that ported from ESP8266HTTPUpdateServer class for ESP32 intention. It is contained the WebUpdate under the examples folder.\u00a0\u21a9</p> </li> </ol>"},{"location":"otaserver.html","title":"OTA using Update Server","text":""},{"location":"otaserver.html#updates-with-the-update-server","title":"Updates with the update server","text":"<p>Since the v1.0.0 release, AutoConnect provides new feature for updating sketch firmware of ESP8266 or ESP32 modules via OTA using the AutoConnectUpdate class that is an implementation of the Sketch binary update by the HTTP server mentioned in the OTA update of the ESP8266 Arduino Core documentation, which inherits from the ESP8266HTTPUpdate class (as HTTPUpdate class in the case of ESP32). It acts as a client agent for a series of update operations.</p> <p>This method allows you to remotely update the ESP module's firmware beyond the network segments from the update server, as long as you can ensure proper routing and forwarding.</p> <p></p> <p>If you choose this update method, you need to prepare the server process as a variant of the HTTP server that supplies the binary sketch files to the updating client agent. Its server requires to be able to handle the HTTP headers extended by ESP8266HTTPUpdate class as described in the ESP8266 Arduino Core documentation. There are various implementations of the update server that provide binary sketch files. For example, the ESP8266 Arduino Core documentation suggests an advanced updater php script that can be fully communicated with the client agent using the ESP8266HTTPUpdate class.  That is, the update server for AutoConnect must work with the client agent, and its implementation should make the handshake well with the AutoConnectUpdate class which wraps an ESP8266HTTPUpdate class. The AutoConnect library provides an update server script implemented in Python that can combine with the AutoConnectUpdate class.</p>"},{"location":"otaserver.html#how-to-embed-autoconnectupdate-to-your-sketch","title":"How to embed AutoConnectUpdate to your sketch","text":"<p>To embed the AutoConnectUpdate class into your sketch, basically follow these steps:</p> <ol> <li>Declare an ESP8266WebServer object. (In ESP32, as WebServer)</li> <li>Declare an AutoConnect object with an ESP8266WebServer object.</li> <li>Declare an AutoConnectUpdate object with the update server address and the HTTP port as parameters.</li> <li>Invokes AutoConnect::begin function.</li> <li>Attach the AutoConnectUpdate object to AutoConnect using AutoConnectUpdate::attach function.</li> <li>Invokes AutoConnect::handleClient function in the <code>loop()</code>.</li> </ol> <pre><code>#include &lt;ESP8266WiFi.h&gt;\n#include &lt;ESP8266WebServer.h&gt;\n#include &lt;AutoConnect.h&gt;\n\nESP8266WebServer server;                          // Step #1\nAutoConnect portal;                               // Step #2\nAutoConnectUpdate update(\"192.168.0.100\", 8000);  // Step #3\n\nvoid setup() {\nif (portal.begin()) {     // Step #4\n    update.attach(portal);  // Step #5\n  }\n}\n\nvoid loop() {\n  portal.handleClient();    // Step #6\n}\n</code></pre> <p></p>"},{"location":"otaserver.html#behavior-of-the-autoconnectupdate-class","title":"Behavior of the AutoConnectUpdate class","text":"<p>A sketch incorporating the AutoConnectUpdate class has an extended menu item as UPDATE in the AutoConnect menu. UPDATE as menu item will be attached by the AutoConnectUpdate automatically.</p> <p>When an UPDATE item started, its first action is requesting a catalog list of updatable binary sketch files to the update server. Then the update server sends back the catalog list of stored binary sketch files to a client which is the ESP module. The AutoConnectUpdate class will display responded list to a custom Web page1 on the browser.</p> <p> </p> <p>The substance of Available firmware list is a custom Web page by AutoConnectAux, and you can select the target binary sketch file with the radio button (AutoConnectRadio). A progress bar will appear to notify the updating status once the update has begun. When the update finished, the ESP module will reset automatically to launch a new firmware.</p> <p> </p> <p>The AutoConnectUpdate class performs the above series of operations in conjunction with the update server. All you need to do is attach the AutoConnectUpdate class to AutoConnect and execute the AutoConnect::handleClient function in the <code>loop()</code>.</p>"},{"location":"otaserver.html#update-server-for-the-autoconnectupdate-class","title":"Update server for the AutoConnectUpdate class","text":"<p>The above series of operations using AutoConnectUpdate class requires an update server that can work with it. AutoConnect provides an update server script implemented in Python. This server script conforms to a sketch that uses the AutoConnectUpdate class as an update client agent.2</p> <p>In the OTA platform, you can place the update server operated by the script in a location that is reachable from the ESP module on the network.</p> <pre><code>updateserver.py [-h] [--port PORT] [--bind IP_ADDRESS] [--catalog CATALOG] [--log LOG_LEVEL]\n</code></pre> --help | -hShow help message and exit. --port | -pSpecifies PORT number (Default: 8000) --bind | -bSpecifies the IP address to which the update server binds. Usually, it is the host address of the update server. When multiple NICs configured, specify one of the IP addresses. (Default: HOST IP or 127.0.0.0) --catalog | -dSpecifies the directory path on the update server that contains the binary sketch files. (Default: The current directory) --log | -lSpecifies the level of logging output. It accepts the Logging Levels specified in the Python logging module. <p>updateserver.py usage</p> <ol> <li> <p>Python    First, prepare a Python environment. It is also possible with a tiny single-board computer like the raspberry pi. Popular distributions such as Ubuntu for Linux include Python. You can easily set up a Python 2 or 3 environment. If you are using a Mac, you already have the Python 2 environment. macOS is equipped with Python 2.7 by default. In the case of Windows OS, it is necessary to install the Python environment intentionally. Please refer to the Python official page to install Python in your environment.</p> </li> <li> <p>Deploy the binary sketch files    Use the Arduino IDE to output a binary file of sketches and deploy it3 under the update server. The path which specifies for the --catalog option of updateServer.py is the path of the binary sketch files you deployed.</p> </li> <li> <p>Start updateserver.py    For example, to start the update server on the host with IP address 172.16.1.10 using 8080 port4, execute the following command:   <pre><code>python updateserver.py --port 8080 --bind 172.16.1.10 --catalog bin --log debug\n</code></pre>   In this example assumes that the binary sketch files are deployed under the path <code>bin</code> from the current directory.</p> </li> </ol> <p>Limitations of the updateserver.py</p> <p>The updateserver.py script equips only the minimum facility because it assumes a private small OTA platform without identifying individual modules and version restrictions etc. To operate a larger OTA platform, it is necessary to identify the individual ESP module and to consider version control and security.</p>"},{"location":"otaserver.html#http-contents-and-the-sequence-for-the-autoconnectupdate-class","title":"HTTP contents and the sequence for the AutoConnectUpdate class","text":"<p>You can also equip an update server that works with the AutoConnectUpdate class. It can be improved more widely applicable by adding extensions such as version control and authentication to the updateserver.py script. It is necessary to understand the specifications related to HTTP data streams and sequences to enhance the update server that the AutoConnectUpdate class assumes.</p> <p>This section describes the contents of the HTTP data stream required by the communication with AutoConnectUpdate class. To work correctly with the AutoConnectUpdate class, the update server must meet two requirements:</p> <ul> <li>The update server notifies the catalog list of updatable binary files which stored in the update server to the client agent. 5</li> <li>Send an updating binary file and MD5 hash to a client in response to URI request (HTTP GET). 6</li> </ul> <p>Above requirements will be implemented on along the HTTP protocol. The AutoConnectUpdate class requests an update server to notify the client for a catalog list of binary sketch files using an HTTP URL query string. The specifications of the HTTP query and the contents of the catalog list to be returned are as follows:</p>"},{"location":"otaserver.html#1-http-url-query-for-the-catalog-list-of-the-updatable","title":"1. HTTP URL query for the catalog list of the updatable","text":"<pre><code>[address]/_catalog?op=list&amp;path=[path]\n</code></pre> addressURL of the update server /_catalogRequest path, it is fixed. opOperation command for the update server. Currently, only 'list' occurs. pathPath containing the updatable binary files on the update server."},{"location":"otaserver.html#2-the-catalog-list-content","title":"2. The catalog list content","text":"<p>The response (that is, the catalog list) to the above query from the server is the following specification in JSON format.</p> <pre><code>{\n\"name\" : FILE_NAME,\n\"type\" : FILE_TYPE,\n\"date\" : FILE_TIMESTAMP_DATED,\n\"time\" : FILE_TIMESTAMP_TIMED,\n\"size\" : FILE_SIZE\n}\n</code></pre> nameBinary sketch file name for update (String) typeOne of 'bin', 'directory' or 'file'. AutoConnect Update recognizes only file types of 'bin' as update targets. (String) dateFile update date. AutoConnect v1.0.0 treats the file update date as an annotation and is not equip the version control feature yet. (String) timeFile update time. AutoConnect v1.0.0 treats the file update date as an annotation and is not equip the version control feature yet. (String) sizeFile byte count (Numeric) <p>The above JSON object is one entry. The actual catalog list is an array of this entry since it  assumes that an update server will provide multiple update binary files in production. The update server should respond with the MIME type specified as <code>application/json</code> for the catalog list.7</p>"},{"location":"otaserver.html#3-the-binary-sketch-file-used-for-updating","title":"3. The binary sketch file used for updating","text":"<p>The AutoConnectUpdate class issues a HTTP GET request with the specified host address and URI. The update server responds by sending back a binary sketch file with the following header:</p> <pre><code>Content-Type: application/octet-stream\nContent-Disposition: attachment; filename=\"BINARY_SKETCH_FILE_NAME\"\nContent-Length: LENGTH_OF_CONTENT\nx-MD5: HEXDIGEST\n</code></pre> <p>The header x-MD5 is a 128-bit hash value (digest in hexadecimal) that represents the checksum of the binary sketch file for updates required for the ESP8266HTTPUpdate class.</p> <ol> <li> <p>You can scroll horizontally on the browser to see the timestamp and file size that the catalog list contains.\u00a0\u21a9</p> </li> <li> <p>The folders containing the script: For Python2: AUTOCONNECT_LIBRARY_PATH/src/updateserver/python2 For Python3: AUTOCONNECT_LIBRARY_PATH/src/updateserver/python3\u00a0\u21a9</p> </li> <li> <p>Deploying the binary sketch file output by Arduino IDE is usually just copying to the folder for deployment. However, its folder must be accessible from the updateserver.py script.\u00a0\u21a9</p> </li> <li> <p>The port of the update server and the port used by the AutoConnectUpdate class must be the same.\u00a0\u21a9</p> </li> <li> <p>The client agent is an instance of the AutoConnectUpdate class.\u00a0\u21a9</p> </li> <li> <p>The client agent will send its URI request to the update server.\u00a0\u21a9</p> </li> <li> <p>It should be represented as <code>Content-Type: application/json</code> in the HTTP response header.\u00a0\u21a9</p> </li> </ol>"},{"location":"otaupdate.html","title":"OTA Updates","text":"<p>Only for AutoConnect</p> <p>AutoConnect OTA features are valid only for AutoConnect; they are not available for AutoConnectCore.</p>"},{"location":"otaupdate.html#ota-updates-with-autoconnect","title":"OTA Updates with AutoConnect","text":"<p>AutoConnect provides two type platforms for updating the binary sketch in the ESP8266 or ESP32 module via OTA. They correspond to the Web Browser Update and HTTP Server Update whiches mentioned in the ESP8266 Arduino Core documentation.</p> <p>The update behavior using a web browser as the client that supplies the binary sketch file for update follows the scenario assumed by the ESP8266 Arduino core. Therefore, the user sketch must meet the requirements described in the ESP8266 Arduino Core documentation, but you can easily embed the OTA update feature that able to operate via the web browser by AutoConnect menu. All you need to do is that specify AutoConnectConfig.</p> <p></p> <p>It is for the only the same network</p> <p>This method can apply only if the client browser and the ESP module belong to the same network segment. It cannot work correctly across networks.</p> <p>Another update method using an update server can be applied more broadly than using a web browser. This method can also update the ESP module over the Internet if you can secure the correct route and transparency between the ESP module and the update server. To configure this platform, you need to have an update server along with using the AutoConnectUpdate class in your sketch.</p> <p></p> <p>Security Disclaimer</p> <p>The security level of the OTA update platform provided by AutoConnect is very weak. No guarantees as to the level of security for your application by the AutoConnect OTA Update is implied.</p>"},{"location":"wojson.html","title":"Custom Web pages w/o JSON","text":""},{"location":"wojson.html#suppress-increase-in-memory-consumption","title":"Suppress increase in memory consumption","text":"<p>Custom Web page processing consumes a lot of memory. AutoConnect will take a whole string of the JSON document for the custom Web pages into memory. The required buffer size for the JSON document of example sketch mqttRSSI reaches approximately 3000 bytes. And actually, it needs twice the heap area. Especially this constraint will be a problem with the ESP8266 which has a heap size poor.</p> <p>AutoConnect can handle custom Web pages without using JSON. In that case, since the ArduinoJson library will not be bound, the Sketch size will also be reduced.</p>"},{"location":"wojson.html#writing-the-custom-web-pages-without-json","title":"Writing the custom Web pages without JSON","text":"<p>To handle the custom Web pages without using JSON, follow the steps below.</p> <ol> <li>Create or define AutoConnectAux for each page.</li> <li>Create or define AutoConnectElement(s).</li> <li>Add AutoConnectElement(s) to AutoConnectAux.</li> <li>Create more AutoConnectAux containing AutoConnectElement(s), if necessary.</li> <li>Register the request handlers for the custom Web pages.</li> <li>Join prepared AutoConnectAux(s) to AutoConnect.</li> <li>Invoke AutoConnect::begin().</li> </ol> <p>In addition to the above procedure, to completely cut off for binding with the ArduinoJson library, turn off the ArduinoJson use indicator which is declared by the AutoConnect definitions. Its declaration is in AutoConnectDefs.h file.1</p> <pre><code>// Comment out the AUTOCONNECT_USE_JSON macro to detach the ArduinoJson.\n#define AUTOCONNECT_USE_JSON\n</code></pre> <p>JSON processing will be disabled</p> <p>Commenting out the AUTOCONNECT_USE_JSON macro invalidates all functions related to JSON processing. If the Sketch is using the JSON function, it will result in a compile error.</p> <p>Exclude the ArduinoJson by each compile-time</p> <p>If you want to exclude ArduinoJson without changing the library code, specify the AUTOCONNECT_NOUSE_JSON directive as a compiler option according to the method described in the FAQ.</p>"},{"location":"wojson.html#implementation-example-without-arduinojson","title":"Implementation example without ArduinoJson","text":"<p>The code excluding JSON processing from the mqttRSSI sketch attached to the library is as follows. (It is a part of code. Refer to mqttRSSI_NA.ino for the whole sketch.)</p> <p> The JSON document for mqttRSSI</p> <p><pre><code>[\n  {\n\"title\": \"MQTT Setting\",\n\"uri\": \"/mqtt_setting\",\n\"menu\": true,\n\"element\": [\n      {\n\"name\": \"header\",\n\"type\": \"ACText\",\n\"value\": \"&lt;h2&gt;MQTT broker settings&lt;/h2&gt;\",\n\"style\": \"text-align:center;color:#2f4f4f;padding:10px;\"\n      },\n      {\n\"name\": \"caption\",\n\"type\": \"ACText\",\n\"value\": \"Publishing the WiFi signal strength to MQTT channel. RSSI value of ESP8266 to the channel created on ThingSpeak\",\n\"style\": \"font-family:serif;color:#4682b4;\"\n      },\n      {\n\"name\": \"mqttserver\",\n\"type\": \"ACInput\",\n\"value\": \"\",\n\"label\": \"Server\",\n\"pattern\": \"^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\\\-]*[a-zA-Z0-9])\\\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\\\-]*[A-Za-z0-9])$\",\n\"placeholder\": \"MQTT broker server\"\n      },\n      {\n\"name\": \"channelid\",\n\"type\": \"ACInput\",\n\"label\": \"Channel ID\",\n\"pattern\": \"^[0-9]{6}$\"\n      },\n      {\n\"name\": \"userkey\",\n\"type\": \"ACInput\",\n\"label\": \"User Key\"\n      },\n      {\n\"name\": \"apikey\",\n\"type\": \"ACInput\",\n\"label\": \"API Key\"\n      },\n      {\n\"name\": \"newline\",\n\"type\": \"ACElement\",\n\"value\": \"&lt;hr&gt;\"\n      },\n      {\n\"name\": \"uniqueid\",\n\"type\": \"ACCheckbox\",\n\"value\": \"unique\",\n\"label\": \"Use APID unique\",\n\"checked\": false\n      },\n      {\n\"name\": \"period\",\n\"type\": \"ACRadio\",\n\"value\": [\n\"30 sec.\",\n\"60 sec.\",\n\"180 sec.\"\n        ],\n\"label\": \"Update period\",\n\"arrange\": \"vertical\",\n\"checked\": 1\n      },\n      {\n\"name\": \"newline\",\n\"type\": \"ACElement\",\n\"value\": \"&lt;hr&gt;\"\n      },\n      {\n\"name\": \"hostname\",\n\"type\": \"ACInput\",\n\"value\": \"\",\n\"label\": \"ESP host name\",\n\"pattern\": \"^([a-zA-Z0-9]([a-zA-Z0-9-])*[a-zA-Z0-9]){1,32}$\"\n      },\n      {\n\"name\": \"save\",\n\"type\": \"ACSubmit\",\n\"value\": \"Save&amp;amp;Start\",\n\"uri\": \"/mqtt_save\"\n      },\n      {\n\"name\": \"discard\",\n\"type\": \"ACSubmit\",\n\"value\": \"Discard\",\n\"uri\": \"/\"\n      }\n    ]\n  },\n  {\n\"title\": \"MQTT Setting\",\n\"uri\": \"/mqtt_save\",\n\"menu\": false,\n\"element\": [\n      {\n\"name\": \"caption\",\n\"type\": \"ACText\",\n\"value\": \"&lt;h4&gt;Parameters saved as:&lt;/h4&gt;\",\n\"style\": \"text-align:center;color:#2f4f4f;padding:10px;\"\n      },\n      {\n\"name\": \"parameters\",\n\"type\": \"ACText\"\n      },\n      {\n\"name\": \"clear\",\n\"type\": \"ACSubmit\",\n\"value\": \"Clear channel\",\n\"uri\": \"/mqtt_clear\"\n      }\n    ]\n  }\n]\n</code></pre>  Exclude the JSON and replace to the AutoConnectElements natively</p> <pre><code>// In the declaration,\n// Declare AutoConnectElements for the page asf /mqtt_setting\nACText(header, \"&lt;h2&gt;MQTT broker settings&lt;/h2&gt;\", \"text-align:center;color:#2f4f4f;padding:10px;\");\nACText(caption, \"Publishing the WiFi signal strength to MQTT channel. RSSI value of ESP8266 to the channel created on ThingSpeak\", \"font-family:serif;color:#4682b4;\");\nACInput(mqttserver, \"\", \"Server\", \"^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\\\-]*[a-zA-Z0-9])\\\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\\\-]*[A-Za-z0-9])$\", \"MQTT broker server\");\nACInput(channelid, \"\", \"Channel ID\", \"^[0-9]{6}$\");\nACInput(userkey, \"\", \"User Key\");\nACInput(apikey, \"\", \"API Key\");\nACElement(newline, \"&lt;hr&gt;\");\nACCheckbox(uniqueid, \"unique\", \"Use APID unique\");\nACRadio(period, { \"30 sec.\", \"60 sec.\", \"180 sec.\" }, \"Update period\", AC_Vertical, 1);\nACSubmit(save, \"Start\", \"mqtt_save\");\nACSubmit(discard, \"Discard\", \"/\");\n\n// Declare the custom Web page as /mqtt_setting and contains the AutoConnectElements\nAutoConnectAux mqtt_setting(\"/mqtt_setting\", \"MQTT Setting\", true, {\n  header,\n  caption,\n  mqttserver,\n  channelid,\n  userkey,\n  apikey,\n  newline,\n  uniqueid,\n  period,\n  newline,\n  save,\n  discard\n});\n\n// Declare AutoConnectElements for the page as /mqtt_save\nACText(caption2, \"&lt;h4&gt;Parameters available as:&lt;/h4&gt;\", \"text-align:center;color:#2f4f4f;padding:10px;\");\nACText(parameters);\nACSubmit(clear, \"Clear channel\", \"/mqtt_clear\");\n\n// Declare the custom Web page as /mqtt_save and contains the AutoConnectElements\nAutoConnectAux mqtt_save(\"/mqtt_save\", \"MQTT Setting\", false, {\n  caption2,\n  parameters,\n  clear\n});\n\n// In the setup(),\n// Join the custom Web pages and performs begin\n  portal.join({ mqtt_setting, mqtt_save });\n  portal.begin();\n</code></pre> <ol> <li> <p>Detaching the ArduinoJson library reduces the Sketch size by approximately 10K bytes.\u00a0\u21a9</p> </li> </ol>"}]}